
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="baidu-site-verification" content="code-o47qQmYL2s" />
    <title>iOS AutoLayout 笔记 - 小时光のホームページ</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="iOS,Swift,xiaoshiguang,"> 
    <meta name="description" content="小时光


1、What’s Auto Layout
&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;Auto Layout是由苹果公司UIKit框架提供的一个用于动态计算U,"> 
    <meta name="author" content="小时光"> 
    <link rel="alternative" href="atom.xml" title="小时光のホームページ" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>
<meta name="generator" content="Hexo 5.3.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">小时光のホームページ</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://dengfeng520.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">iOS AutoLayout 笔记</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">iOS AutoLayout 笔记</h1>
        <div class="stuff">
            <span>四月 28, 2020</span>
            

        </div>
        <div class="content markdown">
            <h6 align='right'>小时光</h6>

<blockquote>
<h3 id="1、What’s-Auto-Layout"><a href="#1、What’s-Auto-Layout" class="headerlink" title="1、What’s Auto Layout"></a>1、What’s Auto Layout</h3></blockquote>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<code>Auto Layout</code>是由苹果公司<code>UIKit</code>框架提供的一个用于动态计算<code>UIView</code>及其子类的大小和位置的库。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;说到<code>Auto Layout</code>就不得不说<code>Cassowary</code>算法，因为<code>Auto Layout</code>是构建在<code>Cassowary</code>算法的基础之上的。1997年，<code>Auto Layout</code>用到的布局算法论文发表，被称为高效的线性方程求解算法。2011年苹果利用<code>Cassowary</code>算法为开发者提供了<code>Auto Layout</code>自动布局库中。由于<code>Cassowary</code>算法的本身的优秀，不仅是苹果公司，许多开发者将其运用到各个不同的开发语言中，如<code>JavaScript、ASP.NET、Java、C++</code>等都有运用<code>Cassowary</code>算法的库。从这里也可以看出<code>Cassowary</code>算法自身的优秀和先进性，不然不会被运用的如此广泛。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;苹果公司在<code>iOS 6</code>系统时引入了<code>Auto Layout</code>，但是直到现在已经更新到<code>iOS 12</code>了，还有很多开发者还是不愿使用<code>Auto Layout</code>。主要是对其反人类的语法以及对其性能问题的担忧。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;针对<code>Auto Layout</code>的一些问题，在<code>iOS 9</code>发布时，苹果推出了更简洁语法的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/nslayoutanchor">NSLayoutAnchor</a>。同时发布了模仿前端<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/flex-grammar.html">Flexbox</a>布局思路的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uistackview">UIStackView</a>，以此为开发者在自动布局上提供更好的选择。</p>
<p>在苹果<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2018/220">WWDC 2018 High Performance Auto Layout</a>中苹果工程师说: iOS 12将大幅度提升Auto Layout性能，使滑动屏幕时达到满帧。<br>在<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2018/202/">WWDC 2018 What’s New in Cocoa Touch</a>苹果的工程师说了iOS 12对Auto Layout优化后的表现。<br><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a24c8ba66df4a9fb6e7d38fabf2c533~tplv-k3u1fbpfcp-zoom-1.image" alt="WWDC 2018 What&#39;s New in Cocoa Touch"><br>从图上可以看出，<code>iOS 11</code>中视图嵌套的数量的性能快成指数级别增长了，在<code>iOS 12</code>中已经基本和手写frame布局的性能类似了。</p>
<p>从<code>iOS 6</code>到<code>iOS 12</code>，苹果也在不断的优化<code>Auto Layout</code>的性能，同时为开发者提供更简洁的<code>API</code>，如果你还在使用<code>frame</code>手写布局，不妨试试<code>Auto Layout</code>。下面我将介绍<code>iOS</code>中几种常用的布局方法。</p>
<blockquote>
<h3 id="2、Auto-Layout各个版本不同用法"><a href="#2、Auto-Layout各个版本不同用法" class="headerlink" title="2、Auto Layout各个版本不同用法"></a>2、Auto Layout各个版本不同用法</h3></blockquote>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如我要设置一个宽高为120,居中显示的View，效果如下图：<br><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a81951bcc0e40d29af0ab2a38f35db0~tplv-k3u1fbpfcp-zoom-1.image" alt="AutoLayoutdemo3.png"></p>
<h5 id="1、用frame手写布局"><a href="#1、用frame手写布局" class="headerlink" title="1、用frame手写布局"></a>1、用frame手写布局</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UIView *centerView &#x3D; [[UIView alloc] init];</span><br><span class="line">centerView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">[self.view addSubview:centerView];</span><br><span class="line">CGFloat width &#x3D; self.view.frame.size.width;</span><br><span class="line">CGFloat height &#x3D; self.view.frame.size.height;</span><br><span class="line">[centerView setFrame:CGRectMake(width &#x2F; 2 - (60), height &#x2F; 2 - (60), 120, 120)];</span><br></pre></td></tr></table></figure>
<h5 id="2、iOS-6提供的NSLayoutConstraint语法添加约束"><a href="#2、iOS-6提供的NSLayoutConstraint语法添加约束" class="headerlink" title="2、iOS 6提供的NSLayoutConstraint语法添加约束"></a>2、iOS 6提供的NSLayoutConstraint语法添加约束</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">centerView.translatesAutoresizingMaskIntoConstraints &#x3D; NO;</span><br><span class="line"> NSLayoutConstraint *consW &#x3D; [NSLayoutConstraint constraintWithItem:centerView</span><br><span class="line">                                                          attribute:NSLayoutAttributeWidth</span><br><span class="line">                                                          relatedBy:NSLayoutRelationEqual</span><br><span class="line">                                                             toItem:self.view</span><br><span class="line">                                                          attribute:NSLayoutAttributeWidth</span><br><span class="line">                                                         multiplier:0</span><br><span class="line">                                                           constant:120.0</span><br><span class="line">                              ];</span><br><span class="line"> NSLayoutConstraint *consH &#x3D; [NSLayoutConstraint constraintWithItem:centerView</span><br><span class="line">                                                          attribute:NSLayoutAttributeHeight</span><br><span class="line">                                                          relatedBy:NSLayoutRelationEqual</span><br><span class="line">                                                             toItem:self.view attribute:NSLayoutAttributeHeight</span><br><span class="line">                                                         multiplier:0</span><br><span class="line">                                                           constant:120.0</span><br><span class="line">                              ];</span><br><span class="line"> NSLayoutConstraint *consX &#x3D; [NSLayoutConstraint constraintWithItem:centerView</span><br><span class="line">                                                          attribute:NSLayoutAttributeCenterX</span><br><span class="line">                                                          relatedBy:NSLayoutRelationEqual</span><br><span class="line">                                                             toItem:self.view</span><br><span class="line">                                                          attribute:NSLayoutAttributeCenterX</span><br><span class="line">                                                         multiplier:1.0</span><br><span class="line">                                                           constant:0.0</span><br><span class="line">                              ];</span><br><span class="line"> NSLayoutConstraint *consY &#x3D; [NSLayoutConstraint constraintWithItem:centerView</span><br><span class="line">                                                          attribute:NSLayoutAttributeCenterY</span><br><span class="line">                                                          relatedBy:NSLayoutRelationEqual</span><br><span class="line">                                                             toItem:self.view</span><br><span class="line">                                                          attribute:NSLayoutAttributeCenterY</span><br><span class="line">                                                         multiplier:1.0</span><br><span class="line">                                                           constant:0.0</span><br><span class="line">                              ];</span><br><span class="line"> [self.view addConstraints:@[consW,consH,consX,consY]];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3、用VFL语法"><a href="#3、用VFL语法" class="headerlink" title="3、用VFL语法"></a>3、用VFL语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">centerView.translatesAutoresizingMaskIntoConstraints &#x3D; NO;</span><br><span class="line">   [self.view addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:[centerView(120)]&quot; options:0 metrics:nil views:views]];</span><br><span class="line">   [self.view addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;[centerView(120)]&quot; options:0 metrics:nil views:views]];</span><br><span class="line">   [self.view addConstraint:[NSLayoutConstraint constraintWithItem:centerView attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterY multiplier:1 constant:0]];</span><br><span class="line">   [self.view addConstraint:[NSLayoutConstraint constraintWithItem:centerView attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterX multiplier:1 constant:0]];</span><br></pre></td></tr></table></figure>
<h5 id="4、使用第三方开源框架Masonry或SnapKit"><a href="#4、使用第三方开源框架Masonry或SnapKit" class="headerlink" title="4、使用第三方开源框架Masonry或SnapKit"></a>4、使用第三方开源框架<a target="_blank" rel="noopener" href="https://github.com/SnapKit/Masonry">Masonry</a>或<a target="_blank" rel="noopener" href="https://github.com/SnapKit/SnapKit">SnapKit</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof (self) weakSelf &#x3D; self;</span><br><span class="line">[centerView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.size.mas_equalTo(CGSizeMake(120, 120));</span><br><span class="line">    make.center.equalTo(weakSelf.view);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let centerView:UIView &#x3D; UIView.init()</span><br><span class="line">view.addSubview(centerView)</span><br><span class="line">centerView.backgroundColor &#x3D; UIColor.red</span><br><span class="line">centerView.snp.makeConstraints &#123; (make) in</span><br><span class="line">   make.width.equalTo(120)</span><br><span class="line">   make.height.equalTo(120)</span><br><span class="line">   make.center.equalTo(view)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5、使用iOS-9之后Apple提供的NSLayoutAnchor"><a href="#5、使用iOS-9之后Apple提供的NSLayoutAnchor" class="headerlink" title="5、使用iOS 9之后Apple提供的NSLayoutAnchor"></a>5、使用iOS 9之后Apple提供的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/nslayoutanchor">NSLayoutAnchor</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let centerView:UIView &#x3D; UIView.init()</span><br><span class="line">view.addSubview(centerView)</span><br><span class="line">centerView.backgroundColor &#x3D; UIColor.red</span><br><span class="line">centerView.translatesAutoresizingMaskIntoConstraints &#x3D; false</span><br><span class="line">centerView.centerXAnchor.constraint(equalTo: view.centerXAnchor, constant: 0).isActive &#x3D; true</span><br><span class="line">centerView.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: 0).isActive &#x3D; true</span><br><span class="line">centerView.widthAnchor.constraint(equalToConstant: 120).isActive &#x3D; true</span><br><span class="line">centerView.heightAnchor.constraint(equalToConstant: 120).isActive &#x3D; true</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;通过上面的代码对比，使用<code>frame</code>手写布局只要几行代码就搞定了，使用<code>NSLayoutConstraint</code>语法和<code>VFL</code>语法是最复杂的，尤其是<code>NSLayoutConstraint</code>语法要用30多行代码才能是想同样的效果，代码行数越多出错的概率也就成正比上升，所以这就是很多开发者不愿使用<code>Auto Layout</code>（或者说不愿意使用系统提供API来实现）的原因之一吧。</p>
<p> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如果你的<code>App</code>要兼容<code>iOS 9</code>以下的各个版本，建议使用<a target="_blank" rel="noopener" href="https://github.com/SnapKit/Masonry">Masonry</a>,如果只兼容iOS 9以上的版本，建议使用<a target="_blank" rel="noopener" href="https://github.com/SnapKit/SnapKit">SnapKit</a>或者系统提供的<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/nslayoutconstraint">NSLayoutAnchor</a> API，毕竟<code>Masonry</code>这个库已经2年没有更新了。</p>
<p>在这里我推荐优先使用<code>NSLayoutAnchor</code>，第三方的开源库随时都面临着一些问题：</p>
<ul>
<li><code> iOS</code> 系统版本的更新造成的适配和兼容问题，如果是开源代码要等到苹果发布新版本，代码的作者再做兼容和适配</li>
<li> 代码的作者停止更新这些代码了，这对我们开发者来说就很被动了，我们要么自己修改这些代码，要么选择更新的开源代码</li>
<li> 使用系统库可在打包时可以减少包大小</li>
</ul>
<blockquote>
<h3 id="3、Auto-Layout的生命周期"><a href="#3、Auto-Layout的生命周期" class="headerlink" title="3、Auto Layout的生命周期"></a>3、<code>Auto Layout</code>的生命周期</h3></blockquote>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;前面说到苹果的<code>Auto Layout</code>是基于<code>Cassowary</code>算法的，苹果在此基础上提供了一套<code>Layout Engine</code>引擎，由它来管理页面的布局，来完成创建、更新、销毁等。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;在<code>APP</code>启动后，会开启一个常驻线程来监听约束变化，当约束发生变化后会出发<code>Deffered Layout Pass</code>(延迟布局传递)，在里面做容错处理（如有些视图在更新约束时没有确定或缺失布局申明），完成后进入约束监听变化的状态。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;当下一次刷新视图（如调用<code>layoutIfNeeded()</code>）时，<code>Layout Engine</code>会从上到下调用<code>layoutSubviews()</code>，然后通过<code>Cassowary</code>算法计算各个子视图的大小和位置，算出来后将子视图的<code>frame</code>从<code>layout Engine</code>里拷贝出来，在之后的处理就和手写<code>frame</code>的绘制、渲染的过程一样了。使用<code>Auto Layout</code>和手写<code>frame</code>多的工作就在布局计算上。</p>
<blockquote>
<h3 id="4、NSLayoutAnchor常用属性"><a href="#4、NSLayoutAnchor常用属性" class="headerlink" title="4、NSLayoutAnchor常用属性"></a>4、<code>NSLayoutAnchor</code>常用属性</h3></blockquote>
<ul>
<li>leadingAnchor</li>
<li>trailingAnchor</li>
<li>leftAnchor</li>
<li>rightAnchor</li>
<li>topAnchor</li>
<li>bottomAnchor</li>
<li>widthAnchor</li>
<li>heightAnchor</li>
<li>centerXAnchor</li>
<li>centerYAnchor</li>
<li>firstBaselineAnchor</li>
<li>lastBaselineAnchor</li>
</ul>
<p>对于<code>NSLayoutAnchor</code>的一些常用属性，通过其命名就能看出来其作用，这里不做赘述，如果想了解更多请查阅<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/nslayoutanchor#//apple_ref/occ/instm/NSLayoutAnchor/constraintEqualToAnchor:constant:">Apple Developer NSLayoutAnchor</a>。</p>
<blockquote>
<h3 id="5、Auto-Layout几个更新约束的方法"><a href="#5、Auto-Layout几个更新约束的方法" class="headerlink" title="5、Auto Layout几个更新约束的方法"></a>5、Auto Layout几个更新约束的方法</h3></blockquote>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout">setNeedsLayout</a>: 告知页面需要更新，但是不会立刻开始更新。执行后会立刻调用<code>layoutSubviews</code>。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiview/1622507-layoutifneeded">layoutIfNeeded</a>: 告知页面布局立刻更新。所以一般都会和<code>setNeedsLayout</code>一起使用。如果希望立刻生成新的<code>frame</code>需要调用此方法，利用这点一般布局动画可以在更新布局后直接使用这个方法让动画生效。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews">layoutSubviews</a>: 更新子<code>View</code>约束</p>
</li>
<li><p> <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints">setNeedsUpdateConstraints</a>:需要更新约束，但是不会立刻开始</p>
</li>
<li><p> <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiview/1622595-updateconstraintsifneeded">updateConstraintsIfNeeded</a>:立刻更新约束</p>
</li>
<li><p> <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints">updateConstraints</a>:更新<code>View</code>约束</p>
</li>
</ul>
<blockquote>
<h3 id="6、NSLayoutAnchor使用注意事项"><a href="#6、NSLayoutAnchor使用注意事项" class="headerlink" title="6、NSLayoutAnchor使用注意事项"></a>6、<code>NSLayoutAnchor</code>使用注意事项</h3></blockquote>
<h5 id="1、在使用NSLayoutAnchor为视图添加约束时一定要先把translatesAutoresizingMaskIntoConstraints设置false"><a href="#1、在使用NSLayoutAnchor为视图添加约束时一定要先把translatesAutoresizingMaskIntoConstraints设置false" class="headerlink" title="1、在使用NSLayoutAnchor为视图添加约束时一定要先把translatesAutoresizingMaskIntoConstraints设置false"></a>1、在使用<code>NSLayoutAnchor</code>为视图添加约束时一定要先把<code>translatesAutoresizingMaskIntoConstraints</code>设置<code>false</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">centerView.translatesAutoresizingMaskIntoConstraints &#x3D; false</span><br></pre></td></tr></table></figure>
<h5 id="2、在使用safeAreaLayoutGuide适配iPhone-X-等机型时要对iOS-11之前的系统做适配，否则会导致低版本系统上程序Crash"><a href="#2、在使用safeAreaLayoutGuide适配iPhone-X-等机型时要对iOS-11之前的系统做适配，否则会导致低版本系统上程序Crash" class="headerlink" title="2、在使用safeAreaLayoutGuide适配iPhone X 等机型时要对iOS 11之前的系统做适配，否则会导致低版本系统上程序Crash"></a>2、在使用<code>safeAreaLayoutGuide</code>适配<code>iPhone X</code> 等机型时要对<code>iOS 11</code>之前的系统做适配，否则会导致低版本系统上程序Crash</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if #available(iOS 11.0, *) &#123;</span><br><span class="line">     tableView.topAnchor.constraint(equalTo: self.view.safeAreaLayoutGuide.topAnchor, constant: 0).isActive &#x3D; true</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">     tableView.topAnchor.constraint(equalTo: self.view.topAnchor, constant: 0).isActive &#x3D; true</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="3、设置约束后要将其激活，即设置isActive为true"><a href="#3、设置约束后要将其激活，即设置isActive为true" class="headerlink" title="3、设置约束后要将其激活，即设置isActive为true"></a>3、设置约束后要将其激活，即设置<code>isActive</code>为<code>true</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let centerX: NSLayoutConstraint &#x3D; centerView.centerXAnchor.constraint(equalTo: view.centerXAnchor, constant: 0)</span><br><span class="line">centerX.isActive &#x3D; true</span><br></pre></td></tr></table></figure>
<h5 id="4、leadingAnchor-不要和-leftAnchor混用"><a href="#4、leadingAnchor-不要和-leftAnchor混用" class="headerlink" title="4、leadingAnchor 不要和 leftAnchor混用"></a>4、<code>leadingAnchor</code> 不要和 <code>leftAnchor</code>混用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">centerView.leadingAnchor.constraint(equalTo: view.leftAnchor, constant: 0).isActive &#x3D; true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">centerView.leftAnchor.constraint(equalTo: view.leadingAnchor, constant: 0).isActive &#x3D; true</span><br></pre></td></tr></table></figure>
<p>以上2种写法，在编译时不会出现任何问题，但是在运行时就会报错，并会导致程序Crash,官方的说法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">While the NSLayoutAnchor class provides additional type checking, it is still possible to create </span><br><span class="line">invalid constraints. For example, the compiler allows you to constrain one view’s leadingAnchor</span><br><span class="line"> with another view’s leftAnchor, since they are both NSLayoutXAxisAnchor instances. However, </span><br><span class="line">Auto Layout does not allow constraints that mix leading and trailing attributes with left or right </span><br><span class="line">attributes. As a result, this constraint crashes at runtime.</span><br></pre></td></tr></table></figure>
<p>同理，<code>trailingAnchor</code>和<code>rightAnchor</code>也不能混用。</p>
<h5 id="5、如何刷新某个约束"><a href="#5、如何刷新某个约束" class="headerlink" title="5、如何刷新某个约束"></a>5、如何刷新某个约束</h5><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如我要修改一个<code>UIView</code>的宽度：<br>通过代码添加约束，可把<code>UIView</code>的宽度设置类属性，然后在需要的地方修改<code>constant</code>的参数，然后在刷新约束即可，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var centerView: UIView! </span><br><span class="line">var centerWidth: NSLayoutConstraint! </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">self.centerView &#x3D; UIView.init()</span><br><span class="line">view.addSubview(self.centerView)</span><br><span class="line">self.centerView.backgroundColor &#x3D; UIColor.red</span><br><span class="line">self.centerView.translatesAutoresizingMaskIntoConstraints &#x3D; false</span><br><span class="line">self.centerView.centerXAnchor.constraint(equalTo: view.centerXAnchor, constant: 0).isActive &#x3D; true</span><br><span class="line">self.centerView.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: 0).isActive &#x3D; true</span><br><span class="line">self.centerWidth &#x3D; self.centerView.widthAnchor.constraint(equalToConstant: 120)</span><br><span class="line">self.centerWidth.isActive &#x3D; true</span><br><span class="line">self.centerView.heightAnchor.constraint(equalToConstant: 120).isActive &#x3D; true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.centerWidth.constant &#x3D; 250</span><br><span class="line">weak var weakSelf &#x3D; self</span><br><span class="line">UIView.animate(withDuration: 0.35, animations: &#123;</span><br><span class="line">   weakSelf?.centerView.superview?.layoutIfNeeded()</span><br><span class="line">&#125;) &#123; (finished) in</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd12831dda304b3e9c4f5666f408e300~tplv-k3u1fbpfcp-zoom-1.image" alt="layoutDemo5.gif"></p>
<p>如果是<code>xib</code>或者<code>storyboard</code>，那就更简单了，直接摁住键盘<code>control</code>键，拖到对应的类里，然后在需要的地方修改约束并刷新即可。操作如下：<br><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e4c22a448af4ecfb08ac31267efce56~tplv-k3u1fbpfcp-zoom-1.image" alt="AutoLayoutdemo6.gif"></p>
<h5 id="6、设置宽高比"><a href="#6、设置宽高比" class="headerlink" title="6、设置宽高比"></a>6、设置宽高比</h5><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;在开发中，我们会遇到一些需求要求根据<code>UIView</code>的宽高比来设置约束，如一般情况下显示视频的宽高比是16:9，通过代码设置宽高比如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">centerView.heightAnchor.constraint(equalToConstant: 90).isActive &#x3D; true</span><br><span class="line">centerView.widthAnchor.constraint(equalTo: centerView.heightAnchor, multiplier: 16 &#x2F; 9).isActive &#x3D; true</span><br></pre></td></tr></table></figure>
<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d907322de88f4bc28837d6d72acef973~tplv-k3u1fbpfcp-zoom-1.image" alt="layoutDemo7.png"></p>
<blockquote>
<h3 id="7、Auto-Layout自适应UITableViewCell高度使用"><a href="#7、Auto-Layout自适应UITableViewCell高度使用" class="headerlink" title="7、Auto Layout自适应UITableViewCell高度使用"></a>7、<code>Auto Layout</code>自适应<code>UITableViewCell</code>高度使用</h3></blockquote>
<h5 id="1、-使用rowHeight设置高度"><a href="#1、-使用rowHeight设置高度" class="headerlink" title="1、 使用rowHeight设置高度"></a>1、 使用<code>rowHeight</code>设置高度</h5><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;一般情况下，如果<code>UITableView</code>的每个<code>Cell</code>高度是固定的我们可以直接指定一个值即可，如果没有设置<code>UITableView</code>的高度，系统会默认设置<code>rowHeight</code>高度是44。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableview.rowHeight &#x3D; 44;</span><br></pre></td></tr></table></figure>
<p>也可以通过UITableViewDelegate的代理来设置UItableView的高度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;</span><br><span class="line">       return 50</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果通过手动计算每个<code>UItableViewCell</code>的高度，也在这个代理中实现，通过计算返回每个<code>UItableViewCell</code>的高度。</p>
<h5 id="2、使用estimatedRowHeight设置高度"><a href="#2、使用estimatedRowHeight设置高度" class="headerlink" title="2、使用estimatedRowHeight设置高度"></a>2、使用<code>estimatedRowHeight</code>设置高度</h5><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<code>UItableView</code>继承自<code>UIScrollView</code>,<code>UIScrollView</code>的滚动需要设置其<code>contentSize</code>后，然后根据自身的<code>bounds、contentInset、contentOffset</code>等属性来计算出可滚动的长度。而<code>UITableView</code>在初始化时并不知道这些参数，只有在设置了<code>delegate</code>和<code>dataSource</code>之后，根据创建的<code>UITableViewCell</code>的个数和加载的<code>UITableViewCell</code>的高度之后才能算出可滚动的长度。</p>
<p>在使用<code>Auto Layout</code>自适应<code>UITableViewCell</code>高度时应提前设置一个估算值，当然这个估算值越接近真实值越好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tableView.rowHeight &#x3D; UITableView.automaticDimension</span><br><span class="line">tableView.estimatedRowHeight &#x3D; 200</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;</span><br><span class="line">   return 200    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/207509923e2b4898b3fbbdc502dca252~tplv-k3u1fbpfcp-zoom-1.image" alt="Autolayoutdemo2.png"></p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如上图所示：这个界面就是用<code>Auto Layout + estimatedRowHeight</code>完成自适应高度的，在添加约束时要按照从上到下的书讯设置每一个<code>UIView</code>的顶部（<code>top</code>）到上一个的视图底部的（<code>bottom</code>）距离，同时要计算<code>UITableViewCell</code>内部所有控件的高度。那么问题来了，用户发布的内容详情没有得到数据之前时没办法算出其高度的，此处可以先给内容文字<code>UILabel</code>设置一个默认高度，然后让其根据内容填充自动计算高度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> topicInfoLab.heightAnchor.constraint(greaterThanOrEqualToConstant: 20).isActive &#x3D; true;</span><br><span class="line"> topicInfoLab.font &#x3D; UIFont.init(name: &quot;Montserrat-SemiBold&quot;, size: 12)</span><br><span class="line">topicInfoLab.numberOfLines &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>如果用户发布内容没有图片，直接设置发布内容UILabel距离UITableView距离底部的约束距离即可；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">detailsLab.bottomAnchor.constraint(equalTo: self.contentView.bottomAnchor, constant: -8).isActive &#x3D; true</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果用户发布的内容有图片，那么在计算出每张图片的位置和大小之后，一定要给最后一张图片设置距离<code>UItableViewCell</code>底部(<code>bottom</code>)的约束距离。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(idx, obj) in imageArray.enumerated() &#123;</span><br><span class="line">&#x2F;&#x2F;.....计算图片的大小和位置</span><br><span class="line">if idx &#x3D;&#x3D; imageArray.count - 1 &#123;</span><br><span class="line">   &#x2F;&#x2F;设置最后一张图片距离底部的约束</span><br><span class="line">   photo.bottomAnchor.constraint(equalTo: self.contentView.bottomAnchor, constant: -8).isActive &#x3D; true</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/413e2c97f7a54f48814fb1a20d019eba~tplv-k3u1fbpfcp-zoom-1.image" alt="layoutDemo8.png"></p>
<p>实现思路如上图所示，具体实现的请看<a target="_blank" rel="noopener" href="https://github.com/dengfeng520/One-Swift">代码</a></p>
<blockquote>
<h3 id="8、-Compression-Resistance-Priority-和-Hugging-Priority使用"><a href="#8、-Compression-Resistance-Priority-和-Hugging-Priority使用" class="headerlink" title="8、 Compression Resistance Priority 和 Hugging Priority使用"></a>8、 <code>Compression Resistance Priority</code> 和 <code>Hugging Priority</code>使用</h3></blockquote>
<p><code>Compression Resistance Priority</code> 和 <code>Hugging Priority</code>在实际使用中往往配合使用，分别处理在同义水平线上多个view之间内容过少和内容过多而造成的互相压挤的情况。</p>
<p><code>Hugging Priority</code>的意思就是自包裹的优先级，优先级越高，则优先将尺寸按照控件的内容进行填充。</p>
<p><code>Compression Resistance Priority</code>，意思是说当不够显示内容时，根据这个优先级进行切割。优先级越低，越容易被切掉。</p>
<table>
<thead>
<tr>
<th align="center"><code>ContentHuggingPriority</code></th>
<th align="center">表示当前的<code>UIView</code>的内容不想被拉伸</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>ContentCompressionResistancePriority</code></td>
<td align="center">表示当前的<code>UIView</code>的内容不想被收缩</td>
</tr>
<tr>
<td align="center">默认情况下: <code>HuggingPriority</code> = 250</td>
<td align="center">默认情况下: <code>CompressionResistancePriority</code> = 750</td>
</tr>
</tbody></table>
<p>如设置2个<code>UILabel</code>的拉伸优先级可使用代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fristLab.setContentHuggingPriority(UILayoutPriority(rawValue: 251), for: .horizontal)</span><br><span class="line">secondLab.setContentCompressionResistancePriority(UILayoutPriority(rawValue: 750), for: .horizontal)</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a>9、总结</h3></blockquote>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;本文主要分享了苹果<code>Auto Layout</code>的几种实现方法和注意事项，对于<code>Auto Layout</code>在实际开发中的使用是采用纯代码、还是<code>xib</code> + 代码，还是<code>storyboard</code> + 代码，还是<code>xib</code> + <code>storyboard</code> + 代码的方式实现，主要看团队的要求、个人的习惯，以及<code>App</code>的繁琐程度。<br>对于<code>Auto Layout</code>在视图上的使用，个人建议如果UI比较简单或者单一的界面可使用<code>Auto Layout</code>，如果UI的操作或刷新很复杂的界面，建议还是<code>frame</code> + 手动布局的方式。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://github.com/dengfeng520/RPChat">本文demo，请戳这里</a></p>
<p>友情链接：</p>
<p><a target="_blank" rel="noopener" href="https://ming1016.github.io/2015/11/03/deeply-analyse-autolayout/#more">深入剖析Auto Layout，分析iOS各版本新增特性</a></p>
<p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/85332">Auto Layout 是怎么进行自动布局的，性能如何？</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2018/220">Apple Developer High Performance Auto Layout</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/nslayoutconstraint">Apple Develope NSLayoutConstraint</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2018/202/">WWDC 2018 What’s New in Cocoa Touch</a></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/29307041.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
