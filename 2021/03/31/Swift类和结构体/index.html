
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="baidu-site-verification" content="code-o47qQmYL2s" />
    <title>Swift 类和结构体 - 小时光のホームページ</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="iOS,Swift,xiaoshiguang,"> 
    <meta name="description" content="1、值类型和引用类型在iOS中虚拟内存分为五大内存分区：堆区、栈区、全局区、常量区、代码区。在Swift中根据对象在内存的存储位置不同分为值类型和引用类型。

值类型： Swift中的值类型主要有：,"> 
    <meta name="author" content="小时光"> 
    <link rel="alternative" href="atom.xml" title="小时光のホームページ" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>
<meta name="generator" content="Hexo 5.3.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">小时光のホームページ</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://dengfeng520.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Swift 类和结构体</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Swift 类和结构体</h1>
        <div class="stuff">
            <span>三月 31, 2021</span>
            

        </div>
        <div class="content markdown">
            <h3 id="1、值类型和引用类型"><a href="#1、值类型和引用类型" class="headerlink" title="1、值类型和引用类型"></a>1、值类型和引用类型</h3><p>在iOS中虚拟内存分为五大内存分区：<strong>堆区、栈区、全局区、常量区、代码区</strong>。在Swift中根据对象在内存的存储位置不同分为值类型和引用类型。</p>
<ul>
<li><p>值类型： Swift中的值类型主要有：<code>enum，struct、Array、Dictionary、Tuple</code>等</p>
</li>
<li><p>引用类型：Swift中的引用类型主要有：<code>methods,class,clousre</code></p>
</li>
</ul>
<h5 id="1-1、值类型和引用类型的内存分配和管理方式"><a href="#1-1、值类型和引用类型的内存分配和管理方式" class="headerlink" title="1.1、值类型和引用类型的内存分配和管理方式"></a>1.1、值类型和引用类型的内存分配和管理方式</h5><p>Swift 中的值类型，一般存储于栈内存中（也不一定），由于栈的特性这部分内存是由CPU直接管理和优化的，对于值的copy也是深拷贝(deep copy)，当使用完一个值后系统会立即释放这部分内存。所以存储于栈上的内存在创建、使用、释放都非常效率。</p>
<p>一般情况下，当创建一个<code>struct</code>默认被存储于栈区。当编译器侦测到结构体变量被一个函数闭合的时候，此时这个结构体将存储在堆上。此处可参考<a target="_blank" rel="noopener" href="https://objccn.io/products/advanced-swift/">《Swift 进阶》</a>一书中的<strong>结构体和类章节 闭包和可变性</strong>小节的内容。</p>
<p>Swift中的引用类型，一般存储于堆区，苹果采用ARC的方式来管理这部分内存，对于这部分内存的追踪就是对引用计数的追踪，当类对象被引用时引用计数+1，当引用计数为0时，ARC会释放这部分内存。</p>
<h3 id="2、复杂的值类型struct"><a href="#2、复杂的值类型struct" class="headerlink" title="2、复杂的值类型struct"></a>2、复杂的值类型<code>struct</code></h3><p>Swift提供了多种可以结构化存储数据的方式，<code>struct、enum、class</code>等。这里先说在开发中经常用作<code>Model</code>来使用的<code>struct</code>。</p>
<h5 id="2-1、struct的定义和初始化"><a href="#2-1、struct的定义和初始化" class="headerlink" title="2.1、struct的定义和初始化"></a>2.1、struct的定义和初始化</h5><p>从定义一个<code>struct</code>开始，这里我定义一个用来表示颜色的<code>struct</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> red: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> green: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> blue: <span class="type">Double</span></span><br><span class="line">    <span class="comment">// 透明度</span></span><br><span class="line">    <span class="keyword">var</span> alpha: <span class="type">Double</span>? <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我定义了四个属性，<code>red、double、blue</code>表示红绿蓝三色值，<code>alpha</code>表示透明度。这些属性所占用的内存空间决定了<code>Color</code>的大小。当我定义完四个属性后直接build,没有任何问题，这里首先来了解<code>struct</code>的初始化方法。</p>
<h6 id="2-1-1、Memberwise-initializer"><a href="#2-1-1、Memberwise-initializer" class="headerlink" title="2.1.1、Memberwise initializer"></a>2.1.1、<code>Memberwise initializer</code></h6><p>当我定义一个<code>struct</code>而不为其创建任何<code>init</code>方法，也可以正常运行，这是由于Swift编译器自动为这个<code>struct</code>创建了一个初始化方法，这种<code>init</code>方法叫做<code>Memberwise initializer</code>.当我需要使用这个<code>struct</code>时可以这样初始化一个<code>color</code>对象：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color <span class="operator">=</span> <span class="type">Color</span>(red: <span class="number">200</span>, green: <span class="number">200</span>, blue: <span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<h6 id="2-1-2-、Default-initializer"><a href="#2-1-2-、Default-initializer" class="headerlink" title="2.1.2 、Default initializer"></a>2.1.2 、<code>Default initializer</code></h6><p>如果我想在创建<code>color</code>对象的时候不指定参数,自动的给属性设置默认值，这时有两种方法可供选择：</p>
<ul>
<li><p>在定义每个属性时都为其设置默认值</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> red: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> green: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> blue: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> alpha: <span class="type">Double</span>? <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以在初始化<code>color</code>对象时，不用指定参数来初始化<code>color</code>对象了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color <span class="operator">=</span> <span class="type">Color</span>()</span><br></pre></td></tr></table></figure>
<p>这么做的要求就是在设置属性时必须为每个属性都设置默认值，因为Swift要求<code>init</code>方法必须初始化自定义类型的每一个属性。</p>
</li>
<li><p>在<code>init</code>方法中为每个属性设置默认值</p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> red: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> green: <span class="type">Double</span> </span><br><span class="line">    <span class="keyword">var</span> blue: <span class="type">Double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> alpha: <span class="type">Double</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">red</span>: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span>, <span class="params">green</span>: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span>, <span class="params">blue</span>: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span>, <span class="params">alpha</span>: <span class="type">Double</span>? <span class="operator">=</span> <span class="number">1</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.red <span class="operator">=</span> red</span><br><span class="line">        <span class="keyword">self</span>.green <span class="operator">=</span> green</span><br><span class="line">        <span class="keyword">self</span>.blue <span class="operator">=</span> blue</span><br><span class="line">        <span class="keyword">self</span>.alpha <span class="operator">=</span> alpha</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这和之前直接给属性设置默认值的方法效果是一样的。当为某个<code>struct</code>创建了<code>init</code>方法后一定要保证其正确性，因为当重写了<code>init</code>方法后，系统就不会在创建默认的<code>init</code>方法了。</p>
<h6 id="2-1-3、Failable-init"><a href="#2-1-3、Failable-init" class="headerlink" title="2.1.3、Failable init"></a>2.1.3、Failable init</h6><p>在使用<code>struct</code>作为model时，如果要将其显示在界面上最终都需要转换成字符串<code>String</code>，这里可以使用系统提供的<code>Codable</code>协议来把服务器返回的进行转换，当然也可以使用其他开源库来完成这些操作。由于在初始化时可能会解析<code>Data</code>数据失败，这里采用<code>init?</code>的方式来初始化，当解析失败时，直接返回<code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> red: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> green: <span class="type">Double</span> </span><br><span class="line">    <span class="keyword">var</span> blue: <span class="type">Double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> alpha: <span class="type">Double</span>? <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>,<span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> red</span><br><span class="line">        <span class="keyword">case</span> green</span><br><span class="line">        <span class="keyword">case</span> blue</span><br><span class="line">        <span class="keyword">case</span> alpha</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Color</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">init?</span>(<span class="params">data</span>: <span class="type">Data</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> model <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">JSONDecoder</span>().decode(<span class="type">Color</span>.<span class="keyword">self</span>, from: data) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> model</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-1-4、Type-property设置一个常用的值"><a href="#2-1-4、Type-property设置一个常用的值" class="headerlink" title="2.1.4、Type property设置一个常用的值"></a>2.1.4、<code>Type property</code>设置一个常用的值</h6><p>对于一个<code>struct</code>经常会使用的值，我们可以采用在<code>struct</code>中定义成<code>Type property</code>。如App的主题颜色是我在代码中要经常使用的，可以采用<code>Type roperty</code>的初始化方式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> themeColor <span class="operator">=</span> <span class="type">Color</span>(red: <span class="number">200</span>, green: <span class="number">200</span>, blue: <span class="number">200</span>, alpha: <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当我要使用App主题颜色时</span></span><br><span class="line"><span class="keyword">let</span> color <span class="operator">=</span> <span class="type">Color</span>.themeColor</span><br></pre></td></tr></table></figure>
<p>当创建了默认主题颜色时，它不是<code>struct</code>对象的一部分，因此不会增加<code>    color</code>对象的大小,还可以使代码看起来更简洁明了。</p>
<h5 id="2-2、为struct添加方法"><a href="#2-2、为struct添加方法" class="headerlink" title="2.2、为struct添加方法"></a>2.2、为struct添加方法</h5><p>在Swift中不仅可以为<code>struct</code>添加属性还可以添加方法，只不过<code>struct</code>的方法，默认都是只读的，例如我要为<code>Color</code>添加一个修改透明度的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyWith</span>(<span class="params">alpha</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3、mutating关键字"><a href="#2-3、mutating关键字" class="headerlink" title="2.3、mutating关键字"></a>2.3、mutating关键字</h5><p>当我要在<code>struct</code>的方法中修改<code>struct</code>中的某个属性值时，要在这个方法前面加上<code>mutating</code>关键字。当添加<code>mutating</code>之后，Swift会隐式的把<code>self</code>标记为<code>inout</code>,这样就可以在方法中修改<code>struct</code>中的属性值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">modifyWith</span>(<span class="params">alpha</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.alpha <span class="operator">=</span> alpha</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-4、修改struct值"><a href="#2-4、修改struct值" class="headerlink" title="2.4、修改struct值"></a>2.4、修改<code>struct</code>值</h5><p>我定义了一个<code>color</code>对象，为了更好观察这个变量被修改时发生了什么，给他添加一个<code>didSet clousre</code>,只要<code>color</code>的值发生变化，就可以看到打印的内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color <span class="operator">=</span> <span class="type">Color</span>(red: <span class="number">200</span>, green: <span class="number">200</span>, blue: <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;color============<span class="subst">\(color)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我修改<code>color</code>的值，再看打印的结果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colorB <span class="operator">=</span> <span class="type">Color</span>(red: <span class="number">100</span>, green: <span class="number">100</span>, blue: <span class="number">100</span>)</span><br><span class="line">color <span class="operator">=</span> colorB</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">color<span class="operator">============</span><span class="type">Color</span>(red: <span class="number">100.0</span>, green: <span class="number">100.0</span>, blue: <span class="number">100.0</span>, alpha: <span class="type">Optional</span>(<span class="number">1.0</span>))</span><br></pre></td></tr></table></figure>
<p>这里修改了<code>color</code>的值所以触发了<code>didSet</code>方法。</p>
<p>如果只修改<code>color</code>其中某个属性值,如我要修改<code>red</code>属性值为110，    </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">color.red <span class="operator">=</span> <span class="number">110</span></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">color<span class="operator">============</span><span class="type">Color</span>(red: <span class="number">110.0</span>, green: <span class="number">100.0</span>, blue: <span class="number">100.0</span>, alpha: <span class="type">Optional</span>(<span class="number">1.0</span>))</span><br></pre></td></tr></table></figure>
<p>可以看到依旧会打印，也就是说<strong>只要修改<code>color</code>的任何一个属性值，其实整个<code>color</code>变量都被修改了</strong>。</p>
<h3 id="3、引用类型class"><a href="#3、引用类型class" class="headerlink" title="3、引用类型class"></a>3、引用类型<code>class</code></h3><h5 id="3-1、class的定义和初始化"><a href="#3-1、class的定义和初始化" class="headerlink" title="3.1、class的定义和初始化"></a>3.1、class的定义和初始化</h5><p>当我定义一个表示颜色的类<code>MyColor</code>,为其设置四个属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> red: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> green: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> blue: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> alpha: <span class="type">Double</span>? <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我让这个类没有父类，也可以根据情况设置其父类。如果没有没有fu此时编译器会提示<code>Class &#39;MyColor&#39; has no initializers</code>,这是由于<strong>类是引用类型必须有一个完整的生命周期，类必须被明确的初始化、使用、最后被明确的释放</strong>。所以当我定义了一个类时必须明确的构建<code>init</code>方法。这也是<code>class</code>和<code>struct</code>的一个区别之一。</p>
<h6 id="3-1-1、默认init"><a href="#3-1-1、默认init" class="headerlink" title="3.1.1、默认init"></a>3.1.1、默认init</h6><p>一般的最简单的初始化方法可以直接调用<code>init</code>方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color <span class="operator">=</span> <span class="type">MyColor</span>()</span><br></pre></td></tr></table></figure>
<p>如果我想像这样初始化一个<code>color</code>对象，可以使用<code>class</code>默认的初始化方法，<code>class</code>的默认初始化方法有两种：</p>
<ul>
<li><p>为每个属性设置默认值</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> red: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> green: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> blue: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> alpha: <span class="type">Double</span>? <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行代码，就可以编译成功。这种方式的确解决了编译报错问题，如果我想在初始化时为类的每个属性设置默认值就会报错，所以为每个属性都设置默认值的方式只适合表意简单的并且初始值固定或者在其内部赋值的<code>class</code>。如果我想类的外部为其设置属性值，可以采用其他的初始化方式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color <span class="operator">=</span> <span class="type">MyColor</span>(red: <span class="number">100</span>, green: <span class="number">100</span>, blue: <span class="number">100</span>) <span class="comment">// Argument passed to call that takes no arguments</span></span><br></pre></td></tr></table></figure></li>
<li><p>在<code>init</code>方法中为每个属性设置默认值</p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">red</span>: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span>, <span class="keyword">_</span> <span class="params">green</span>: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span>, <span class="keyword">_</span> <span class="params">blue</span>: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span>, <span class="keyword">_</span> <span class="params">alpha</span>: <span class="type">Double</span>? <span class="operator">=</span> <span class="number">1</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">self</span>.red <span class="operator">=</span> red</span><br><span class="line">     <span class="keyword">self</span>.green <span class="operator">=</span> green</span><br><span class="line">     <span class="keyword">self</span>.blue <span class="operator">=</span> blue</span><br><span class="line">     <span class="keyword">self</span>.alpha <span class="operator">=</span> alpha</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">let</span> mycolorA <span class="operator">=</span> <span class="type">MyColor</span>()</span><br><span class="line"><span class="keyword">let</span> mycolorB <span class="operator">=</span> <span class="type">MyColor</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>这样就可以根据实际的需求来初始化<code>MyColor</code>类了。在Swift中，<strong>初始化类的<code>init</code>方法必须定义在<code>class</code>内部，而不能定义在<code>extension</code>里</strong>，否则会导致编译错误。<strong>而<code>struct</code>的<code>init</code>方法是可以定义在<code>extension</code>中</strong>，这也是<code>class</code>和<code>struct</code>的区别之一。</p>
<h5 id="3-2、-Convenience-init"><a href="#3-2、-Convenience-init" class="headerlink" title="3.2、 Convenience init"></a>3.2、 Convenience init</h5><p>如果构造方法前面没有<code>convenience</code>关键字称作<strong>便利构造方法</strong>。如果没有称作<strong>指定构造方法</strong>。</p>
<ul>
<li>便利构造方法： 初始化方法前有<code>convenience</code>关键字，不用对所有的属性进行初始化，因为便利构造方法依赖于指定构造方法。如果想给系统提供的类提供一个快捷创建的方法，就可以自定义一个便利构造方法</li>
<li>指定构造方法：必须对所有的属性初始化</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="function"><span class="keyword">init</span>(<span class="params">at</span>: (<span class="type">Double</span>, <span class="type">Double</span>, <span class="type">Double</span>, <span class="type">Double</span>?))</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(at.<span class="number">0</span>, at.<span class="number">1</span>, at.<span class="number">2</span>, at.<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3、Failable-init"><a href="#3-3、Failable-init" class="headerlink" title="3.3、Failable init"></a>3.3、Failable init</h5><p>在大多数时候和服务器交互数据为了统一和方便，会把所有的数据都采用字符串（String）格式， 这就需要在初始化的时候做一些处理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="function"><span class="keyword">init?</span>(<span class="params">at</span>: (<span class="type">String</span>, <span class="type">String</span>, <span class="type">String</span>, <span class="type">String</span>?))</span> &#123;</span><br><span class="line">     <span class="keyword">guard</span> <span class="keyword">let</span> red <span class="operator">=</span> <span class="type">Double</span>(at.<span class="number">0</span>), <span class="keyword">let</span> green <span class="operator">=</span> <span class="type">Double</span>(at.<span class="number">1</span>), <span class="keyword">let</span> blue <span class="operator">=</span> <span class="type">Double</span>(at.<span class="number">2</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">self</span>.<span class="keyword">init</span>(red, green, blue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>String</code>的<code>init</code>可能会失败，这里采用可选的形式来定义。在其实现中，如果<code>String</code>转<code>Double</code>失败，就返回<code>nil</code>，表示初始化失败。</p>
<h3 id="3、比较struct和class"><a href="#3、比较struct和class" class="headerlink" title="3、比较struct和class"></a>3、比较<code>struct</code>和<code>class</code></h3><p>前面分别简单介绍了<code>struct</code>和<code>class</code>，这里对这两者做一个比较：</p>
<h5 id="3-1-struct和class的共同点"><a href="#3-1-struct和class的共同点" class="headerlink" title="3.1 struct和class的共同点"></a>3.1 <code>struct</code>和<code>class</code>的共同点</h5><ul>
<li>都可以定义属性并用来保存值</li>
<li>都可以构建方法</li>
<li>都可以设置其每个属性的初始值以设置其初始状态</li>
<li>都可以采用下标的方式来访问他的值</li>
<li>都可以对其做<code>extension</code>操作，用来扩展其超出默认实现的功能</li>
<li>都可以遵循某个协议用来提供某些标准的功能</li>
</ul>
<h5 id="3-2、struct和class-的区别"><a href="#3-2、struct和class-的区别" class="headerlink" title="3.2、struct和class`的区别"></a>3.2、struct<code>和</code>class`的区别</h5><ul>
<li><p><code>struct</code>会默认生成<code>init</code>方法，<code>class</code>必须明确指定init方法</p>
</li>
<li><p><code>struct</code>不能继承（但是可以遵循协议）,<code>class</code>是可以继承的</p>
</li>
<li><p><code>struct</code>更多的是关注其值，当我修改<code>struct</code>其中任意属性值时整个<code>struct</code>都会被重新修改一次，<code>class</code>更多的是关注的是对象本身</p>
</li>
</ul>
<h3 id="4、struct和class的选择"><a href="#4、struct和class的选择" class="headerlink" title="4、struct和class的选择"></a>4、struct<code>和</code>class的选择</h3><p>Swift中<code>struct</code>和<code>class</code>有这么多共同点，那在实际开发中要如何选用<code>struct</code>和<code>class</code>呢，作为开发者需要根据当前的使用时机来选择使用哪种类型：</p>
<h5 id="4-1、默认情况下使用struct"><a href="#4-1、默认情况下使用struct" class="headerlink" title="4.1、默认情况下使用struct"></a>4.1、默认情况下使用<code>struct</code></h5><p>一般创建一个<code>struct</code>其会被存储于栈区，因为<code>struct</code>一般不涉及到堆内存分配，无论是创建、追踪还是销毁都非常快，所以默认情况下优先选择<code>struct</code>。</p>
<h5 id="4-2、是否需要继承或Protocol"><a href="#4-2、是否需要继承或Protocol" class="headerlink" title="4.2、是否需要继承或Protocol"></a>4.2、是否需要继承或<code>Protocol</code></h5><ul>
<li>如果对继承和协议没有要求，优先使用<code>struct</code></li>
<li>如果需要继承，那么只能使用<code>class</code></li>
</ul>
<h5 id="4-3、需要和Objective-C时，使用class"><a href="#4-3、需要和Objective-C时，使用class" class="headerlink" title="4.3、需要和Objective-C时，使用class"></a>4.3、需要和<code>Objective-C</code>时，使用<code>class</code></h5><p>当<code>Swift</code>和<code>Objective-C</code>交互时，可以在<code>class</code>前面加<code>@objcMembers</code>，或者要调用的方法和变量前加<code>@objc</code>，在要调用的<code>Objecrtive-C</code>文件中导入<code>#import &quot;工程名-Swift.h&quot;</code>,即可使用调用Swift类。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift 文件中</span></span><br><span class="line"><span class="keyword">@objc</span>Members <span class="class"><span class="keyword">class</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">coverModel</span>()</span> &#123;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Objective-C 文件中</span><br><span class="line">#import &quot;工程名-Swift.h&quot;</span><br><span class="line"></span><br><span class="line">Model *model &#x3D; [[Model alloc] init];</span><br><span class="line">[model coverModel];</span><br></pre></td></tr></table></figure>
<h5 id="4-4、需要控制身份时使用class"><a href="#4-4、需要控制身份时使用class" class="headerlink" title="4.4、需要控制身份时使用class"></a>4.4、需要控制身份时使用<code>class</code></h5><ul>
<li>当需要使用<code>===</code>比较两个实例一致性时。<code>===</code>会自动检查两个对象是否完全一致，包括存储数据的内存地址</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mycolorA <span class="operator">=</span> <span class="type">MyColor</span>()</span><br><span class="line"><span class="keyword">let</span> mycolorB <span class="operator">=</span> mycolorA</span><br><span class="line"><span class="keyword">if</span> mycolorA <span class="operator">===</span> mycolorB &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当需要创建用于共享、可改变的数据时</li>
</ul>
<h5 id="4-5、不控制身份时使用struct"><a href="#4-5、不控制身份时使用struct" class="headerlink" title="4.5、不控制身份时使用struct"></a>4.5、不控制身份时使用<code>struct</code></h5><ul>
<li>当需要使用<code>==</code>比较实例数据，用于比较两个值是否相等</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colorA <span class="operator">=</span> <span class="type">Color</span>(red: <span class="number">200</span>, green: <span class="number">200</span>, blue: <span class="number">200</span>)</span><br><span class="line"><span class="keyword">let</span> colorB <span class="operator">=</span> <span class="type">Color</span>(red: <span class="number">100</span>, green: <span class="number">100</span>, blue: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">if</span> colorA.alpha <span class="operator">==</span> colorB.alpha &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当需要在多线程中修改值时，优先使用<code>struct</code>，因为<code>struct</code>是线程安全的</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colorArray <span class="operator">=</span> [colorA, colorB, colorC, colorD, colorE]</span><br><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.global()</span><br><span class="line"><span class="keyword">let</span> count <span class="operator">=</span> colorArray.count</span><br><span class="line">queue.async &#123; [colorArray] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>colorArray.count &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;index=========<span class="subst">\(colorArray[index])</span>&quot;</span>)</span><br><span class="line">        <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">queue.async &#123;</span><br><span class="line">    <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">0.5</span>)</span><br><span class="line">    colorArray.remove(at: <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-------<span class="subst">\(colorArray.count)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码可以正常运行。</p>
<p>当然所谓的线程安全也是相对而言的，修改如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colorArray <span class="operator">=</span> [colorA, colorB, colorC, colorD, colorE]</span><br><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.global()</span><br><span class="line"><span class="keyword">let</span> count <span class="operator">=</span> colorArray.count</span><br><span class="line">queue.async &#123;</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>count &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;index=========<span class="subst">\(colorArray[index])</span>&quot;</span>)</span><br><span class="line">        <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">queue.async &#123;</span><br><span class="line">    <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">0.5</span>)</span><br><span class="line">    colorArray.removeLast()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-------<span class="subst">\(colorArray.count)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行代码就会Crash并打印错误：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fatal error: Index out of range: file Swift/ContiguousArrayBuffer.swift, line <span class="number">444</span></span><br></pre></td></tr></table></figure>
<p>这是由于我移除了数组的最后一个元素，当需要打印最后一个（也就是第五个）元素时，数组中其实已经没有这个元素了，所以会数组越界Crash。而第一段代码之所以不会Crash，是因为在新的线程中会copy一份数组内容。所以当新建一个线程操作数据时copy值类型到新线程操作是线程安全的。</p>
<p>本文主要介绍了<code>struct</code>和<code>class</code>及其异同点，同时简单分析了在开发中应该如何选择<code>struct</code>还是<code>class</code>。如果我的理解有不对地方欢迎指出。</p>
<hr>
<p>本文参考：</p>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes">Apple Developer: Choosing Between Structures and Classes</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html"> The Swift Programming Language: Structures and Classes</a></p>
<p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/27044368/">Swift进阶：机构体和类</a></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/29307041.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
