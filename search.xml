<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>iOS从资源和代码方面为App瘦身处理</title>
    <url>/2021/02/20/iOS%E4%BB%8E%E8%B5%84%E6%BA%90%E5%92%8C%E4%BB%A3%E7%A0%81%E6%96%B9%E9%9D%A2%E4%B8%BAApp%E7%98%A6%E8%BA%AB%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;对<code>App</code>包瘦身处理是为了减少包的大小，节约用户下载<code>App</code>流量。在<code>App Store</code>下载<code>App</code>，如果超过了150MB就必须在Wi-Fi环境下载或更新，这样如果超过了150M，可能就会间接失去了大部分用户。如果我们的<code>App</code>要兼容iOS7和iOS 8,<a href="https://help.apple.com/app-store-connect/#/dev611e0a21f">苹果官方规定:主二进制text段的大小不能超过60M</a>，如果超过这个标准，就没办法向<code>App Strore</code>提交审核。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;下面这张表格列举了当前国内外的部分常用<code>App</code>的包大小。</p>
<table>
<thead>
<tr>
<th align="center">APP</th>
<th align="center">版本</th>
<th align="center">大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">支付宝</td>
<td align="center">10.1.60</td>
<td align="center">167.5M</td>
</tr>
<tr>
<td align="center">淘宝</td>
<td align="center">8.6.10</td>
<td align="center">207.6M</td>
</tr>
<tr>
<td align="center">微信</td>
<td align="center">7.0.3</td>
<td align="center">230M</td>
</tr>
<tr>
<td align="center">滴滴</td>
<td align="center">5.2.45</td>
<td align="center">202.4M</td>
</tr>
<tr>
<td align="center">抖音</td>
<td align="center">5.7.0</td>
<td align="center">170.2M</td>
</tr>
<tr>
<td align="center">新浪微博</td>
<td align="center">9.3.1</td>
<td align="center">191.5M</td>
</tr>
<tr>
<td align="center">网易云音乐</td>
<td align="center">6.1.0</td>
<td align="center">147.7M</td>
</tr>
<tr>
<td align="center">Facebook</td>
<td align="center">216.0</td>
<td align="center">256.5M</td>
</tr>
<tr>
<td align="center">Twitter</td>
<td align="center">7.47</td>
<td align="center">110.9M</td>
</tr>
<tr>
<td align="center">Instagram</td>
<td align="center">88.0</td>
<td align="center">90.2M</td>
</tr>
</tbody></table>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;通过上面的表格可以看出目前包少于150M的只有<code>网易云音乐</code>,<code>Instagram</code>,<code>Twitter </code>。那么作为开发者可以通过哪些方法对自己的<code>App</code>包大小做优化处理呢？</p>
<blockquote>
<p>1、苹果提供的 App Thinning</p>
</blockquote>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;我们知道不同的设备的屏幕大小、分辨率、<code>CPU</code>、<code>GPU</code>、硬盘大小等都不相同。针对这种情况，苹果官方为开发者提供了 <code>App Thinning</code>技术，对于不同设备提供只适用当前设备的包为用户提供下载。如<code>iPhone 5C</code>只会下载适用于32位运行芯片的库和2x的图片资源的包，<code>iPhone 8P</code>则会下载适用于64位的库和3x的图片资源。</p>
<p>苹果关于App Thinning的介绍请看：<br><a href="https://developer.apple.com/videos/play/wwdc2015/404/">App Thinning in Xcode视频</a><br><a href="https://help.apple.com/xcode/mac/current/#/devbbdc5ce4f">App Thinning官方文档</a></p>
<p>######（1）、<code>App Thinning</code>有三种方式: <code>App Slicing</code>,<code>Bitcode</code>、<code>On-Demand Resources</code>。</p>
<ul>
<li> <code>App Slicing</code>：iOS9之后苹果官方出的解决方案，在向<code>iTunes Connect</code>上传<code>App</code>包后，对<code>App</code>做切割处理，创建不同的变体包，这样就可以适用到不同的设备；</li>
<li><code>Bitcode</code>:也是iOS9之后苹果给出的解决方案，针对特定的设备进行包大小优化。</li>
<li> <code>On-Demand Resources</code>:主要是为又下多关卡的情况服务的，<code>On-Demand Resources</code>会根据用户的关卡下载进度下载随后几个关卡的资源，并且已经过关的资源会被干掉，这样可以减少初始<code>App</code>包的大小。</li>
</ul>
<p>######（2）、那么如何在项目中适用<code>App Thinning</code>呢？</p>
<h6 id="2-1-、-Slicing的使用"><a href="#2-1-、-Slicing的使用" class="headerlink" title="(2.1) 、 Slicing的使用"></a>(2.1) 、 <code>Slicing</code>的使用</h6><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;在使用<code>App Slicing</code>的时候，大部分工作是由<code>Xcode</code>和<code>App Store</code>来完成的，开发者本身不需要做任何事情。在开发中只需要创建<code>xcassets</code>目录，然后将图片加入其中即可。在创建一个工程的时候<code>Xcode</code>会默认为开发者创建一个名为<code>Assets.xcassets</code>的目录，在开发过程中只要把图片资源加入其中即可。</p>
<p><img src="/resources/resources001.webp" alt="Asssts.xcassets"></p>
<p>当然也可以自己新建，选中工程目录<code>New File</code>—&gt;<code>Resources</code>—&gt;<code>Asset Catalog</code>即可新建一个。</p>
<p><img src="/resources/resources002.webp" alt="create xcassets "></p>
<p> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 我们在使用<code>xcassets</code>时，添加对应的2x分辨率和3x分辨率的图片，会在上传到<code>App Store</code>后被创建成不同安装包以减少<code>App</code>安装包的大小。同时苹果会自动根据的设备不同，在创建的安装包中自动加入当前设备需要的芯片指令集架构文件。</p>
<h6 id="2-2-、Bitcode使用"><a href="#2-2-、Bitcode使用" class="headerlink" title="(2.2) 、Bitcode使用"></a>(2.2) 、<code>Bitcode</code>使用</h6><p><a href="https://help.apple.com/xcode/mac/current/#/devbbdc5ce4f">Apple Bitcode官方文档</a></p>
<p>什么是bitcode？<br> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 一般情况下，在iOS9之后，新建一个工程，Xcode会默认设置，bitcode。介于源码和机器码之间，在LLVM中的IR（Intermediate Representation)这层，由编译器前端clang生成，交给LLVM优化器优化后交给后端生成CPU相应指令。</p>
<p>将bitcode提供给Apple，由他们针对各种机型（包括新机型）的CPU对代码做二次优化，其本身不会增加包体积，上传的二进制文件会变大，但是不会影响用户的下载大小。</p>
<p>如果开启bitcode，相应的，所有使用的pod都需要开启bitcode，bitcode必须是完整的，否则就是无效的，编译阶段就会报错。</p>
<p>开启bitcode选项后，在debug模式下不会打进bitcode，只有在Archive时才会。</p>
<h6 id="2-3-、On-Demand-Resources的使用"><a href="#2-3-、On-Demand-Resources的使用" class="headerlink" title="(2.3) 、On-Demand Resources的使用"></a>(2.3) 、<code>On-Demand Resources</code>的使用</h6><p><a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/">On-Demand Resources官方文档</a></p>
<p>将图片、音频等资源文件分离出来，开发阶段将资源按照ResourceTag区分，存放在苹果的服务器上。App按需要发起请求，由操作系统来管理下载和存储，一般用于游戏资源或者内购。</p>
<p>优点：</p>
<ul>
<li>包体积更小，为设备省更多的存储控件</li>
<li>懒加载（Game -&gt; level -&gt; download current resources）</li>
<li>很少使用的资源可以放在服务器（Tutorial）</li>
</ul>
<p>缺点：</p>
<ul>
<li>资源需要从苹果服务器下载</li>
<li>资源需要按tag区分，制定相应的配置策略</li>
<li>代码中管理何时下载，何时释放，增加了资源管理的复杂度</li>
</ul>
<blockquote>
<p>2、删除废止、无用的资源</p>
</blockquote>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 在<code>App</code>的版本迭代中，我们不断的加入新的资源。但是由于后期的需求、设计、交互等变更，前期加的一些资源就没有用了，但是当时并没有删除这些资源，导致我们的资源越来越臃肿，<code>App</code>包越来越大。如我们的<code>App</code>中加入了圣诞版本的素材，但是这个版本之后这些素材就没用了。而删除这些无用资源也是最简单最有效的能为<code>App</code>包大小带来最明显的效果的操作，那么，该如找到并删除这些无用的资源呢？</p>
<ul>
<li>(1)、在提审前，使用最简单的方法，通过<code>Xcode</code>的<code>Find</code>功能在代码中搜索图片资源名称，如果没有搜到，说明没有没有使用这张图片，直接删除图片资源即可。但是这样做的比较麻烦，而且效率也比较低;</li>
<li>(2)、通过<code>Mac</code>终端<code>Find</code>命令来搜索工程中的所有图片资源，确认是无用的图片资源后删除，此处可以使用系统提供的<code>NSFileManger</code>类来删除;</li>
<li>(3)、此处为各位推荐一个开源工具<a href="https://github.com/tinymind/LSUnusedResources.git">LSUnusedResources</a>,<code>LSUnusedResources</code>不仅拥有<code>GUI</code>，而且添加和删除操作也很简单。</li>
<li>(4)、删除一些其他的文件，如在我们的项目中使用了<a href="https://github.com/airbnb/lottie-ios">lottie</a>动画，所以在本地会有一些对应的<code>json</code>文件，对于废止的文件,可以通过上面的方法删除；</li>
</ul>
<blockquote>
<p>3、图片资源压缩处理</p>
</blockquote>
<p>试想，如果设计师给的图片非常大，一张图片达到了几十<code>KB</code>,甚至是几<code>MB</code>,如果这样的资源很多，那么最终打包下来的安装包自然就很大，如在我们的项目中设计师给出的一张全屏背景图仅1x的图片就达到了53KB，这样对图片的压缩处理就显得刻不容缓了。</p>
<p><img src="/resources/resources003.webp" alt="压缩前"></p>
<p>我们要的目的是为了在不损失图片质量的情况下尽可能大的对图片做压缩处理，这样就能节省一些空间，减少安装包的大小。此处推荐<code>Google</code>的方案将图片转成<a href="https://developers.google.com/speed/webp/">WebP</a>(这里需要梯子才能打开)。</p>
<p>######(1)、为什么要使用<code>WebP</code></p>
<ul>
<li><code>WebP</code>压缩率高，肉眼基本看不出差异，支持有损和无损两种模式，压缩之后不仅不损失图片质量，官方提出相对于我们常用的<code>PNG</code>格式能减少26%的大小。</li>
<li><code>WebP</code>支持<code>Alpha</code>透明和<code>24-bit</code>颜色数，不会像<code>PNG8</code>那样因为色彩不够出现毛边；</li>
<li><code>WebP</code>兼容目前主流的浏览器和平台；</li>
</ul>
<h6 id="2-、WebP的安装"><a href="#2-、WebP的安装" class="headerlink" title="(2)、WebP的安装"></a>(2)、<code>WebP</code>的安装</h6><p>使用<code>Homebrew</code>命令安装<code>webp</code>,在终端输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install webp</span><br></pre></td></tr></table></figure>
<p>如我要把<code>all_background.png</code>这张图片采用无损压缩方式转成<code>WebP</code>可使用命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cwebp -lossless all_background.png -o all_background.webp</span><br></pre></td></tr></table></figure>
<p>如果要控制压缩质量为50%：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cwebp -q 50 girl006.jpg -o girl006.webp</span><br></pre></td></tr></table></figure>

<p>压缩完成之后，只占了3K内存，优化效果非常明显。</p>
<p><img src="/resources/resources004.webp" alt="压缩后"></p>
<h6 id="3-、WebP的使用"><a href="#3-、WebP的使用" class="headerlink" title="(3)、WebP的使用"></a>(3)、<code>WebP</code>的使用</h6><p><code>WebP</code>图片的加载可参考:<a href="%5Bhttps://www.jianshu.com/p/f33422951795%5D(https://www.jianshu.com/p/f33422951795)">WebP解码支持（Objc &amp; Swift）</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let path : String &#x3D; Bundle.main.path(forResource: &quot;all_background&quot;, ofType: &quot;webp&quot;)!;</span><br><span class="line">self.backgroundImg.image &#x3D; UIImage.init(webPPath: path);</span><br></pre></td></tr></table></figure>
<p>关于<code>WebP</code>的更多使用方式可参考<a href="https://developers.google.com/speed/webp/docs/using">WebP官方网站</a>。</p>
<blockquote>
<p>4、删除废止的代码文件</p>
</blockquote>
<p>在产品的不断更新和迭代中，代码中不可避免的会删除或废止一些功能，但是作为开发者有时候并没有及时的删除这些废止的代码。这样随着代码量的增加，APP中的冗余或无效代码就越来越多，我们对代码瘦身的目的就是找出这些代码并删除。那么可以通过哪些方法来达到目的呢？</p>
<p>（1）、使用Xcode的Analyze静态分析</p>
<p>打开Xcode，Product –&gt; Analyze,也可以使用快捷键 command ⌘ + ⇧ + B打开，</p>
<p><img src="/resources/resources005.webp" alt="Analyze"></p>
<p>Xcode的Analyze静态分析，不仅能找到没有调用的代码，同时还可以找到：</p>
<ul>
<li>代码中的野指针或未初始化的变量</li>
<li>内存泄漏的代码</li>
<li>没有使用过的库或框架</li>
</ul>
<p><img src="/resources/resources006.webp" alt="静态分析结果"></p>
<p>我在使用Xcode静态分析时，发现还是有很多问题的，如废止的文件或类检查的效果并不是很理想，所以推荐AppCode做静态分析。</p>
<p>（2）、使用AppCode做静态分析</p>
<p> 可以直接使用<a href="https://www.jetbrains.com/objc/download/">AppCode</a>来做静态分析，操作也很简单，打开 AppCode —&gt;code—&gt;Inspect Code；</p>
<p><img src="/resources/resources007.webp" alt="AppCode Inspect Code"></p>
<p>在静态分析完成之后，可以在<code>Unused code</code>中看到废弃的代码，如下图所示：</p>
<p><img src="/resources/resources008.webp" alt="Unused code"></p>
<ul>
<li><code>Unused class</code>是废弃类</li>
<li><code>Unused import statement</code>是无用类引用申明</li>
<li><code>Unused property </code>是无用的属性</li>
<li><code>Unused method</code>是无用的方法</li>
<li><code>Unused parameter</code>是无用的参数</li>
<li><code>Unused instance variable</code>是无用的实例变量</li>
<li><code>Unused local variable</code>是无用的局部变量</li>
<li><code>Unused value</code>是无用的值</li>
<li><code>Unused macro</code>是无用的宏定义</li>
<li><code>Unused global decaration</code>是无用的全局申明</li>
</ul>
<p>那么问题来了，使用AppCode静态分析就可以检查出所有的废弃代码了吗？并不是，下面列举了几种情况，AppCode认为方法或者类没有调用：</p>
<ul>
<li>当使用<code>objc_msgSend</code>或<code>@selector</code>调用一个方法时</li>
<li>利用点的方式使用属性时</li>
<li>父类申明在子类中实现的方法时</li>
<li>使用<code>NSClassFromString</code>运行时方式申明的类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIViewController *TestVC &#x3D; [[NSClassFromString(@&quot;TestClassViewController&quot;) alloc]init]; </span><br><span class="line">SEL aSelector &#x3D; NSSelectorFromString(@&quot;setIsPlayLaunchAnimation:&quot;);</span><br><span class="line">if  ([TestVC respondsToSelector:aSelector])  &#123;</span><br><span class="line">     IMP aIMP &#x3D; [SearchMainView methodForSelector:aSelector];</span><br><span class="line">     void (*setter)(id, SEL, BOOL) &#x3D; (void(*)(id, SEL, BOOL))aIMP;</span><br><span class="line">     setter(TestVC, aSelector,true);</span><br><span class="line"> &#125;</span><br><span class="line"> self.window.rootViewController &#x3D; [[UINavigationController alloc] initWithRootViewController:TestVC];</span><br></pre></td></tr></table></figure>
<p>所以，使用工具静态分析并不能完美的找出所有的废弃代码，在删除代码前要手动确认该方法或类是否调用了。最简单的方式就是利用Xcode自带的<code>Find</code>功能。</p>
<p>######（3）、删除工程中的野鸡开源代码</p>
<p>有很多优秀的同行，他们分享了自己写的代码，这使得一些程序员在开发中遇到一个需求首先想到的是去<code>GitHub、CSDN、Code4App</code>上去找demo，而不是自己根据需求造轮子，找到比较相近的代码改一改就直接加到自己的代码中使用了，但是这样会产生很多不可控的问题。例如：</p>
<ul>
<li>后期需求变更</li>
<li>系统版本升级之后的兼容问题</li>
<li>出现BUG给作者提<code>Issues</code>不能及时得到回复或解决</li>
<li>代码作者长期没有维护</li>
</ul>
<p>我个人建议，在使用第三方的开源代码的时候一定要慎重，不要随便找一个开源代码就加到自己的工程中使用，可以借鉴作者的思路自己造轮子，当然对于Star很多且作者在长期维护的代码可以选择使用。同时GitHub上优秀的代码大部分都是都系统API的封装，如：</p>
<ul>
<li><code>Alamofire、AFNetWorking</code>是对<code>URLSession</code>的进一步封装，</li>
<li><code>SnapKit、Masonry</code>是对<code>AutoLayout </code>的封装，</li>
</ul>
<p>当然有些功能或API是苹果没有为开发者提供的，我们就不得不使用第三方的开源代码，如</p>
<ul>
<li>iOS 6之前苹果并没有提供<code>UICollectionView</code>，所以开发者们只能使用第三方的开源代码，</li>
<li>iOS 7之前苹果没有提供<code>UITableViewCell</code>自适应高度，所以我们只能使用<code>UITableView+FDTemplateLayoutCell</code></li>
</ul>
<p>个人建议：如果有系统提供的API，优先使用系统的方法或API。</p>
<p>在我们开发团队最新的工程中，我们并没有使用<code>SnapKit</code>，而是使用了苹果提供的<code>NSLayoutAnchor</code>，个人觉得苹果经过从iOS 9之后的不断优化，已经基本能够满足大部分不太复杂的APP的需求了。</p>
<p>本文主要介绍了在iOS开发中如何从图片资源和代码两方面为App瘦身的方法，如果你有更优更好的解决方法，欢迎指点。</p>
<p>–<br>友情链接:</p>
<p><a href="https://help.apple.com/xcode/mac/current/#/devbbdc5ce4f">Xcode Help What is app thinning? (iOS, tvOS, watchOS)</a></p>
<p><a href="https://developer.apple.com/videos/play/wwdc2015/404/">Apple Developer App Thinning in Xcode</a></p>
<p><a href="https://time.geekbang.org/column/article/88573">包大小：如何从资源和代码层面实现全方位瘦身？</a></p>
<p><a href="http://madmark.cc/2019/04/02/App%20Thinning/#more">iOS App瘦身</a></p>
]]></content>
  </entry>
  <entry>
    <title>iOS 多线程概览</title>
    <url>/2021/02/28/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h6 align='right'>小时光</h6>

<h3 id="1、为什么所有的UI操作都在主线程中"><a href="#1、为什么所有的UI操作都在主线程中" class="headerlink" title="1、为什么所有的UI操作都在主线程中"></a>1、为什么所有的UI操作都在主线程中</h3><p>不仅是iOS系统，包括Android等，所有的UI渲染、操作都在主线程中来完成。那为什么不采用多线程的方式呢？<br>使用多线程渲染UI更快，操作更流畅。但是系统设计者和开发者来说，需要解决线程问题的成本就更高了，也就是说成本远大于收益了。所以工程师们把所有的UI渲染和操作全都放在了主线程中。参考<a href="https://juejin.cn/post/6844903763011076110">为什么必须在主线程操作UI</a>。</p>
<h3 id="2、为什么要使用多线程"><a href="#2、为什么要使用多线程" class="headerlink" title="2、为什么要使用多线程"></a>2、为什么要使用多线程</h3><p>即然所有的UI操作都是单线程的，那么为何还需要多线程呢？在App开发中，所遇到不仅有UI操作，还有一些其他的费时操作，如网络请求、文件读取操作、AR模型下载等。此时就需要开发者把费时的操作放到子线程中去，完成后再返回住线程执行一些UI操作。<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/351466fe66794aff8ca268aae1cc9fdc~tplv-k3u1fbpfcp-watermark.image"><br>如上图所示，当进入这个Controller时开始下载图片，由于下载的图片较多需要几秒甚至十几秒，在下载时我同步滑动底部的<code>UISlider</code>,此时<code>UISlider</code>并没有滑动，直到所有的图片全部下载完成后才滑动。</p>
<p>试想如果我们的使用的每个App在费时操作时都需要等待很长时间用户才能操作，这样势必会给用户很不好的体验。此时的解决方案是创建一个新的线程来下载图片，这样既不影响用户的UI操作也不影响图片下载。</p>
<h3 id="3、多线程的实现方式"><a href="#3、多线程的实现方式" class="headerlink" title="3、多线程的实现方式"></a>3、多线程的实现方式</h3><p> Apple为开发者提供的三种多线程实现方式:</p>
<h5 id="3-1、-Thread"><a href="#3-1、-Thread" class="headerlink" title="3.1、 Thread"></a>3.1、 Thread</h5><ul>
<li>轻量级</li>
<li>需要开发者手动管理线程生命周期和线程同步</li>
</ul>
<h5 id="3-2、-GCD（Grand-Central-Dispatch）"><a href="#3-2、-GCD（Grand-Central-Dispatch）" class="headerlink" title="3.2、 GCD（Grand Central Dispatch）"></a>3.2、 GCD（Grand Central Dispatch）</h5><ul>
<li>相对<code>Thread</code>而言，不需要管理线程生命周期，操作更简单</li>
<li>本身维护了一个线程池，会自动根据当前手机系统的情况来动态管理线程，不需要开发者来管理线程池和线程并发情况</li>
<li>底层源码是开源的，点击<a href="https://opensource.apple.com/tarballs/libdispatch/">Apple Open Spurce</a>查看源码</li>
</ul>
<h5 id="3-3、-Cocoa-Operation"><a href="#3-3、-Cocoa-Operation" class="headerlink" title="3.3、 Cocoa Operation"></a>3.3、 Cocoa Operation</h5><ul>
<li>面向对象的API</li>
<li>可以取消、依赖、任务优先级、可以子类化</li>
</ul>
<h3 id="4、多线程常用队列"><a href="#4、多线程常用队列" class="headerlink" title="4、多线程常用队列"></a>4、多线程常用队列</h3><p>多线程可以根据任务执行的队列方式分为三种队列：</p>
<ul>
<li>主队列: 在主线程中执行的任务</li>
<li>串行队列（Serial Queue）: 任务按照先后顺序执行，同一时刻只会执行一个任务</li>
<li>并行队列（Concurrent Queue）: 多个任务同时执行，完成的顺序不一定</li>
</ul>
<p>参考 <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW2">Apple Developer About Dispatch Queues</a></p>
<h3 id="5、Serial-Queue"><a href="#5、Serial-Queue" class="headerlink" title="5、Serial Queue"></a>5、Serial Queue</h3><ul>
<li>（1）、串行队列处理并发任务</li>
</ul>
<p>前面说过，对于一些耗时操作，一般将其放到一个子线程中执行，待完成后再返回主线程中刷新UI。核心代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图片下载管理类`DownloaderManager`</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloaderManager</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">downloadImageWithURL</span>(<span class="title">_</span> <span class="title">url</span>: <span class="title">String</span>) -&gt; <span class="title">UIImage</span>? </span>&#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> data <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">Data</span>(contentsOf: <span class="type">URL</span>(string: url)<span class="operator">!</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIImage</span>(data: data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个队列</span></span><br><span class="line"><span class="keyword">let</span> serialQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;TSN.RPChat.io&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (index, imgurl) <span class="keyword">in</span> <span class="type">DownloaderManager</span>.imageArray.enumerated() &#123;</span><br><span class="line">   <span class="comment">// 把下载任务加载到队列中</span></span><br><span class="line">   serialQueue.async &#123; </span><br><span class="line">      <span class="keyword">let</span> image <span class="operator">=</span> <span class="type">DownloaderManager</span>.downloadImageWithURL(imgurl)</span><br><span class="line">      <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">         girlsImg.image <span class="operator">=</span> image</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时再次运行代码，发现在下载图片的同时也能滑动<code>UISlider</code>，同时发现图片的加载顺序是按照从上到下的顺序加载的。默认情况下，系统会创建一个串行队列，也就是下载完成第一张图片之后再去下载第二张。此时对我来说，我的目的是下载并把图片全部显示出来，我并不关心图片的下载和加载顺序。这样我就需要在创建队列时设置这个队列为一个并行队列。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ff481b519e44cf1ab3c1442c628bbbd~tplv-k3u1fbpfcp-watermark.image" alt="串行队列"></p>
<h3 id="6、Concurrent-Queue"><a href="#6、Concurrent-Queue" class="headerlink" title="6、Concurrent Queue"></a>6、Concurrent Queue</h3><p>作为队列，<code>concurrent queue</code>中的任务虽然是按照进入队列的顺序启动，但不用等待之前的任务完成，iOS会根据当前系统情况启动多个线程并行执行队列中的任务。</p>
<p>在创建队列时设置<code>attributes</code>属性为<code>concurrent</code>就创建了一个并行队列。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> concurrentQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;TSN.RPChat.io&quot;</span>, attributes: .concurrent)</span><br></pre></td></tr></table></figure>
<p>此时运行工程，可以看到图片并不是按照先后顺序加载的，说明同一个<code>concurrent queue</code>中的所有任务在并行执行。<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12d73fba49ea4e6992822fc67e3279a1~tplv-k3u1fbpfcp-watermark.image" alt="Concurrent Queue"></p>
<h3 id="7、面向对象的Cocoa-Operation"><a href="#7、面向对象的Cocoa-Operation" class="headerlink" title="7、面向对象的Cocoa Operation"></a>7、面向对象的Cocoa Operation</h3><p>上面创建的队列我使用的是GCD（Grand Central Dispatch）方式，尽管GCD对线程管理进行了封装并加入了面向对象管理模式。但是如果我要对一个队列中的任务做更多的操作，如（查看状态、取消任务，控制任务的执行顺序等）仍然不太方便。考虑到这些问题，苹果为开发这提供了一个面向对象方式的多任务执行机制<a href="https://developer.apple.com/documentation/foundation/operation">Operation</a>。<code>Operation</code>是基于<code>GCD</code>的对象封装。</p>
<h5 id="7-1、Operation概览"><a href="#7-1、Operation概览" class="headerlink" title="7.1、Operation概览"></a>7.1、<a href="https://developer.apple.com/documentation/foundation/operation">Operation概览</a></h5><p> Operation的一些使用状态：</p>
<ul>
<li><p><a href="https://developer.apple.com/documentation/foundation/operation/1412992-isready">isReady</a>是否可执行，一般用于异步的情况下 </p>
</li>
<li><p><a href="https://developer.apple.com/documentation/foundation/operation/1415621-isexecuting">isExexuting</a>标记<code>Operation</code>是否正在执行中</p>
</li>
<li><p><a href="https://developer.apple.com/documentation/foundation/operation/1413540-isfinished">isFinished</a>标记<code>Operation</code>是否已经执行完成了，一般用于异步</p>
</li>
<li><p><a href="https://developer.apple.com/documentation/foundation/operation#1661262">isCancelled</a>标记<code>Operation</code>是否已经<code>cancel</code>了</p>
<p>更多状态请参考<a href="https://developer.apple.com/documentation/foundation/operation#1661262">Apple Developer: Maintaining Operation Object States</a></p>
</li>
</ul>
<h5 id="7-2、OperationQueue"><a href="#7-2、OperationQueue" class="headerlink" title="7.2、OperationQueue"></a>7.2、<a href="https://developer.apple.com/documentation/foundation/operationqueue">OperationQueue</a></h5><ul>
<li><p><strong>OperationQueue</strong>可以加入多个<code>Operation</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ope1 <span class="operator">=</span> <span class="type">Operation</span>()</span><br><span class="line"><span class="keyword">let</span> ope2 <span class="operator">=</span> <span class="type">Operation</span>()</span><br><span class="line">       </span><br><span class="line"><span class="keyword">let</span> que <span class="operator">=</span> <span class="type">OperationQueue</span>()</span><br><span class="line">que.addOperation(ope1)</span><br><span class="line">que.addOperation(ope2)</span><br></pre></td></tr></table></figure></li>
<li><p><code>maxConcurrentOperationCount</code>可设置最大并发数当前,默认情况下，系统会根据当前情况动态确定最大并发数</p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">que.maxConcurrentOperationCount <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>此处需要注意的是最大并发数并不是线程数，最大并发数表示的是当前队列最多可同时执行的的任务（或线程）数量。</p>
<ul>
<li>可取消所有<code>Operation</code>，但当前正在执行的<code>Operation</code>不会取消</li>
<li>所有的<code>Operation</code>执行完毕后退出销毁</li>
</ul>
<h5 id="7-3、BlockOperation"><a href="#7-3、BlockOperation" class="headerlink" title="7.3、BlockOperation"></a>7.3、<a href="https://developer.apple.com/documentation/foundation/blockoperation">BlockOperation</a></h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> queblock <span class="operator">=</span> <span class="type">BlockOperation</span>.<span class="keyword">init</span>(block: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> que <span class="operator">=</span> <span class="type">OperationQueue</span>.<span class="keyword">init</span>()</span><br><span class="line">que.maxConcurrentOperationCount <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">que.addOperation(queblock)</span><br></pre></td></tr></table></figure>
<h5 id="7-4、completionBlock"><a href="#7-4、completionBlock" class="headerlink" title="7.4、completionBlock"></a>7.4、<a href="https://developer.apple.com/documentation/foundation/operation/1408085-completionblock">completionBlock</a></h5><p>当执行完一个任务时的回调.<br>我们可以通过创建Operation的方法，首先创建一个<code>Operation</code>对象，然后将其添加到队列中，这样做就可以通过设置<code>completionBlock</code>，在任务完成时得到通知。</p>
<h5 id="7-5、默认优先级"><a href="#7-5、默认优先级" class="headerlink" title="7.5、默认优先级"></a>7.5、默认优先级</h5><p>苹果为<strong>Operation</strong>提供了优先级，<strong>Operation</strong>通过<a href="https://developer.apple.com/documentation/foundation/operation/1413553-qualityofservice">qualityOfService</a>属性来控制其优先级,来看源码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">QualityOfService</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> userInteractive <span class="operator">=</span> <span class="number">33</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> userInitiated <span class="operator">=</span> <span class="number">25</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> utility <span class="operator">=</span> <span class="number">17</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> background <span class="operator">=</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> `default` <span class="operator">=</span> <span class="operator">-</span><span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>userInteractive</strong>: 最高优先级，用于用户交互事件</li>
<li><strong>userInitiated</strong>:次高优先级，用于用户需要马上执行的事件</li>
<li><strong>utility</strong>:普通优先级，用于普通任务</li>
<li><strong>background</strong>:最低优先级，用于不重要的任务</li>
<li><strong>default</strong>:默认优先级，主线程和没有设置优先级的线程都默认为这个优先级</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operation.qualityOfService <span class="operator">=</span> .default</span><br></pre></td></tr></table></figure>
<p>通过<a href="https://developer.apple.com/documentation/foundation/operation/1411204-queuepriority">queuePriority</a>属性来控制在<code>OperationQueue</code>中的优先级：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">QueuePriority</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> veryLow <span class="operator">=</span> <span class="operator">-</span><span class="number">8</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> low <span class="operator">=</span> <span class="operator">-</span><span class="number">4</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> normal <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> high <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> veryHigh <span class="operator">=</span> <span class="number">8</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">operation.queuePriority &#x3D; .high</span><br></pre></td></tr></table></figure>
<h5 id="7-6、使用OperationQueue下载图片"><a href="#7-6、使用OperationQueue下载图片" class="headerlink" title="7.6、使用OperationQueue下载图片"></a>7.6、使用<strong>OperationQueue</strong>下载图片</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个队列</span></span><br><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">OperationQueue</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Operation</span></span><br><span class="line">queue.addOperation &#123;</span><br><span class="line">et image <span class="operator">=</span> <span class="type">DownloaderManager</span>.downloadImageWithURL(imgurl)</span><br><span class="line"><span class="type">OperationQueue</span>.main.addOperation &#123;</span><br><span class="line">     girlsImg.image <span class="operator">=</span> image </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里需要注意的是：更新UI的代码要放到主线程中完成。使用<code>OperationQueue.main</code>获取主线程队列，然后添加<code>addOperation</code>把更新UI的任务放到主线程。<br>如果需要在下载完成时做一些相关操作，可以使用<code>completionBlock</code>,</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> operation <span class="operator">=</span> <span class="type">BlockOperation</span>(block: &#123;</span><br><span class="line">     <span class="comment">// 要执行的任务，如下载图片等</span></span><br><span class="line">     <span class="keyword">let</span> image <span class="operator">=</span> <span class="type">DownloaderManager</span>.downloadImageWithURL(imgurl)</span><br><span class="line">     <span class="comment">// 下载完成后，返回主线程渲染图片</span></span><br><span class="line">     <span class="type">OperationQueue</span>.main.addOperation &#123;</span><br><span class="line">         girlsImg.image <span class="operator">=</span> image</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line">operation.completionBlock <span class="operator">=</span> &#123;</span><br><span class="line">     <span class="comment">// 执行完成后</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置最大并发数 不设置时系统回根据当前情况动态设置最大并发数 设置为1时为串行队列</span></span><br><span class="line">queue.maxConcurrentOperationCount <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 将Operation添加到queue队列中</span></span><br><span class="line">queue.addOperation(operation)</span><br></pre></td></tr></table></figure>
<h5 id="7-7、设置任务之间的关联性"><a href="#7-7、设置任务之间的关联性" class="headerlink" title="7.7、设置任务之间的关联性"></a>7.7、设置任务之间的关联性</h5><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdaa9343667a42e4bf9562740fe05738~tplv-k3u1fbpfcp-watermark.image" alt="设置任务之间的关联性"><br>如图所示,当点击download按钮的时候开始下载图片，但是客户要求按照432的顺序加载，但是图片1不影响，此处需要用到<code>addDependency</code>方法，让图片按照432的顺序下载，图片1并行下载，核心代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">OperationQueue</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> operation1 <span class="operator">=</span> <span class="type">BlockOperation</span>(block: &#123;</span><br><span class="line">       <span class="keyword">let</span> image <span class="operator">=</span> <span class="type">DownloaderManager</span>.downloadImageWithURL(imgArray[<span class="number">0</span>])</span><br><span class="line">       <span class="type">OperationQueue</span>.main.addOperation &#123;</span><br><span class="line">           <span class="keyword">self</span>.girlsImg1.image <span class="operator">=</span> image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">operation1.completionBlock <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-------operation1&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> operation2 <span class="operator">=</span> <span class="type">BlockOperation</span>(block: &#123;</span><br><span class="line">        <span class="keyword">let</span> image <span class="operator">=</span> <span class="type">DownloaderManager</span>.downloadImageWithURL(imgArray[<span class="number">1</span>])</span><br><span class="line">        <span class="type">OperationQueue</span>.main.addOperation &#123;</span><br><span class="line">           <span class="keyword">self</span>.girlsImg2.image <span class="operator">=</span> image</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line">operation2.completionBlock <span class="operator">=</span> &#123;</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;-------operation2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> operation3 <span class="operator">=</span> <span class="type">BlockOperation</span>(block: &#123;</span><br><span class="line">    <span class="keyword">let</span> image <span class="operator">=</span> <span class="type">DownloaderManager</span>.downloadImageWithURL(imgArray[<span class="number">2</span>])</span><br><span class="line">        <span class="type">OperationQueue</span>.main.addOperation &#123;</span><br><span class="line">          <span class="keyword">self</span>.girlsImg3.image <span class="operator">=</span> image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">operation3.completionBlock <span class="operator">=</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;-------operation3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> operation4 <span class="operator">=</span> <span class="type">BlockOperation</span>(block: &#123;</span><br><span class="line">    <span class="keyword">let</span> image <span class="operator">=</span> <span class="type">DownloaderManager</span>.downloadImageWithURL(imgArray[<span class="number">7</span>])</span><br><span class="line">    <span class="type">OperationQueue</span>.main.addOperation &#123;</span><br><span class="line">         <span class="keyword">self</span>.girlsImg4.image <span class="operator">=</span> image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">operation4.completionBlock <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-------operation4&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">operation3.addDependency(operation4)</span><br><span class="line">operation2.addDependency(operation3)</span><br><span class="line">        </span><br><span class="line">queue.addOperation(operation1)</span><br><span class="line">queue.addOperation(operation4)</span><br><span class="line">queue.addOperation(operation3)</span><br><span class="line">queue.addOperation(operation2)</span><br></pre></td></tr></table></figure>
<p>此处把添加<code>Operation</code>到<code>Queue</code>的操作，放到了<code>addDependency</code>之后，确保执行前有正确的依赖关系。多次运行代码可以看到，图片的下载顺序依然是4-&gt;3-&gt;2的顺序。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-------</span>operation1</span><br><span class="line"><span class="operator">-------</span>operation4</span><br><span class="line"><span class="operator">-------</span>operation3</span><br><span class="line"><span class="operator">-------</span>operation2</span><br></pre></td></tr></table></figure>
<h5 id="7-8、取消执行的任务"><a href="#7-8、取消执行的任务" class="headerlink" title="7.8、取消执行的任务"></a>7.8、取消执行的任务</h5><p>除了设置一个队列中任务关联性之外，还可以控制取消队列中的任务，但是取消的结果会根据任务的状态而不同：</p>
<ul>
<li><p>已经完成的任务，取消不影响其结果</p>
</li>
<li><p>当一个任务被取消时所有与其关联的任务也会被取消</p>
</li>
<li><p>任务被取消后，<code>completionBlock</code>依旧会执行</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7b15b84bc8a490396eefb6115858fdc~tplv-k3u1fbpfcp-watermark.image" alt="取消图片下载"></p>
<p>如图所示，当我点击<code>download</code>按钮后快速点击<code>cancel</code>按钮，可以看到图片一的下载任务被<code>cancel</code>了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cancelItem <span class="operator">=</span> <span class="type">UIBarButtonItem</span>()</span><br><span class="line">cancelItem.title <span class="operator">=</span> <span class="string">&quot;cancel&quot;</span></span><br><span class="line">cancelItem.rx.tap.subscribe(onNext: &#123;</span><br><span class="line">    <span class="keyword">self</span>.queue.cancelAllOperations()</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>此处可以通过<code>Operation</code>的<code>isCancelled</code>属性来判断任务是否被<code>cancel</code>。当<code>isCancelled</code>返回<code>true</code>表示该任务被<code>cancel</code>了。</p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">-------</span>operation4,<span class="literal">false</span></span><br><span class="line"><span class="operator">-------</span>operation3,<span class="literal">false</span></span><br><span class="line"><span class="operator">-------</span>operation2,<span class="literal">false</span></span><br><span class="line"><span class="operator">-------</span>operation1,<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>本文主要简单介绍了Operation的一些简单应用，正确的理解和应用这些多线程技术是构建复杂App的基础，关于更多多线程的应用可参考官方多线程的文档：</p>
<p><strong><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html">Apple Developer Threading Programming Guide</a></strong></p>
<p><strong><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW2">Apple Developer About Dispatch Queues</a></strong></p>
<p><strong><a href="https://github.com/dengfeng520/RPDemo/tree/main/OperationDemo">本文demo</a></strong></p>
]]></content>
  </entry>
  <entry>
    <title>优雅的利用Lottie实现炫酷的动画效果</title>
    <url>/2020/04/28/%E4%BC%98%E9%9B%85%E7%9A%84%E5%88%A9%E7%94%A8Lottie%E5%AE%9E%E7%8E%B0%E7%82%AB%E9%85%B7%E7%9A%84%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h6 align='right'>小时光</h6>


<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<code>APP</code>中的交互动画对整个<code>APP</code>来说是十分重要的。对用户来说，使用一款<code>APP</code>可能并不是这个<code>APP</code>界面做的绚丽，动画做的美之类的原因。纵然如此，一款<code>APP</code>只有动画优美，界面上做好了，才会吸引到用户，用户才会来使用这个<code>APP</code>。</p>
<blockquote>
<p>1、为什么用<code>Lottie</code></p>
</blockquote>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;对于一些简单的动画我们开发者可以使用系统提供的一些方法来实现，但是在实际开发中设计师给出的动画都是很炫酷复杂的，如果采用手写代码的方式，就要面对很对问题：</p>
<ul>
<li>（1）、<code>Android</code>和 <code>iOS</code>要针对系统来编写代码动画</li>
<li>（2）、同时由于不同系统之间的差异，比如<code>Android</code>能够实现的动画<code>iOS</code>不能实现，即使实现也要花费得不偿失的时间，这就造成在开发中一些动画被去掉或者简单化，最终还是没有达到设计师满意的效果</li>
<li>（3）、即使开发者通过代码实现了设计师的效果，可能会和设计师给出的效果有一些出入，这样就造成了沟通和修改的成本</li>
<li>（4）、 越是复杂的代码，编写的代码就会越多这样势必会对后期的维护造成很大的成本</li>
<li>（5）、 考虑到不断的版本迭代中需求的变更，修改代码也会有很大的成本</li>
</ul>
<p>所以综上所述的一些问题，此处给诸位推荐一个第三方动画库<a href="http://airbnb.io/lottie/">Lottie</a>。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;下面几个gif动画都是用<a href="http://airbnb.io/lottie/">Lottie</a>实现的。</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/Gif/LaunchScreen.gif?raw=true" alt="LaunchScreen.gif"></p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/Gif/refreshAnimationView.gif?raw=true" alt="refreshAnimationView.gif"></p>
<ul>
<li>（1）、<code>Lottie</code>是专门为移动开发设计的一个第三方库，目前支持<code>Android、iOS  、Web、React Native</code>等平台；</li>
<li>（2）、Lottie同时支持页面切换的过场动画(UIViewController Transitions)</li>
<li>（3）、<code>Lottie</code>的使用非常简单，直接读取资源文件或者读取服务器资源链接即可；</li>
<li>（4）、开发者可以轻松控制动画（播放进度、播放帧数、背景颜色等）；</li>
<li>（5）、<code>Lottie</code>是设计师通过<code>After Effects</code>将动画导出JSON文件，然后由<code>Lottie</code>加载和渲染这个文件并转成相应的代码，由于是JSON文件，文件也会很小，可以减少App包的大小</li>
<li>（6）、把动画制作和APP开发的工作分开，由设计师来完成动画的制作</li>
</ul>
<blockquote>
<p>2、Lottie 的实现原理</p>
</blockquote>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;实际上，<code>Lottie</code>在iOS上的实现是：</p>
<p>**  将<code>After Effects</code>编辑的动画内容，通过JSON作为媒介一一映射到iOS的 <code>LayerModel</code>、<code>Keyframe</code>、<code>ShapeItem</code>、<code>DashElement</code>、<code>Marker</code>、<code>Mask</code>、<code>Transfrom</code>这些类的属性中并保存了下来，然后 再通过<code>CoreAnimation</code>进行渲染。**</p>
<blockquote>
<p>3、Lottie 的简单使用</p>
</blockquote>
<p>######1、 导入工程</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<code>Lottie</code>的使用非常简单，只要集成了<code>Lottie</code>框架，然后在程序中通过<code>Loattie</code>的接口控制设计通过AE生成的JSON就行了。<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;官方推荐<code>iOS</code>开发者使用<code>Pod</code>来管理,其他平台开发者可参考<a href="http://airbnb.io/lottie/">Lottie官网</a>给出的方案。<br>在<code>Podfile</code>文件中导入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &#39;lottie-ios&#39;</span><br></pre></td></tr></table></figure>
<p><code>cd</code>到工程目录下执行安装命令即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure>
<p>######2、 初始化一个动画<br>在需要的<code>Lottie</code>动画的类引入头文件，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Lottie</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 加载本地资源</span><br><span class="line"> let path : String &#x3D; Bundle.main.path(forResource: &quot;Refresh&quot;, ofType: &quot;json&quot;)!</span><br><span class="line"> let lottieAnimationView &#x3D; AnimationView.init(filePath: path)</span><br><span class="line"> let lottieAnimationView &#x3D; AnimationView.init(name: &quot;Refresh&quot;)</span><br><span class="line">&#x2F;&#x2F; load from URL</span><br><span class="line"> let animationView &#x3D; LOTAnimationView(contentsOf: WebURL)</span><br><span class="line"> let lottieAnimationView &#x3D; AnimationView.init(url: WebURL, closure:&#123;</span><br><span class="line">           down in</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>######3、动画的播放和控制<br>运行代码，此时动画只停在第一帧，因为并没有让动画执行，执行播放：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lottieAnimationView.play()</span><br></pre></td></tr></table></figure>
<p>如果在动画执行完 还有其他的逻辑，可使用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lottieAnimationView.play &#123; (animationFinished) in</span><br><span class="line">   print(&quot;其他相关业务&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要这个动画循环播放：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lottieAnimationView.loopMode &#x3D; .loop</span><br></pre></td></tr></table></figure>
<p>同时可以控制帧数和播放进度来实现顺序播放或者逆序播放：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 播放进度</span><br><span class="line">lottieAnimationView.play(fromProgress: 0.25, toProgress: 0.5, loopMode: .loop) &#123; (animationFinished) in</span><br><span class="line">            </span><br><span class="line"> &#125;</span><br><span class="line">&#x2F;&#x2F; 播放帧数</span><br><span class="line">lottieAnimationView.play(fromFrame: 0, toFrame: 5, loopMode: .loop) &#123; (animationFinished) in</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要逆序播放，只需将帧数或进度的顺序调整即可，如顺序是0 –&gt; 5帧，逆序则是5 –&gt; 0:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lottieAnimationView.play(fromProgress: 0.5, toProgress: 0.25, loopMode: .loop) &#123; (animationFinished) in</span><br><span class="line">            </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">lottieAnimationView.play(fromFrame: 5, toFrame: 0, loopMode: .loop) &#123; (animationFinished) in</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用<code>Lottie</code>动画时，由于程序业务关系，我们需要在这段动画没有执行完之前就执行下一段动画，此时可直接从某一帧执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lottieAnimationView.play(fromFrame: 20, toFrame: 50, loopMode: .loop) &#123; (animationFinished) in</span><br><span class="line">           loadingAnimationView.play()</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>如果要停止动画并保持当前帧数，可使用<code>pause()</code>,<br>如果要停止动画并回到初始帧，可使用<code>top()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lottieAnimationView.pause()</span><br><span class="line">lottieAnimationView.stop()</span><br></pre></td></tr></table></figure>
<p>更多使用，如修改关键帧数的参数颜色等可参考<a href="http://airbnb.io/lottie/#/ios?id=ios-sample-app">Lottie官网</a></p>
<blockquote>
<p>4、总结</p>
</blockquote>
<p>对于程序中比较复杂的动画用<code>iOS</code>系统为开发者提供的<code>API</code>无法实现的，建议使用<code>Lottie</code>动画，对于一些简单的动画，建议使用系统提供的<code>API</code>来实现，可以参考<a href="https://zsisme.gitbooks.io/ios-/content/index.html">iOS核心动画技巧</a>。</p>
<p>以上是我在使用<code>Lottie</code>时的一些总结，更多使用请参考<a href="http://airbnb.io/lottie/ios.html#swift-examples">Github</a>。</p>
<hr>
<p><a href="https://github.com/dengfeng520/One-Swift.git">本文demo</a></p>
<p><a href="https://github.com/airbnb/lottie-ios">Lottie官方demo</a></p>
<p><a href="http://svga.io/">友情链接:SVGA</a></p>
]]></content>
  </entry>
  <entry>
    <title>基于MVVM构建聊天App （一）从新建工程开始</title>
    <url>/2021/01/05/%E5%9F%BA%E4%BA%8EMVVM%E6%9E%84%E5%BB%BA%E8%81%8A%E5%A4%A9App(%E4%B8%80)%E4%BB%8E.../</url>
    <content><![CDATA[<h6 align='right'>小时光</h6>
<h6  align='right'>北京体适能体育科技有限公司</h6> 


<p><strong>在开发一个新的App时不仅要考虑当前版本的需求，更要考虑到后期的版本迭代和维护工作 《Clean Code》一书中也提出<code>代码大部分时候是用来维护的，而不是用来实现功能的</code>。所以在前期的框架设计，技术调查上应该慎之又慎。本次我将从个人开发者角度围绕着代码的可维护性、可测试性、可复用性来实现一个简单的聊天App。</strong></p>
<h3 id="1、基本设置"><a href="#1、基本设置" class="headerlink" title="1、基本设置"></a>1、基本设置</h3><p>新建一个工程，命名为<code>RPChat</code>,此处开发语言选择<code>Swift</code>:</p>
<p>(1)、在工程中设置<strong>Info.plist</strong>中设置<strong>Allow Arbitrary Loads</strong>为YES，参考:<a href="https://stackoverflow.com/questions/31254725/transport-security-has-blocked-a-cleartext-http">stackoverflow Transport security has blocked a cleartext HTTP</a></p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/https%E9%85%8D%E7%BD%AE.png?raw=true" alt="https配置"></p>
<p>(2)、打开<code>Assets.xcassets</code>按照指定的图片大小添加App的Logo图片。</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/Logo.png?raw=true" alt="Logo"></p>
<h3 id="2、工程结构"><a href="#2、工程结构" class="headerlink" title="2、工程结构"></a>2、工程结构</h3><p>添加三个<code>framework</code>分别命名为<strong>RPChat_iOS、RPChatUIKit、RPChatDataKit</strong></p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/addframework1.png?raw=true" alt="添加framework"></p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/addframework2.png?raw=true" alt="添加framework"></p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/addframework3.png?raw=true" alt="工程目录"></p>
<ul>
<li><strong>RPChat_iOS</strong>是和UI的显示以及交互相关的代码</li>
<li><strong>RPChatUIKit</strong>是整个项目中会用到的对UIKit的公共扩展</li>
<li><strong>RPChatDataKit</strong>是整个项目的数据存储以及访问接口，也可以理解为是App的View Model以及Model</li>
</ul>
<h3 id="3、使用carthage管理第三方开源库"><a href="#3、使用carthage管理第三方开源库" class="headerlink" title="3、使用carthage管理第三方开源库"></a>3、使用carthage管理第三方开源库</h3><h5 id="1、carthage使用"><a href="#1、carthage使用" class="headerlink" title="1、carthage使用"></a>1、carthage使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">carthage version</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;Users&#x2F;****&#x2F;Desktop&#x2F;GitHub&#x2F;RPChat</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch Cartfile</span><br></pre></td></tr></table></figure>
<p>使用VSCode打开<code>Cartfile</code>文件，输入用到的第三方开源库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github &quot;Alamofire&#x2F;Alamofire&quot; &#x2F;&#x2F; Http请求封装</span><br><span class="line">github &quot;ReactiveX&#x2F;RxSwift&quot; &#x2F;&#x2F; 用于管理App中的事件</span><br><span class="line">github &quot;onevcat&#x2F;Kingfisher&quot; &#x2F;&#x2F; 用于App中的缓存和下载图片</span><br><span class="line">github &quot;SwiftyJSON&#x2F;SwiftyJSON&quot; &#x2F;&#x2F; 生成Model</span><br><span class="line">gitHub &quot;CoderMJLee&#x2F;MJRefresh&quot; &#x2F;&#x2F; UItableView下拉组件</span><br><span class="line">github &quot;robbiehanson&#x2F;CocoaAsyncSocket&quot; </span><br></pre></td></tr></table></figure>
<p>执行更新命令： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">carthage update --platform iOS --no-use-binaries</span><br></pre></td></tr></table></figure>
<h5 id="2、Using-Carthage-with-Xcode-12"><a href="#2、Using-Carthage-with-Xcode-12" class="headerlink" title="2、Using Carthage with Xcode 12"></a>2、Using Carthage with Xcode 12</h5><p>升级Xcode 12后，执行上面的命令可能会报错，解决方法可参考：<br><a href="https://github.com/Carthage/Carthage/blob/master/Documentation/Xcode12Workaround.md">Using Carthage with Xcode 12</a></p>
<p>然后使用以下命令执行<code>carthage</code>更新：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">carthage.sh bootstrap --platform iOS --cache-builds</span><br></pre></td></tr></table></figure>
<p>更新完成后，打开工程，选择<strong>TARGETS</strong> –&gt;<strong>Build Phases</strong>–&gt; <strong>Link Binary With Libries</strong> 点击加号，选择 <strong>Add File</strong> –&gt; <strong>Carthage</strong> –&gt; <strong>Build</strong> –&gt; <strong>iOS</strong> 添加所需的<code>FrameWork</code>,</p>
<p>下面的gif演示了如何添加第三方的<code>FrameWork</code>；</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/addgif.gif?raw=true" alt="gif"></p>
<p>接下来，点击+，选择<code>New Run Script Phase</code>，此时新建了<code>Run Script</code>,在执行命令中添加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;Carthage copy-frameworks</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/NewRunScript.png?raw=true" alt="New Run Script"></p>
<h5 id="3、解决the-file-couldn’t-be-saved-报错问题"><a href="#3、解决the-file-couldn’t-be-saved-报错问题" class="headerlink" title="3、解决the file couldn’t be saved.报错问题"></a>3、解决<code>the file couldn’t be saved.</code>报错问题</h5><p>添加完后再次build可能会报错：<code>the file couldn’t be saved. command phasescriptexecution failed with a nonzero exit code</code></p>
<p>解决方案参考：<a href="https://github.com/Carthage/Carthage/issues/3056">carthage copy-frameworks produces “The file couldn’t be saved.” error #3056</a></p>
<p>Add to <code>run scripts</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf $&#123;TMPDIR&#125;&#x2F;TemporaryItems&#x2F;*carthage*</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;carthage copy-frameworks</span><br></pre></td></tr></table></figure>
<p>再次build成功。</p>
<p>在<code>Input Files</code>中引入我们要用到的库的路径:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(SRCROOT)&#x2F;Carthage&#x2F;Build&#x2F;iOS&#x2F;Alamofire.framework</span><br></pre></td></tr></table></figure>
<p>其作用是把<code>Carthage</code>引入的第三方库在打包的时候，拷贝到特定目录。</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/Carthage.png?raw=true" alt="Carthage"></p>
<p>在上传到git仓库时，不需要传<code>Carthage</code>下的文件，所以选择忽略，在<code>.gitignore</code>文件中添加</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/gitignore.png?raw=true" alt=".gitignore"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*.DS_Store</span><br><span class="line">Carthage&#x2F;</span><br><span class="line">xcuserdata&#x2F;</span><br><span class="line">.idea&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="4、兼容iOS-13之前的老版本"><a href="#4、兼容iOS-13之前的老版本" class="headerlink" title="4、兼容iOS 13之前的老版本"></a>4、兼容iOS 13之前的老版本</h3><p>修改最低支持版本为<code>iOS 11</code></p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/iOSVer.png?raw=true" alt="iOS 最低版本"></p>
<p>此时发现再Build工程，发现已经有很多<code>Error</code>，这是版本兼容的问题，由于<code>Xcode 11</code>新建的工程默认为当前最高版本，Xcode新增了一个<code>SceneDelegate</code>文件，具体作用请参考官方文档：<a href="https://developer.apple.com/videos/play/wwdc2019/423/">Optimizing App Launch</a>。现在要在<code>AppDelegate</code>和中<code>SceneDelegate</code>做兼容老版本处理。 方法就是对当前系统做一个判断，然后再根据不同系统版本分开处理。</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/vererror.png?raw=true" alt="版本报错"></p>
<p>在<code>SceneDelegate</code>直接加上<code>@available(iOS 13.0, *)</code>即可,<br>在<code>AppDelegate</code>做扩展处理：</p>
<p>代码如下： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@available(iOS 13.0, *)</span><br><span class="line">class SceneDelegate: UIResponder, UIWindowSceneDelegate &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@available(iOS 13.0, *)</span><br><span class="line">extension AppDelegate &#123;</span><br><span class="line">    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -&gt; UISceneConfiguration &#123;</span><br><span class="line">         return UISceneConfiguration(name: &quot;Default Configuration&quot;, sessionRole: connectingSceneSession.role)</span><br><span class="line">    &#125;</span><br><span class="line">    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set&lt;UISceneSession&gt;) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5、国际化"><a href="#5、国际化" class="headerlink" title="5、国际化"></a>5、国际化</h3><h5 id="1、常用文案国际化"><a href="#1、常用文案国际化" class="headerlink" title="1、常用文案国际化"></a>1、常用文案国际化</h5><ul>
<li>1、如下图所示： 创建所需国际化的语言，此处我创建了英语、繁体汉语、简体汉语：</li>
</ul>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/Localizable1.png?raw=true" alt="Localizable1"></p>
<ul>
<li>2、在工程中新建一个<code>String File</code>文件，命名为<code>Localizable</code></li>
</ul>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/Localizable2.png?raw=true" alt="国际化2"></p>
<p> 点击到Localizable.strings文件，点击右侧Localize…按钮添加需要国际化的语言。</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/Localizable3.png?raw=true" alt="国际化3"></p>
<p>此时来做个测试，在<code>ViewController</code>新建一个名为<code>testLab</code>的<code>UILabel</code>;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@IBOutlet weak var testLab: UILabel!</span><br></pre></td></tr></table></figure>
<p>展开<code>Localize.strings</code>文件，在英文中添加<code>test;</code>,在简体中文中添加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;test&quot; &#x3D; &quot;测试&quot;;</span><br></pre></td></tr></table></figure>
<p>在<code>ViewController</code>中调用，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">testLab.text &#x3D; NSLocalizedString(&quot;test&quot;, comment: &quot;&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/test1.png?raw=true" alt="test"></p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/test2.png?raw=true" alt="测试"></p>
<p>此时点击Run可以看到<code>testLab</code>显示内容为<code>test</code>;</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/test3.png?raw=true" alt="English"></p>
<p>修改模拟器语言为简体汉语，再次运行：</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/test4.png?raw=true" alt="简体汉语"></p>
<h5 id="2、App名称国际化"><a href="#2、App名称国际化" class="headerlink" title="2、App名称国际化"></a>2、App名称国际化</h5><ul>
<li><p>（1）、同样的方法新建一个名为<code>InfoPlist</code>的<code>String</code>文件。</p>
</li>
<li><p>(2)、在<code>InfoPlist.strings(English)</code>文件中添加:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFBundleName &#x3D; &quot;CatchU&quot;;</span><br></pre></td></tr></table></figure></li>
<li><p>(3)、在 <code>InfoPlist.strings(Chinese,Simplified)</code>中添加</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFBundleName &#x3D; &quot;畅聊吧&quot;;</span><br></pre></td></tr></table></figure></li>
<li><p>(4)、 打开<code>Info.Plist</code>设置<code>Bundle name</code>属性为<code>$CFBundleName</code></p>
</li>
</ul>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/test5.png?raw=true" alt="Bundle name"></p>
<ul>
<li>(5)、再次运行代码，可以看到，App的名称已经修改成功了。</li>
</ul>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/icon.png?raw=true" alt="App Name"></p>
<p>本篇主要讲了App的新建和相关配置，包括：</p>
<ul>
<li> 新建工程，基本配置</li>
<li>通过三个<code>frameworks</code>去实现App不同层次的功能</li>
<li>通过<code>Carthage</code>管理工程中用的第三方开源库</li>
<li>对iOS 13之前的系统做一个兼容处理</li>
<li>国际化相关</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Swift的方式来使用数组</title>
    <url>/2020/04/28/Swift%20%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h6 align='right'>小时光</h6>

<p>Array是在开发中最常用的数据类型之一，<a href="https://developer.apple.com/documentation/swift/array">官方文档</a>对Array的定义是：<code>An ordered, random-access collection.</code>。通常表示一个有序的集合，这里所说的有序并不是大小有序，而是指<code>Array</code>中元素的先后位置关系。</p>
<h3 id="1、Swift的方式来操作数组"><a href="#1、Swift的方式来操作数组" class="headerlink" title="1、Swift的方式来操作数组"></a>1、Swift的方式来操作数组</h3><h5 id="1-1、创建Array的N种方法"><a href="#1-1、创建Array的N种方法" class="headerlink" title="1.1、创建Array的N种方法"></a>1.1、创建Array的N种方法</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testArray1: <span class="type">Array</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> testArray2: [<span class="type">Int</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="keyword">var</span> testArray3 <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line"><span class="keyword">var</span> testArray4 <span class="operator">=</span> testArray3</span><br></pre></td></tr></table></figure>
<p>在上面的代码块中，<code>Array&lt;Int&gt;</code>和<code>[Int]()</code>没有本质区别，随便使用哪种方式都可以初始化一个<code>Array</code>。而最后一种直接使用了一个空的<code>Array</code>生成了一个新的<code>Array</code>对象。</p>
<h5 id="1-2、定义数组时同时指定初始值的方法"><a href="#1-2、定义数组时同时指定初始值的方法" class="headerlink" title="1.2、定义数组时同时指定初始值的方法"></a>1.2、定义数组时同时指定初始值的方法</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testInts <span class="operator">=</span> [<span class="type">Int</span>](repeating: <span class="number">6</span>, count: <span class="number">3</span>) <span class="comment">// [6, 6, 6]</span></span><br><span class="line"><span class="keyword">var</span> sixInts <span class="operator">=</span> testInts <span class="operator">+</span> testInts <span class="comment">// [6, 6, 6, 6, 6, 6]</span></span><br></pre></td></tr></table></figure>
<h5 id="1-3、count和isEmtpy属性"><a href="#1-3、count和isEmtpy属性" class="headerlink" title="1.3、count和isEmtpy属性"></a>1.3、<strong>count</strong>和<strong>isEmtpy</strong>属性</h5><p><code>count</code>返回数组集合中元素的个数，类型是<code>Int</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> testArray <span class="operator">=</span> [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> countInts <span class="operator">=</span> testArray.count <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p><code>isEmpty</code>表示数组是否为空，类型是<code>Bool</code>再对数组操作前我们可以先判断数组是否为空再下一步操作</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> testArray <span class="operator">=</span> [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> testArray.isEmpty <span class="operator">==</span> <span class="literal">false</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> mapArray <span class="operator">=</span> testArray.map(&#123; (mapString) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">         <span class="keyword">return</span> mapString</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数组为空&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-4、访问Array中的元素"><a href="#1-4、访问Array中的元素" class="headerlink" title="1.4、访问Array中的元素"></a>1.4、访问<strong>Array</strong>中的元素</h5><h6 id="1-4-1、通过索引访问数组的某个元素"><a href="#1-4-1、通过索引访问数组的某个元素" class="headerlink" title="1.4.1、通过索引访问数组的某个元素"></a>1.4.1、通过索引访问数组的某个元素</h6><p>在几乎所有的开发语言中都惯用索引（或下标）的方式访问数组数组中的元素，因为我们在使用索引访问数组的元素时没法保证索引的安全性，所以这种方式存在数组越界的风险，稍不注意就会导致整个程序直接<code>Crash</code>，从而给用户造成不好的体验。<br>当然<code>Swift</code>也支持这种方式，但苹果却不推荐开发者使用这种方式访问数组元素。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> testArray <span class="operator">=</span> [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> sevenStr <span class="operator">=</span> testArray[<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>如上面的代码，使用这种方式访问数组元素，如果直接访问不做处理会导致程序直接<code>crash</code>，在调试时，可以看到编译器直接报错：<code>Thread 1: Fatal error: Index out of range</code>, 所以在使用索引访问数组元素时应该慎重在慎重。那么在<code>Swift</code>中如何优雅的访问数组元素呢？事实上，Swift的设计者是不推荐开发者使用这种下标取值的方式。</p>
<p>使用type方法可以看到，这种方式返回的值为<code>String</code>类型，这说明在使用下标取值时需要确认，取到的值为String类型，而不是<code>Optionals&lt;String&gt;</code>类型，我们在使用这种方式取值时没有<code>Optionals</code>保护数组越界的情况，在使用下标取值的方法时我们就要承担<strong>crash</strong>的风险。</p>
<h6 id="1-4-2、访问数组中某个范围内的元素"><a href="#1-4-2、访问数组中某个范围内的元素" class="headerlink" title="1.4.2、访问数组中某个范围内的元素"></a>1.4.2、访问数组中某个范围内的元素</h6><p>在<code>Swift</code>中我们可以通过使用<code>range operator</code>访问数组的一个范围,通过<code>range operator</code>方式得到的并不是一个<code>Array</code>,而是一个<a href="https://developer.apple.com/documentation/swift/arrayslice">ArraySlice</a>,<a href="https://developer.apple.com/documentation/swift/arrayslice">官方文档</a>对<code>ArraySlice</code>的定义是<code>A slice of an </code>Array<code>, </code>ContiguousArray<code>, or </code>ArraySlice<code> instance.</code>通俗来说，就是<code>Array</code>某一段内容的<code>View</code>,不保存数组的内容，只保存这个<code>view</code>引用的数组的范围。我们可以通过这个<code>view</code>创建一个新的<code>Array</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> testArray <span class="operator">=</span> [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> rangeArray <span class="operator">=</span> <span class="type">Array</span>(testArray[<span class="number">0</span><span class="operator">...</span><span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<h6 id="1-4-3、向数组中添加或删除元素"><a href="#1-4-3、向数组中添加或删除元素" class="headerlink" title="1.4.3、向数组中添加或删除元素"></a>1.4.3、向数组中添加或删除元素</h6><p>向数组的末尾添加元素，可以使用<code>append</code>方法, 或者使用<code>+=</code>的方式:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testArray <span class="operator">=</span> [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>]</span><br><span class="line">testArray.append(<span class="string">&quot;seven&quot;</span>) <span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;]</span></span><br><span class="line">testArray <span class="operator">+=</span> [<span class="string">&quot;eight&quot;</span>,<span class="string">&quot;nine&quot;</span>] <span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;]</span></span><br></pre></td></tr></table></figure>
<p>如果要在<code>Array</code>中间位置添加元素，可使用<code>insert</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testArray <span class="operator">=</span> [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>]</span><br><span class="line">testArray.insert(<span class="string">&quot;two&quot;</span>, at: <span class="number">1</span>) <span class="comment">// [&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;]</span></span><br><span class="line">testArray.insert(<span class="string">&quot;seven&quot;</span>, at: <span class="number">7</span>) <span class="comment">// Thread 1: Fatal error: Array index is out of range`</span></span><br></pre></td></tr></table></figure>
<p><code>insert</code>方法的第一个参数表示要插入的值，第二个参数表示要插入的位置索引，此处要注意的是：<strong>这个位置必须是一个合法的范围，即<code>0...array1.endIndex</code>,如果超出这个范围就会导致程序<code>Crash</code></strong></p>
<p>删除数组中的元素:</p>
<p>删除数组中的最后一个元素可以使用<code>removeLast()</code>方法，删除数组中的第一个元素可以使用<code>removeFirst()</code>方法，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testArray <span class="operator">=</span> [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>,<span class="string">&quot;seven&quot;</span>]</span><br><span class="line">testArray.removeLast() <span class="comment">// [&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;]</span></span><br><span class="line">testArray.removeFirst() <span class="comment">// [&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;]</span></span><br><span class="line">testArray.remove(at: <span class="number">7</span>) <span class="comment">// Fatal error: Index out of range</span></span><br><span class="line"><span class="keyword">var</span> secondTestArray <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line">secondTestArray.removeFirst() <span class="comment">// Fatal error: Can&#x27;t remove first element from an empty collection</span></span><br><span class="line">secondTestArray.removeLast() <span class="comment">// Fatal error: Can&#x27;t remove last element from an empty collection</span></span><br><span class="line">secondTestArray.popLast() <span class="comment">// nil </span></span><br></pre></td></tr></table></figure>
<p><strong>当我们删除数组中的某个元素时，首先要确保数组不能为空，然后还要保证删除的索引在合法的范围内，然后在进行删除操作</strong></p>
<p>查找元素在数组中的位置:</p>
<p>如我要查找元素5在数组中的位置，可以使用<code>firstIndex</code>,返回的是一个<code>Optional&lt;Int&gt;</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> testList <span class="operator">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> oneIndex <span class="operator">=</span> testList.firstIndex &#123; <span class="variable">$0</span> <span class="operator">==</span> <span class="number">5</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ondexIndex===============<span class="subst">\(oneIndex <span class="operator">??</span> <span class="number">0</span>)</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>#####1.5、数组遍历</p>
<p>在开发中对<code>Array</code>每个元素的遍历也是常用操作:</p>
<h6 id="1-5-1、最简单的方式"><a href="#1-5-1、最简单的方式" class="headerlink" title="1.5.1、最简单的方式"></a>1.5.1、最简单的方式</h6><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> testArray <span class="operator">=</span> [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> vaule <span class="keyword">in</span> testArray &#123;</span><br><span class="line">    <span class="built_in">print</span>(vaule)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="1-5-2、遍历的时候，同时获得索引和值"><a href="#1-5-2、遍历的时候，同时获得索引和值" class="headerlink" title="1.5.2、遍历的时候，同时获得索引和值"></a>1.5.2、遍历的时候，同时获得索引和值</h6><p>使用数组对象的<code>enumerated()</code>方法，它会返回一个<code>Sequence</code>对象，包含了每个成员的索引和值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> testArray <span class="operator">=</span> [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> testArray.enumerated() &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(index)</span>: <span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="1-5-3、通过闭包closure遍历"><a href="#1-5-3、通过闭包closure遍历" class="headerlink" title="1.5.3、通过闭包closure遍历"></a>1.5.3、通过闭包<code>closure</code>遍历</h6><p>通过闭包<code>closure</code>，我们可以使用<code>Array</code>的<code>forEach</code>方法来遍历数组:</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> testArray <span class="operator">=</span> [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>]</span><br><span class="line">testArray.forEach &#123; (vaule) <span class="keyword">in</span></span><br><span class="line">     <span class="built_in">print</span>(vaule)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>for in</code>和 <code>forEach</code>遍历的效果是一样的，但是如果使用<code>forEach</code>方法遍历数组就不能通过<code>break</code>或<code>continue</code>来退出循环，如果要退出遍历就只能使用<code>for in</code>方法。</p>
   <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">testArray.forEach &#123; (testChar) <span class="keyword">in</span></span><br><span class="line"><span class="keyword">if</span> testChar <span class="operator">==</span> <span class="string">&quot;three&quot;</span> &#123;</span><br><span class="line">       <span class="keyword">continue</span> <span class="comment">// &#x27;continue&#x27; is only allowed inside a loop</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="1-5-4、map-、flatMap、-compactMap-、-filter-遍历数组"><a href="#1-5-4、map-、flatMap、-compactMap-、-filter-遍历数组" class="headerlink" title="1.5.4、map 、flatMap、 compactMap 、 filter 遍历数组"></a>1.5.4、map 、flatMap、 compactMap 、 filter 遍历数组</h6><p>   事实上，Swift的设计者并不推荐开发者使用传统的C语言风格的for循环。Swift为开发者提供了更高级的方法，当我们需要循环一个数组时，可以根据自己的需求，使用Map 和 Filter来实现。</p>
<p>   举例一：老师现在已经得到了学生的试卷成绩，再为每个学生加上平时成绩30分，这样可以得出学生的最终成绩,如果使用传统的C语言循环来实现：</p>
   <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fractionArray: [<span class="type">Int</span>] <span class="operator">=</span> [<span class="number">40</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">43</span>,<span class="number">56</span>,<span class="number">54</span>,<span class="number">33</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">70</span>,<span class="number">22</span>,<span class="number">69</span>]</span><br><span class="line"><span class="keyword">var</span> finallyList <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> fractionArray &#123;</span><br><span class="line">     finallyList.append(num <span class="operator">+</span> <span class="number">30</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [70, 83, 89, 73, 86, 84, 63, 85, 96, 100, 52, 99]</span></span><br></pre></td></tr></table></figure>
<p>再看看Swift为开发者提供的<strong>map</strong>方法：</p>
   <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fractionArray: [<span class="type">Int</span>] <span class="operator">=</span> [<span class="number">40</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">43</span>,<span class="number">56</span>,<span class="number">54</span>,<span class="number">33</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">70</span>,<span class="number">22</span>,<span class="number">69</span>]</span><br><span class="line"><span class="keyword">let</span> finallyArray: [<span class="type">Int</span>] <span class="operator">=</span> fractionArray.map &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="variable">$0</span> <span class="operator">+</span> <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [70, 83, 89, 73, 86, 84, 63, 85, 96, 100, 52, 99]</span></span><br></pre></td></tr></table></figure>
<p><code>map</code>用于把数组中的所有元素按照指定规则操作变换并返回一个新的数组，这样比使用for循环更具表现力。</p>
<p>   <strong>使用<code>map</code>来完成这类操作，大大提高了代码的可读性；<br>   同时使用<code>map</code>直接返回了一个常量数组；</strong></p>
<p>   当然<code>Swift</code>的设计者只是对<code>map</code>封装了<code>for</code>循环的代码，其核心代码如下：</p>
   <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">myselfMap</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">transform</span>: (<span class="type">Element</span>) -&gt; <span class="type">T</span>)</span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">         <span class="keyword">var</span> tmp: [<span class="type">T</span>] <span class="operator">=</span> []</span><br><span class="line">         tmp.reserveCapacity(count)</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">for</span> value <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">             tmp.append(transform(value))</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> tmp</span><br><span class="line">      &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><strong>flatMap</strong>和<strong>compactMap</strong>是<strong>map</strong>的升级版：</p>
<ul>
<li><p><strong>flatMap</strong>遍历时会把二维数组变为一维数组。</p>
</li>
<li><p><strong>compactMap</strong>在遍历数组的同时，去除其中的nil值。</p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lsArray: [<span class="type">Int</span>] <span class="operator">=</span> testList.compactMap &#123; (num) -&gt; <span class="type">Int</span>? <span class="keyword">in</span></span><br><span class="line"> <span class="keyword">return</span> num</span><br><span class="line">&#125; <span class="comment">// [1, 2, 2, 3, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p>举例二： 老师在算出学生成绩后要查看那些人的成绩是优秀，此时我们可以使用<code>filter</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> excellentArray <span class="operator">=</span> finallyArray.filter &#123;</span><br><span class="line">   <span class="variable">$0</span> <span class="operator">&gt;=</span> <span class="number">85</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [89, 86, 85, 96, 100, 99]</span></span><br></pre></td></tr></table></figure>
<p>   <strong>map在遍历数组的同时可以对每个参数做指定规则的操作，同时返回一个新的数组；<br>   filter只按指定规则遍历数组，同时返回一个新的数组</strong></p>
<p>   <code>filter</code>是怎么实现的呢，我们可以根据<code>map</code>的实现方法来实现,其核心代码如下：</p>
   <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myfilter</span>(<span class="keyword">_</span> <span class="params">predicate</span>: (<span class="type">Element</span>) -&gt; <span class="type">Bool</span>)</span> -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> tmp: [<span class="type">Element</span>] <span class="operator">=</span> []</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> <span class="keyword">self</span> <span class="keyword">where</span> predicate(value) &#123;</span><br><span class="line">            tmp.append(value)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="1-5-5、min-、-max"><a href="#1-5-5、min-、-max" class="headerlink" title="1.5.5、min 、 max"></a>1.5.5、min 、 max</h6><p>   同样老师如果需要计算本次考试的最高分和最低分，只要数组中的元素实现了<code>Equatable protocol</code>协议，开发者不用对数组进行任何操作，可直接调用<code>min 、 max</code>即可：</p>
   <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">finallyArray.min() <span class="comment">// 52</span></span><br><span class="line">finallyArray.max() <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<h6 id="1-5-6、sorted和partition对数组进行排序"><a href="#1-5-6、sorted和partition对数组进行排序" class="headerlink" title="1.5.6、sorted和partition对数组进行排序"></a>1.5.6、<code>sorted</code>和<code>partition</code>对数组进行排序</h6><p>接上面，如果老师要对本班成绩按从大到小或者从小到大的顺序排列，这样可以更直观的看到本班的成绩：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mixArray <span class="operator">=</span> finallyArray.sorted() <span class="comment">// [52, 63, 70, 73, 83, 84, 85, 86, 89, 96, 99, 100]</span></span><br><span class="line"><span class="keyword">let</span> maxArray <span class="operator">=</span> finallyArray.sorted(by: <span class="operator">&gt;</span>) <span class="comment">// [100, 99, 96, 89, 86, 85, 84, 83, 73, 70, 63, 52]</span></span><br></pre></td></tr></table></figure>
<h6 id="1-5-7、判断两个数组是否相等"><a href="#1-5-7、判断两个数组是否相等" class="headerlink" title="1.5.7、判断两个数组是否相等"></a>1.5.7、判断两个数组是否相等</h6><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">finallyArray.elementsEqual(mixArray, by: &#123;</span><br><span class="line">    <span class="variable">$0</span> <span class="operator">==</span> <span class="variable">$1</span></span><br><span class="line">&#125;) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h6 id="1-5-8、数组是否是以特定的排序开头"><a href="#1-5-8、数组是否是以特定的排序开头" class="headerlink" title="1.5.8、数组是否是以特定的排序开头"></a>1.5.8、数组是否是以特定的排序开头</h6><p>如老师要计算出本次考试成绩，是否有满分的:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mixArray.starts(with: [<span class="number">100</span>], by: &#123;</span><br><span class="line">    <span class="variable">$0</span> <span class="operator">==</span> <span class="variable">$1</span></span><br><span class="line">&#125;) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h6 id="1-5-9、计算数组中元素和"><a href="#1-5-9、计算数组中元素和" class="headerlink" title="1.5.9、计算数组中元素和"></a>1.5.9、计算数组中元素和</h6><p> 例如老师要计算本次考试的总成绩，然后计算出本次考试的平均成绩：</p>
<p> 如果使用C语言风格，我们首先要对成绩做一个遍历，然后累加最终得到全班成绩总和：</p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allNum <span class="operator">=</span> <span class="type">Int</span>()</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> finallyList &#123;</span><br><span class="line">    allNum <span class="operator">=</span> allNum <span class="operator">+</span> num</span><br><span class="line">&#125;</span><br><span class="line">allNum <span class="operator">/</span> (finallyList.count)</span><br></pre></td></tr></table></figure>
<p> <code>Swift</code>为开发者提供了更简单有效的方法：</p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">finallyList.reduce(<span class="number">0</span>, <span class="operator">+</span>) <span class="operator">/</span> (finallyList.count) <span class="comment">// 81</span></span><br></pre></td></tr></table></figure>
<h6 id="1-5-10、按条件把数组中的元素分类"><a href="#1-5-10、按条件把数组中的元素分类" class="headerlink" title="1.5.10、按条件把数组中的元素分类"></a>1.5.10、按条件把数组中的元素分类</h6><p>例如老师要分别统计出及格和没及格的成绩,我们认为60分为及格：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pass <span class="operator">=</span> mixArray.partition(by: &#123;</span><br><span class="line">    <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="number">60</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> failedArray <span class="operator">=</span> mixArray[<span class="number">0</span> <span class="operator">..&lt;</span> pass] <span class="comment">// 不及格的 [52]</span></span><br><span class="line"><span class="keyword">let</span> passArray <span class="operator">=</span> mixArray[pass <span class="operator">..&lt;</span> mixArray.endIndex] <span class="comment">// 及格的 [63, 70, 73, 83, 84, 85, 86, 89, 96, 99, 100]</span></span><br></pre></td></tr></table></figure>
<h3 id="2、解决数组越界问题"><a href="#2、解决数组越界问题" class="headerlink" title="2、解决数组越界问题"></a>2、解决数组越界问题</h3><p>通过对数组扩展全局处理数组越界问题：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">subscript</span> (<span class="params">to</span> <span class="params">index</span>: <span class="type">Index</span>)</span> -&gt; <span class="type">Iterator</span>.<span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> indices.contains(index) <span class="operator">?</span> <span class="keyword">self</span>[index] : <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、Array和NSArray"><a href="#3、Array和NSArray" class="headerlink" title="3、Array和NSArray"></a>3、Array和NSArray</h3><ul>
<li><p><code>Array</code> 是结构体，属于值类型, <code>NSArray</code> 是类，属于引用类型。</p>
</li>
<li><p><code>Array</code>是否可以被修改完全是通过<code>var</code>和<code>let</code>关键字来决定的，<code>Array</code>类型自身并不解决它是否可以被修改。</p>
</li>
<li><p><code>Array</code>如何转换为<code>NSArray</code></p>
<p> 参考： <a href="https://stackoverflow.com/questions/35811482/swift-how-to-convert-a-swift-array-to-nsarray">stackoverflow Swift - How to convert a swift array to NSArray?</a></p>
</li>
<li><p>赋值时内存</p>
<p>看下面两段代码</p>
<p>(1) 、 <code>Array</code>的<code>copy</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testArray <span class="operator">=</span> [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> copyArray <span class="operator">=</span> testArray</span><br><span class="line">testArray.append(<span class="string">&quot;seven&quot;</span>) <span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;]</span></span><br><span class="line"><span class="built_in">print</span>(copyArray) <span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;]</span></span><br></pre></td></tr></table></figure>
<p> (2) 、 <code>NSArray</code>的<code>copy</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mutArray <span class="operator">=</span> <span class="type">NSMutableArray</span>(array: [<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>])</span><br><span class="line"><span class="keyword">let</span> copyArray: <span class="type">NSArray</span> <span class="operator">=</span> mutArray</span><br><span class="line">mutArray.insert(<span class="string">&quot;seven&quot;</span>, at: <span class="number">6</span>) <span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;]</span></span><br><span class="line"><span class="built_in">print</span>(copyArray) <span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;]</span></span><br></pre></td></tr></table></figure>

<p>第一段代码中：复制<code>testArray</code>数组后并向<code>testArray</code>中添加元素，<code>copyArray</code>的内容并不会改变，因为在复制<code>testArray</code>数组时，并不是内容复制，而是内存地址复制，两个数组仍旧共用同一个内存地址，只有当修改了其中一个<code>Array</code>的内容时，才会生成一个新的内存。</p>
<p>第二段代码：复制<code>mutArray</code>数组，尽管<code>copyArray</code>为<code>NSArray</code>,此时我希望<code>copyArray</code>的值是不会改变的，但实际上当我修改了<code>mutArray</code>的值后<code>copyArray</code>的值也随之改变了。由于这个赋值执行的是引用拷贝，这两个数组指向的是同一个内存地址，所以当我们修改<code>mutArray</code>的内容时，<code>copyArray</code>也就间接受到了影响。</p>
<ul>
<li>当我门使用<code>NSArray</code>和<code>NSMutableArray</code>时，<code>Swift</code>种的<code>var</code>和<code>let</code>关键字就不起作用了。</li>
</ul>
<p>本文主要介绍了<code>Swift</code>中最常用的集合<code>Array</code>的一些基本用法，和<code>Objective-C</code>的<code>NSArray</code>的区别。</p>
<p>友情链接：</p>
<p><a href="https://developer.apple.com/documentation/swift/array">Apple developer Array</a></p>
<p><a href="https://boxueio.com/series/collection-types">泊学：Swift 3 Collections</a></p>
<p><a href="https://time.geekbang.org/course/detail/100034001-134747?utm_campaign=guanwang&utm_source=baidu-ad&utm_medium=ppzq-pc&utm_content=title&utm_term=baidu-ad-ppzq-title">极客时间：集合类</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>王者荣耀 苹果手机通过模拟定位修改战区</title>
    <url>/2020/08/11/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E4%BF%AE%E6%94%B9%E6%88%98%E5%8C%BA/</url>
    <content><![CDATA[<h6 align='right'>小时光</h6>

<p>来说说王者荣耀战区机制，王者荣耀每周一5点到6点这段时间会对上一周所有玩家的所有英雄战力做一个统计，然后根据会刷新出上周的英雄排行。所以每周一6点之后上号，如果玩家有上榜英雄，王者荣耀会给玩家想对应的牌子（就是省50强，100强，国服最强这些）。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb71852c97e74f00ba3da743679113d1~tplv-k3u1fbpfcp-zoom-1.image" alt="A1"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2f2ddc42085435881153cb25ed8a8f1~tplv-k3u1fbpfcp-watermark.image" alt="镜师傅"></p>
<p>那么就有一个很明显的问题，玩家多的城市，玩家就需要很高的英雄积分才能上榜但是玩家少的城市可能就随便打打就能上榜了。如广东的马超，玩家即使把分数肝到10000分以上也只能拿个省100强，但是东北或者内蒙等地区就能轻松拿到省前几名的牌子。</p>
<p>综上所述我们可以通过修改定位的方式来修改王者着荣耀的战区。Android手机由于其源码开源的原因，在网上有很多模拟定位的工具。本文主要介绍苹果手机如何通过模拟定位的方式来修改战区。</p>
<h3 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h3><ul>
<li>苹果手机（越狱没越狱都可以）</li>
<li>苹果电脑一台 </li>
<li>苹果数据线</li>
</ul>
<h3 id="2、开始模拟定位"><a href="#2、开始模拟定位" class="headerlink" title="2、开始模拟定位"></a>2、开始模拟定位</h3><ul>
<li>1、打开浏览器百度搜索 <a href="https://lbs.amap.com/console/show/picker">高德地图坐标获取</a></li>
<li>2、输入<strong>墨脱县</strong>，定位成功后可以看到经纬度为 <strong>95.332241,29.325734</strong></li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13427b36db0f46009e1545b37e7340c5~tplv-k3u1fbpfcp-zoom-1.image" alt="A2"></p>
<h3 id="3、新建工程"><a href="#3、新建工程" class="headerlink" title="3、新建工程"></a>3、新建工程</h3><ul>
<li>1、打开电脑上的工具<strong>Xcode</strong>，如果没有去<strong>App Store</strong>上下载一个，新建一个工程，命名为<strong>LocationDemo</strong></li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d185c29b3f9b4152a4cb5db699f217ba~tplv-k3u1fbpfcp-zoom-1.image" alt="A3"></p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4885db0d62d34be2a2764b564dfac79d~tplv-k3u1fbpfcp-zoom-1.image" alt="A4"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b661c8b1ef245868cacd7cbe48d3953~tplv-k3u1fbpfcp-zoom-1.image" alt="A5"></p>
<ul>
<li>2、新建工程完成后，工程整体结构如下图，</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78d99e102a324a09a1f890409db7e68c~tplv-k3u1fbpfcp-zoom-1.image" alt="A6"></p>
<ul>
<li>3、新建一个GPX文件，右键点击LocationDemo文件夹，选择<strong>New File –&gt; 搜索gpx –&gt; 选择默认命名“Location”</strong></li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5918e65009c478998d6ba8f11e0389e~tplv-k3u1fbpfcp-zoom-1.image" alt="A7"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e4d0442fb964850bbde8bf6b86615b7~tplv-k3u1fbpfcp-zoom-1.image" alt="A8"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a332512294c476f871fd7a50c46f16a~tplv-k3u1fbpfcp-zoom-1.image" alt="A9"></p>
<ul>
<li>4、打开<strong>Location.gpx文件，修改前面搜到的经纬度</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;gpx version&#x3D;&quot;1.1&quot; creator&#x3D;&quot;Xcode&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;wpt lat&#x3D;&quot;29.325734&quot; lon&#x3D;&quot;95.332241&quot;&gt;</span><br><span class="line">        &lt;name&gt;Cupertino&lt;&#x2F;name&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;time&gt;2014-09-24T14:55:37Z&lt;&#x2F;time&gt;</span><br><span class="line">    &lt;&#x2F;wpt&gt;</span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;gpx&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4、开始模拟定位"><a href="#4、开始模拟定位" class="headerlink" title="4、开始模拟定位"></a>4、开始模拟定位</h3><p>插上数据线把手机连接电脑，连接成功后，在Xcode上选择连接的手机。</p>
<ul>
<li>1、同时摁住 Command + R 键盘在手机上运行工程，看到<strong>Build Succeeded</strong>提示后表示运行成功。</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79e65ffa0d994a5599bedb8218fac7b9~tplv-k3u1fbpfcp-zoom-1.image" alt="A10"></p>
<p>运行成功后，发现手机桌面上多了一个名为<strong>LocationDemo</strong>的App,打开就一个白色界面什么都没有，</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f9a09b084a440bcb335edfc6fa19258~tplv-k3u1fbpfcp-zoom-1.image" alt="A11"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a7a74edf5784bff9c93189783638e20~tplv-k3u1fbpfcp-zoom-1.image" alt="A12"></p>
<ul>
<li>2、模拟定位</li>
</ul>
<p>选择<strong>Debug –&gt; Simulate Location –&gt; Location</strong></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd0c297c9cb54add858bac1b8b6a3883~tplv-k3u1fbpfcp-zoom-1.image" alt="A13"></p>
<p>打开手机上的地图，此时如果定位是<strong>墨脱县</strong>说明模拟定位成功了，如果没有请按前面的教程再仔细的走一遍。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e941e06646ae43e29707b549395f5ef5~tplv-k3u1fbpfcp-zoom-1.image" alt="A14"></p>
<p>既然定位成功了,那就继续下一步：</p>
<ul>
<li>3、修改战区</li>
</ul>
<p>前面已经说了，玩家可以在每周一6点之后当天第一次上线时通过模拟定位的方式修改战区，所以我们可在周一时通过上述方法把战区修改到荣耀战力较低的地方。我们已经成功模拟了位置，打开王者荣耀修改战区即可。此处要注意，要保持上面所建的工程在运行的状态下打开王者荣耀，不能断开手机和电脑连接，不能关闭LocationDemo App。修改战区方法如下：<br> （1）、进入游戏后点击排位赛<br> （2）、点击荣耀战区<br> （3）、点击右上角齿轮按钮<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2782080942dd41d18c9de59092acded3~tplv-k3u1fbpfcp-zoom-1.image" alt="A15"><br>（4）、退出查询修改后的战区情况</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca8f4e5b3d2c44c081bef328d79d1acf~tplv-k3u1fbpfcp-zoom-1.image" alt="A16"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd5a3e061d2042018a7f7b7b0039572f~tplv-k3u1fbpfcp-zoom-1.image" alt="A17"></p>
<p>完成这一切，只用等下周就可以看到切换后战区牌子了，就这样，希望能帮到你。</p>
]]></content>
  </entry>
  <entry>
    <title>基于MVVM构建聊天App（四）构建自己的开源库</title>
    <url>/2021/01/05/%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E5%BA%93/</url>
    <content><![CDATA[<p>坦白来说我们所使用的任何一个功能在github等一些开源网站上都能找到示例代码或相关开源库，我个人认为在使用一个开源代码加入到自己的工程之前应该慎重：</p>
<ul>
<li>有些开源项目的由于各种原因最终作者不再维护，出现bug了我们只能自己维护或者寻找新的替代库；</li>
<li>我们的需求和开源库有区别，即使使用了开源代码也需要在其基础上再次修改；</li>
<li>iOS 系统升级后，一些开源库的作者不能及时发布新的兼容版本，可能会导致出现兼容问题；</li>
<li>考虑到工程包的问题，虽然苹果已将非Wi-Fi下载APP的大小升至150M，但在工程中大量引入第三方库，必然也会导致APP包比预期要大；</li>
</ul>
<p>在工程中部分功能，如LoadingView，网络请求，JSON转Model等，虽然有很多开源库，但我还是建议尽量使用系统的方法，或者封装一个组件并将其开源。这样既可以避免上面的几个问题，同时如果开发新项目了也可以更方便的集成到新项目中。</p>
<p>一般来说，构建一个开源库应该做以下几步操作：</p>
<ul>
<li>编写开源代码</li>
<li>测试和修改</li>
<li>发布到开源平台，如Github等</li>
<li>后期维护，包括及时升级，修改bug,处理<strong>Issues和Pull requests</strong>等</li>
</ul>
<h3>1、创建工程编写代码</h3>

<p>1、登录GitHub,新建一个仓库，命名为<code>RPBannerView-Swift</code>,此处我选的是MIT开源协议。</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/A1.png?raw=true" alt="A1"></p>
<p>2、在本地新建一个<code>RPBannerView-Swift</code>文件夹,并将刚创建的代码clone到该文件中</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/A2.png?raw=true" alt="A2"></p>
<p>3、在该文件夹中新建一个工程，命名为<code>RPBannerView-Swift</code>,完成后上传代码到<code>GitHub</code>上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Desktop&#x2F;RPBannerView-Swift&#x2F;</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;dengfeng520&#x2F;RPBannerView-Swift.git</span><br><span class="line">git add .&#x2F;</span><br><span class="line">git commit -a -m &quot;上传代码&quot;</span><br><span class="line">git push origin master</span><br><span class="line">git ll &#x2F;&#x2F; 查看上传记录</span><br></pre></td></tr></table></figure>
<p>4、iOS 版本兼容</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/A3.png?raw=true" alt="A3"></p>
<p>打开<code>RPBannerView-Swift</code>工程，修改最低支持版本为iOS 11，此时build工程，会报错。在<code>AppDelegate</code>和<code>SceneDelegate</code>做兼容处理即可。</p>
<ul>
<li>in AppDelegate.swift</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@available(iOS 13.0, *)</span><br><span class="line">extension AppDelegate &#123;</span><br><span class="line">    &#x2F;&#x2F; MARK: UISceneSession Lifecycle</span><br><span class="line">    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -&gt; UISceneConfiguration &#123;</span><br><span class="line">        &#x2F;&#x2F; Called when a new scene session is being created.</span><br><span class="line">        &#x2F;&#x2F; Use this method to select a configuration to create the new scene with.</span><br><span class="line">        return UISceneConfiguration(name: &quot;Default Configuration&quot;, sessionRole: connectingSceneSession.role)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set&lt;UISceneSession&gt;) &#123;</span><br><span class="line">        &#x2F;&#x2F; Called when the user discards a scene session.</span><br><span class="line">        &#x2F;&#x2F; If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.</span><br><span class="line">        &#x2F;&#x2F; Use this method to release any resources that were specific to the discarded scenes, as they will not return.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>in SceneDelegate.Swift</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@available(iOS 13.0, *)</span><br><span class="line">class SceneDelegate: UIResponder, UIWindowSceneDelegate &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3> 2、发布到Carthage </h3>

<ul>
<li>1、新建framework</li>
</ul>
<p>编译工程成功后新建一个<code>framework </code>,命名为<code>RPBannerView</code>,</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/A4.png?raw=true" alt="A4"></p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/A5.png?raw=true" alt="A5"></p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/A6.png?raw=true" alt="A6"></p>
<ul>
<li><p>2、完成后修改<code>RPBannerView.framework</code>的最低版本为iOS 11，</p>
<p>选中新建的<code>RPBannerView.framework</code> –&gt; <code>Build Settings</code> –&gt; <code>iOS deployment Target</code> –&gt; <code>iOS 11</code></p>
</li>
</ul>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/A7.png?raw=true" alt="A7"></p>
<ul>
<li><p>3、添加<code>RPBannerView.framework</code>要编译的文件，</p>
<p>  选中<code>RPBannerView.framework</code> –&gt; <code>Build Phases</code><br>  把需要编译的文件导入即可。</p>
</li>
</ul>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/A8.png?raw=true" alt="A8"></p>
<ul>
<li>4、新建Xcode schemes</li>
</ul>
<p>选择 Manager Schemes –&gt; 勾选shared</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/A9.png?raw=true" alt="A9"></p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/A10.png?raw=true" alt="A10"></p>
<ul>
<li>5、编译FrameWork</li>
</ul>
<p>切换到<code>RPBannerView.framework</code>,<strong>此处要注意，不要选择模拟器！！</strong></p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/A11.png?raw=true" alt="A11"></p>
<p>在Terminal中cd到工程文件，执行build命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Desktop&#x2F;RPBannerView-Swift&#x2F;</span><br><span class="line">carthage build --no-skip-current</span><br></pre></td></tr></table></figure>
<p>一般情况下第一次build可能会报错，目前不知道是什么原因造成的。</p>
<p><code>Skipped building RPBannerView-Swift due to the error: Dependency &quot;RPBannerView-Swift&quot; has no shared framework schemes</code></p>
<p>解决报错方法：打开<strong>Manage Schemes</strong>，取消勾选<strong>RPBannerView</strong>,点击Close,然后再次打开重新勾选即可。<br>重新build成功。</p>
<p><code>Building scheme &quot;RPBannerView&quot; in RPBannerView-Swift.xcodeproj</code></p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/A13.png?raw=true" alt="A13"></p>
<p>编译成功后打开工程文件可以看到多了一个<code>Carthage</code>文件，逐步点开：<code>Carthage</code> –&gt; <code>Build</code> –&gt; <code>iOS</code> –&gt; <code>RPBannerView.framework</code>是编译成功后的文件。</p>
<ul>
<li>6、上传<code>RPBannerView-FrameWork</code>到GitHub</li>
</ul>
<p>编译成功后需要把代码上传到GitHub并开源才可以让其他人通过<code>Carthage</code>来使用这个开源库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Desktop&#x2F;RPBannerView-Swift&#x2F;</span><br><span class="line">git add .&#x2F;</span><br><span class="line">git commit -a -m &quot;update code&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<ul>
<li>7、创建tag</li>
</ul>
<p>在上传到GitHub后需要创建一个tag，以此来确定这个库的版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Desktop&#x2F;RPBannerView-Swift&#x2F;</span><br><span class="line">git tag 1.0</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>
<ul>
<li>8、验证是否成功</li>
</ul>
<p>新建一个工程，命名为<code>RPBannerViewDemo</code>,在<code>Cartfile</code>文件中导入上传的库，然后更新carthage，如果成功说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd RPBannerViewDemo</span><br><span class="line">touch Cartfile</span><br><span class="line">Vim Cartfile</span><br><span class="line">github &quot;dengfeng520&#x2F;RPBannerView-Swift&quot;</span><br><span class="line">Esc -&gt; :wq</span><br><span class="line">carthage update --platform iOS --no-use-binaries</span><br></pre></td></tr></table></figure>
<p><code>--platform</code> iOS是指定平台默认是全平台架构的，<code>--no-use-binaries</code>是不用预编译的二进制，用源码重新编译二进制，如果不指定，网络不好的情况下会报错。</p>
<p>如果工程中已经使用了<code>Carthage</code>,只需要更新<code>RPBannerView-Swift</code>即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">carthage update RPBannerView-Swift --platform iOS</span><br></pre></td></tr></table></figure>
<p>更新完成后,打开工程，选择TARGETS –&gt;Build Phases–&gt; Link Binary With Libries 点击加号，选择 Add File –&gt; Carthage –&gt; Build –&gt; iOS 添加RPBannerView.FrameWork.</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/A14.png?raw=true" alt="A14"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;Carthage copy-frameworks</span><br></pre></td></tr></table></figure>
<p>接下来，点击+，选择New Run Script Phase，此时新建了Run Script,在执行命令中添加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(SRCROOT)&#x2F;Carthage&#x2F;Build&#x2F;iOS&#x2F;RPBannerView.framework</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/A15.png?raw=true" alt="A15"></p>
<p>然后就可以在工程中愉快的使用自己的开源库了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import RPBannerView</span><br><span class="line"></span><br><span class="line">RPBanner.showBanner(BannerDisplay(title: &quot;test loading...&quot; ,backColor: UIColor.red, addView: view))</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/A16.png?raw=true" alt="A16"></p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/A17.png?raw=true" alt="A17"></p>
<h3> 3、发布到CocoaPods </h3>

<ul>
<li>1、创建RPBannerView-Swift.podspec</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Desktop&#x2F;RPBannerView-Swift&#x2F;</span><br><span class="line">pod spec create RPBannerView-Swift</span><br><span class="line">vim RPBannerView-Swift.podspec</span><br></pre></td></tr></table></figure>
<ul>
<li>2、编辑RPBannerView-Swift.podspec</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pod::Spec.new do |spec|</span><br><span class="line">spec.name         &#x3D; &quot;RPBannerView-Swift&quot;</span><br><span class="line">spec.version      &#x3D; &quot;1.0&quot;</span><br><span class="line">spec.summary      &#x3D; &quot;A short description of RPBannerView.&quot;</span><br><span class="line">spec.description  &#x3D; &quot;RPBannerView-Swift&quot;</span><br><span class="line">spec.homepage     &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;dengfeng520&#x2F;RPBannerView-Swift&quot;</span><br><span class="line">spec.license      &#x3D; &#123; :type &#x3D;&gt; &quot;MIT&quot;, :file &#x3D;&gt; &quot;LICENSE&quot; &#125;</span><br><span class="line">spec.author             &#x3D; &#123; &quot;dengfeng520&quot; &#x3D;&gt; &quot;deng_feng520@163.com&quot; &#125;</span><br><span class="line">spec.platform     &#x3D; :ios</span><br><span class="line">spec.ios.deployment_target &#x3D; &quot;11.0&quot;</span><br><span class="line">spec.source       &#x3D; &#123; :git &#x3D;&gt; &quot;https:&#x2F;&#x2F;github.com&#x2F;dengfeng520&#x2F;RPBannerView-Swift&quot;, :tag &#x3D;&gt; &quot;#&#123;spec.version&#125;&quot; &#125;</span><br><span class="line">spec.source_files  &#x3D; &quot;RPBannerView-Swift&#x2F;RPBannerView&#x2F;*.swift&quot;</span><br><span class="line">spec.framework  &#x3D; &quot;Foundation&quot;, &quot;UIKit&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ul>
<li>3、保存podspec文件，然后验证</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod spec lint RPBannerView-Swift.podspec --allow-warnings</span><br></pre></td></tr></table></figure>
<p>验证成功提交到CocoaPods/Specs代码库中，让其他人也可以通过<code>pod install</code>命令安装开源库。</p>
<p>验证成功提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RPBannerView-Swift.podspec passed validation. </span><br></pre></td></tr></table></figure>
<p>如果没有注册CocoaPods帐号，可以通过以下命令注册CocoaPods帐号，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod trunk register deng_feng520@163.com &#39;dengfeng520&#39; --description&#x3D;&#39;dengfeng520&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看CocoaPods帐号信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod trunk me</span><br></pre></td></tr></table></figure>
<ul>
<li>4、发布到CocoaPods</li>
</ul>
<p>如果已经注册了，直接发布到CocoaPods服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod trunk push RPBannerView-Swift.podspec --allow-warnings</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/B1.png?raw=true" alt="B1"></p>
<p>发布成功后更新CocoaPods本地库:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod setup</span><br></pre></td></tr></table></figure>
<p>然后搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod search RPBannerView-Swift</span><br></pre></td></tr></table></figure>
<ul>
<li>5、在项目中验证是否可以使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd RPBannerViewDemo</span><br><span class="line">pod init</span><br><span class="line">Vim Podfile</span><br><span class="line">pod &#39;RPBannerView-Swift&#39;, :git &#x3D;&gt; &#39;https:&#x2F;&#x2F;github.com&#x2F;dengfeng520&#x2F;RPBannerView-Swift&#39;</span><br><span class="line">Esc -&gt; :wq</span><br><span class="line">pod install</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>pod 下载成功后，即可在项目中使用这个库。</p>
<h3> 4、编写README.md文件 </h3>

<p>如图所示一般一个开源的README.md由三部分组成：</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/RPBanner.png?raw=true" alt="README.md结构"></p>
<ul>
<li>（1）、顶部的Banner</li>
</ul>
<p>此处借鉴其他开源项目添加一张Logo图片和项目名称就可以，让图片和文字全部居中即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div align&#x3D;center&gt;</span><br><span class="line"> &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;dengfeng520&#x2F;RPBannerView-Swift&#x2F;blob&#x2F;master&#x2F;Banner.png?raw&#x3D;true&quot; width &#x3D; 314 height &#x3D; 200&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;h2 align&#x3D;&quot;center&quot;&gt;RPBannerView&lt;&#x2F;h2&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>（2）、 添加的Badge</p>
<ul>
<li>关于这个库的一些标签</li>
<li>代码测试覆盖率</li>
</ul>
<p>标签的设置可参考博客： <a href="http://www.cocoachina.com/articles/19256">GitHub 项目徽章的添加和设置</a></p>
</li>
</ul>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/Issues.png?raw=true" alt="Issues"></p>
<p>  代码覆盖率是一个开源项目代码质量的重要指标，对于同样功能的开源代码人们一般会优先选择覆盖率高的代码。此处推荐使用 <a href="https://codecov.io/">codecov</a>的在线服务生成代码测试的覆盖率的Badge。</p>
<ul>
<li>（3）、项目说明</li>
</ul>
<p>对于说明部分，应该解决的问题让别人在最短的时间内选择你的使用你的代码，一般来说首先要快速的解决开发者的疑惑。<br>这是什么样的库？相对其他同类库有哪些优点？如何快速上手？</p>
<p>在后面我们也可以加上一些其他内容，如版本发布历史，项目改善计划，详细使用攻略等。</p>
<h3> 5、后期的维护 </h3>

<p>把自己的代码发布到Github上之后，我们还应该经常维护,如及时修改bug，版本更新，经常关注Issues和Pull requests，解决未发现的问题和bug等。</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/RPChat/Images/Issues.png?raw=true" alt="Issues"></p>
<hr>
<p>相关链接： <a href="https://github.com/dengfeng520/RPBannerView-Swift">Github RPBannerView-Swift</a></p>
]]></content>
  </entry>
  <entry>
    <title>基于MVVM构建聊天App （三）网络请求封装</title>
    <url>/2021/01/05/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<h6 align='right'>小时光</h6>
本文主要处理2个问题：

<ul>
<li>请求Loading扩展处理</li>
<li>封装URLSession返回Observable序列</li>
</ul>
<blockquote>
<h3>1、请求Loading扩展处理</h3>
</blockquote>
<p>关于Loading组件，我已经封装好，并发布在Github上，<a href="https://github.com/dengfeng520/RPToastView">RPToastView</a>，使用方法可参考<strong>README.md</strong>。<br>此处只需对UIViewController做一个extension，用一个属性来控制Loading组件的显示和隐藏即可，核心代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Reactive where Base: UIViewController &#123;</span><br><span class="line">    public var isAnimating: Binder&lt;Bool&gt; &#123;</span><br><span class="line">        return Binder(self.base, binding: &#123; (vc, active) in</span><br><span class="line">            if active &#x3D;&#x3D; true &#123;</span><br><span class="line">                &#x2F;&#x2F; 显示Loading View</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 隐藏Loading View</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处给<strong>isAnimating</strong>传入<strong>true</strong>表示显示<strong>LoadingView</strong>,传入<strong>false</strong>表示隐藏<strong>LoadingView</strong>，</p>
<blockquote>
<h3>2、为什么不使用Moya</h3>
</blockquote>
<p><a href="https://github.com/Moya/Moya">Github Moya</a></p>
<p><strong>Moya</strong>是在常用的<strong>Alamofire</strong>的基础上又封装了一层，但是我在工程中并没有使用<strong>Moya</strong>,主要是基于以下3点考虑：</p>
<ul>
<li>（1）、<strong>Moya</strong>自身原因：<strong>Moya</strong>封装的很完美，这虽然为开发者带来了很大的方便，但是过多封装的必然会导致可扩展性下降</li>
<li>（2）、内部原因：由于我公司的后台接口没有一个统一的标准，所以不同模块后台返回的数据结构不同，所以我不得不分开处理</li>
<li>（3）、基于App包大小考虑：导入过多的第三方开源库必然会使App包也同步变大，这并不是我所期望的</li>
<li>（4）、和RxSwift兼容问题，如RxSwift已经升级到6.0版本了，Moya却只支持5.*版本</li>
</ul>
<p>所以我最终的选择是<strong>RxSwift+URLSession+SwiftyJSON</strong>。</p>
<blockquote>
<h3>3、RxSwift的使用</h3>
</blockquote>
<p>关于网络请求，OC中常用的开源库是<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>,在Swift中我们常用<a href="https://github.com/Alamofire/Alamofire">Alamofire</a>。截止2020年12月<strong>AFNetworking</strong>的star数量是<strong>33.1K</strong>,<strong>Alamofire</strong>的star数量是<strong>35K</strong>。从这个数据来说，Swift虽然是一门新的语言，但更受开发者青睐。</p>
<p>网络请求最简单的方法个人觉得用 <strong>Alamofire</strong>通过<strong>Closures</strong>返回是否成功或失败:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func post(with body: [String : AnyObject], _ path: String, with closures: @escaping ((_ json: [String : AnyObject],_ failure : String?) -&gt; Void))</span><br></pre></td></tr></table></figure>
<p>如果我们在用户登录成功后需要再调一次接口查询该用户<strong>Socket</strong>服务器相关数据，那么请求的代码就会<strong>Closures</strong>里嵌套<strong>Closures</strong>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> RPAuthRemoteAPI().signIn(with: [&quot;username&quot;:&quot;&quot;,&quot;password&quot;:&quot;&quot;], signInAPI) &#123; (siginInfo, errorMsg) in</span><br><span class="line">   if let errorMsg &#x3D; errorMsg &#123;</span><br><span class="line">                </span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       RPAuthRemoteAPI().socketInfo(with: [&quot;username&quot;:&quot;&quot;], userInfoAPI) &#123; (userInfo, userInfoErrorMsg) in</span><br><span class="line">          if let userInfoErrorMsg &#x3D; userInfoErrorMsg &#123;</span><br><span class="line">                        </span><br><span class="line">          &#125; else &#123;</span><br><span class="line">                        </span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用RxSwift可以将多个请求合并处理，参考<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/why_rxswift.html">RxSwift:等待多个并发任务完成后处理结果</a></p>
<ul>
<li>1、更直观简洁的RxSwift</li>
</ul>
<p>同时，使用RxSwift，返回一个<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core.html">Observable</a>,还可以避免嵌套回调的问题。</p>
<p>上面的代码用RxSwift来写，就更符合逻辑了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let _ &#x3D; RPAuthRemoteAPI().signIn(with: [&quot;username&quot;:&quot;&quot;,&quot;password&quot;:&quot;&quot;], signInAPI)</span><br><span class="line">            .flatMap(&#123; (returnJson) in</span><br><span class="line">     return RPAuthRemoteAPI().userInfo(with: [&quot;username&quot;:&quot;&quot;], userInfoAPI)</span><br><span class="line">&#125;).subscribe &#123; (json) in</span><br><span class="line">     print(&quot;用户信息-----------: \(json)&quot;)</span><br><span class="line">&#125; onError: &#123; (error) in</span><br><span class="line"></span><br><span class="line">&#125; onCompleted: &#123;</span><br><span class="line"></span><br><span class="line">&#125; onDisposed: &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、处理服务器返回的数据</li>
</ul>
<p>一般一个请求无非是三种情况：</p>
<ul>
<li><p>请求成功时服务器返回的数据结构</p>
</li>
<li><p>请求服务器成功，但返回数据异常，如参数错误，加密处理异常，登录超时等</p>
</li>
<li><p>请求没有成功，根据返回的错误码做处理</p>
<p>创建一个协议来管理请求，此处需要知道请求的API，HTTP方式，所需参数等，代码如下：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 请求服务器相关</span><br><span class="line">public protocol Request &#123;</span><br><span class="line">    var path: String &#123;get&#125;</span><br><span class="line">    var method: HTTPMethod &#123;get&#125;</span><br><span class="line">    var parameter: [String: AnyObject]? &#123;get&#125;</span><br><span class="line">    var host: String &#123;get&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在发起一个请求时可能不需要任何参数，此处做一个<strong>extension</strong>处理将<strong>parameter</strong>作为可选参数即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Request &#123;</span><br><span class="line">    var parameter: [String: AnyObject] &#123;</span><br><span class="line">        return [:]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处要分别对以上三种情况做出处理，首先来看看服务器给的接口文档，请求成功时服务器返回的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;access_token&quot; : &quot;b6298027-a985-441c-a36c-d0a362520896&quot;,</span><br><span class="line">  &quot;user_id&quot; : &quot;1268805326995996673&quot;,</span><br><span class="line">  &quot;dept_id&quot; : 1,</span><br><span class="line">  &quot;license&quot; : &quot;made by tsn&quot;,</span><br><span class="line">  &quot;scope&quot; : &quot;server&quot;,</span><br><span class="line">  &quot;token_type&quot; : &quot;bearer&quot;,</span><br><span class="line">  &quot;username&quot; : &quot;198031&quot;,</span><br><span class="line">  &quot;expires_in&quot; : 19432,</span><br><span class="line">  &quot;refresh_token&quot; : &quot;692a1b6e-051f-424d-bd2e-3a9ccec8d4f2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求成功，但出现异常时返回的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;returnCode&quot; : &quot;601&quot;,</span><br><span class="line">  &quot;returnMsg&quot; : &quot;登录失效&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建一个<strong>SignInModel.Swift</strong>来作为模型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public struct SignInModel &#123;</span><br><span class="line">    public let username,dept_id,access_token,token_type,user_id,scope,refresh_token,expires_in,license: String   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将返回的<strong>SwiftyJSON</strong>对象转为Model对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension SignInModel &#123;</span><br><span class="line">    public init?(json: JSON) &#123;</span><br><span class="line">        username &#x3D; json[&quot;username&quot;].stringValue</span><br><span class="line">        dept_id &#x3D; json[&quot;dept_id&quot;].stringValue</span><br><span class="line">        access_token &#x3D; json[&quot;access_token&quot;].stringValue</span><br><span class="line">        token_type &#x3D; json[&quot;token_type&quot;].stringValue</span><br><span class="line">        user_id &#x3D; json[&quot;user_id&quot;].stringValue</span><br><span class="line">        scope &#x3D; json[&quot;scope&quot;].stringValue</span><br><span class="line">        refresh_token &#x3D; json[&quot;refresh_token&quot;].stringValue</span><br><span class="line">        expires_in &#x3D; json[&quot;expires_in&quot;].stringValue</span><br><span class="line">        license &#x3D; json[&quot;license&quot;].stringValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当请求成功后，将服务器获取的Data数据转成SwiftyJSON实例，然后在ViewModel中转成SignInModel。</p>
<p>对于请求成功时，但返回数据异常时，可根据后台返回的code码和message信息，给用户一个友好提示。</p>
<p>对于请求服务器失败时情况，可以定义一个<strong>enum</strong>来处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 请求服务器失败时 错误码</span><br><span class="line">public enum RequestError: Error &#123;</span><br><span class="line">   case unknownError</span><br><span class="line">   case connectionError</span><br><span class="line">   case timeoutError</span><br><span class="line">   case authorizationError(JSON)</span><br><span class="line">   case notFound</span><br><span class="line">   case serverError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h3>4、发起请求并返回一个Observable对象</h3>
</blockquote>
<p><code>RxSwift</code>对系统提供的<code>URLSession</code>也做了扩展，可以让开发者直接使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URLSession.shared.rx.response(request: urlRequest).subscribe(onNext: &#123; (response, data) in</span><br><span class="line">            </span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>首先定一个可以发送请求的协议, 无论请求成功还是失败都需要返回一个<strong>Observable队列</strong>，此处使用了一个**&lt;T: Request&gt;<strong>泛型，任何一个遵循</strong>AuthRemoteProtocol**的类型都可以实现网络请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public protocol AuthRemoteProtocol &#123;</span><br><span class="line">  func post&lt;T: Request&gt;(_ r: T) -&gt; Observable&lt;JSON&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当发起一个请求时，我们需要对<strong>URLSession</strong>做一些请求配置，如设置<strong>header、body、url、timeout、请求方式等</strong>，才能顺利的完成一个请求。<strong>header、timeout</strong>这几个参数一般都固定的。而<strong>body、url</strong>这两个参数必须是一个遵循<strong>Request</strong>协议的对象。核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func post&lt;T: Request&gt;(_ r: T) -&gt; Observable&lt;JSON&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置请求API</span><br><span class="line">    guard let path &#x3D; URL(string: r.host.appending(r.path)) else &#123;         </span><br><span class="line">        return .error(RequestError.unknownError)</span><br><span class="line">    &#125;</span><br><span class="line">    var headers: [String : String]?</span><br><span class="line">    &#x2F;&#x2F; 设置超时时间</span><br><span class="line">    var urlRequest &#x3D; URLRequest(url: path, cachePolicy: .useProtocolCachePolicy, timeoutInterval: 30)</span><br><span class="line">    &#x2F;&#x2F; 设置header</span><br><span class="line">    urlRequest.allHTTPHeaderFields &#x3D; headers</span><br><span class="line">    &#x2F;&#x2F; 设置请求方式</span><br><span class="line">    urlRequest.httpMethod &#x3D; r.method.rawValue</span><br><span class="line">    return Observable.create &#123; (observer) -&gt; Disposable in</span><br><span class="line">       URLSession.shared.dataTask(with: urlRequest) &#123; (data, response, error) in</span><br><span class="line">          &#x2F;&#x2F; 根据服务器返回的code处理并传递给ViewModel </span><br><span class="line">       &#125;.resume()</span><br><span class="line">       return Disposables.create &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般跟服务器约定，当服务器返回的<strong>code</strong>为200时我们认为服务器请求成功并正常返回数据，当返回其他<strong>code</strong><br>时根据返回的<strong>code</strong>做出处理。最终的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 登录Request</span><br><span class="line">struct SigninRequest: Request &#123;</span><br><span class="line">    typealias Response &#x3D; SigninRequest</span><br><span class="line">    var parameter: [String : AnyObject]?</span><br><span class="line">    var path: String</span><br><span class="line">    var method: HTTPMethod &#x3D; .post</span><br><span class="line">    var host: String &#123;</span><br><span class="line">        return __serverTestURL</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public enum RequestError: Error &#123;</span><br><span class="line">   case unknownError</span><br><span class="line">   case connectionError</span><br><span class="line">   case timeoutError</span><br><span class="line">   case authorizationError(JSON)</span><br><span class="line">   case notFound</span><br><span class="line">   case serverError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public protocol AuthRemoteProtocol &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 协议方式，成功返回JSON -----&gt; RxSwift</span><br><span class="line">    func requestData&lt;T: Request&gt;(_ r: T) -&gt; Observable&lt;JSON&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public struct RPAuthRemoteAPI: AuthRemoteProtocol &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 协议方式，成功返回JSON -----&gt; RxSwift</span><br><span class="line">    public func post&lt;T: Request&gt;(_ r: T) -&gt; Observable&lt;JSON&gt; &#123;</span><br><span class="line">        let path &#x3D; URL(string: r.host.appending(r.path))!</span><br><span class="line">        var urlRequest &#x3D; URLRequest(url: path, cachePolicy: .useProtocolCachePolicy, timeoutInterval: 30)</span><br><span class="line">        urlRequest.allHTTPHeaderFields  &#x3D; [&quot;Content-Type&quot; : &quot;application&#x2F;x-www-form-urlencoded; application&#x2F;json; charset&#x3D;utf-8;&quot;]</span><br><span class="line">        urlRequest.httpMethod &#x3D; r.method.rawValue</span><br><span class="line">        if let parameter &#x3D; r.parameter &#123;</span><br><span class="line">            &#x2F;&#x2F; --&gt; Data</span><br><span class="line">            let parameterData &#x3D; parameter.reduce(&quot;&quot;) &#123; (result, param) -&gt; String in</span><br><span class="line">                return result + &quot;&amp;\(param.key)&#x3D;\(param.value as! String)&quot;</span><br><span class="line">            &#125;.data(using: .utf8)</span><br><span class="line">            urlRequest.httpBody &#x3D; parameterData</span><br><span class="line">        &#125;</span><br><span class="line">     return Observable.create &#123; (observer) -&gt; Disposable in</span><br><span class="line">            URLSession.shared.dataTask(with: urlRequest) &#123; (data, response, error) in</span><br><span class="line">                if let error &#x3D; error &#123;</span><br><span class="line">                    print(error)</span><br><span class="line">                    observer.onError(RequestError.connectionError)</span><br><span class="line">                &#125; else if let data &#x3D; data ,let responseCode &#x3D; response as? HTTPURLResponse &#123;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        let json &#x3D; try JSON(data: data)</span><br><span class="line">                        switch responseCode.statusCode &#123;</span><br><span class="line">                        case 200:</span><br><span class="line">                            print(&quot;json-------------\(json)&quot;)</span><br><span class="line">                            observer.onNext(json)</span><br><span class="line">                            observer.onCompleted()</span><br><span class="line">                            break</span><br><span class="line">                        case 201...299:</span><br><span class="line">                            observer.onError(RequestError.authorizationError(json))</span><br><span class="line">                            break</span><br><span class="line">                        case 400...499:</span><br><span class="line">                            observer.onError(RequestError.authorizationError(json))</span><br><span class="line">                            break</span><br><span class="line">                        case 500...599:</span><br><span class="line">                            observer.onError(RequestError.serverError)</span><br><span class="line">                            break</span><br><span class="line">                        case 600...699:</span><br><span class="line">                            observer.onError(RequestError.authorizationError(json))</span><br><span class="line">                            break</span><br><span class="line">                        default:</span><br><span class="line">                            observer.onError(RequestError.unknownError)</span><br><span class="line">                            break</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    catch let parseJSONError &#123;</span><br><span class="line">                        observer.onError(parseJSONError)</span><br><span class="line">                        print(&quot;error on parsing request to JSON : \(parseJSONError)&quot;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.resume()</span><br><span class="line">            return Disposables.create &#123; &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ViewModel中调用，并根据服务器返回的code做处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 显示LoadingView</span><br><span class="line">self.loading.onNext(true)</span><br><span class="line">RPAuthRemoteAPI().post(SigninRequest(parameter: [:], path: path))</span><br><span class="line"> .subscribe(onNext: &#123; returnJson in</span><br><span class="line">  &#x2F;&#x2F; JSON对象转成Model，同时本地缓存Token</span><br><span class="line">    self.loading.onNext(true)</span><br><span class="line"> &#125;, onError: &#123; errorJson in</span><br><span class="line">  &#x2F;&#x2F; 失败</span><br><span class="line">  self.loading.onNext(true)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">  &#x2F;&#x2F; 调用完成时</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<h3>5、存在问题</h3>
</blockquote>
<p>虽然以上的方法基于POP的实现，利于代码的扩展和维护。但是我觉得也存在问题： </p>
<ul>
<li>过分依赖<strong>RxSwift、SwiftyJSON</strong>第三方库，如果说出现系统版本升级，或者这些第三方库的作者不再维护等问题，会给我们后期的开发和维护带来很大的麻烦；</li>
</ul>
<p>–</p>
<p>友情链接：</p>
<p><a href="https://onevcat.com/2016/11/pop-cocoa-1/">面向协议编程与 Cocoa 的邂逅</a></p>
<p><a href="https://github.com/mohammadZ74/MVVMRx_SampleProject">Sample Music list app</a></p>
<p><a href="https://github.com/ReactiveX/RxSwift">Github RxSwift</a></p>
<p><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core.html">RxSwift 中文网</a></p>
<p><a href="https://boxueio.com/">泊学网</a></p>
]]></content>
  </entry>
  <entry>
    <title>iOS AutoLayout 笔记</title>
    <url>/2020/04/28/Autolayout/</url>
    <content><![CDATA[<h6 align='right'>小时光</h6>

<blockquote>
<h3 id="1、What’s-Auto-Layout"><a href="#1、What’s-Auto-Layout" class="headerlink" title="1、What’s Auto Layout"></a>1、What’s Auto Layout</h3></blockquote>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<code>Auto Layout</code>是由苹果公司<code>UIKit</code>框架提供的一个用于动态计算<code>UIView</code>及其子类的大小和位置的库。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;说到<code>Auto Layout</code>就不得不说<code>Cassowary</code>算法，因为<code>Auto Layout</code>是构建在<code>Cassowary</code>算法的基础之上的。1997年，<code>Auto Layout</code>用到的布局算法论文发表，被称为高效的线性方程求解算法。2011年苹果利用<code>Cassowary</code>算法为开发者提供了<code>Auto Layout</code>自动布局库中。由于<code>Cassowary</code>算法的本身的优秀，不仅是苹果公司，许多开发者将其运用到各个不同的开发语言中，如<code>JavaScript、ASP.NET、Java、C++</code>等都有运用<code>Cassowary</code>算法的库。从这里也可以看出<code>Cassowary</code>算法自身的优秀和先进性，不然不会被运用的如此广泛。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;苹果公司在<code>iOS 6</code>系统时引入了<code>Auto Layout</code>，但是直到现在已经更新到<code>iOS 12</code>了，还有很多开发者还是不愿使用<code>Auto Layout</code>。主要是对其反人类的语法以及对其性能问题的担忧。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;针对<code>Auto Layout</code>的一些问题，在<code>iOS 9</code>发布时，苹果推出了更简洁语法的<a href="https://developer.apple.com/documentation/uikit/nslayoutanchor">NSLayoutAnchor</a>。同时发布了模仿前端<a href="https://www.runoob.com/w3cnote/flex-grammar.html">Flexbox</a>布局思路的<a href="https://developer.apple.com/documentation/uikit/uistackview">UIStackView</a>，以此为开发者在自动布局上提供更好的选择。</p>
<p>在苹果<a href="https://developer.apple.com/videos/play/wwdc2018/220">WWDC 2018 High Performance Auto Layout</a>中苹果工程师说: iOS 12将大幅度提升Auto Layout性能，使滑动屏幕时达到满帧。<br>在<a href="https://developer.apple.com/videos/play/wwdc2018/202/">WWDC 2018 What’s New in Cocoa Touch</a>苹果的工程师说了iOS 12对Auto Layout优化后的表现。<br><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a24c8ba66df4a9fb6e7d38fabf2c533~tplv-k3u1fbpfcp-zoom-1.image" alt="WWDC 2018 What&#39;s New in Cocoa Touch"><br>从图上可以看出，<code>iOS 11</code>中视图嵌套的数量的性能快成指数级别增长了，在<code>iOS 12</code>中已经基本和手写frame布局的性能类似了。</p>
<p>从<code>iOS 6</code>到<code>iOS 12</code>，苹果也在不断的优化<code>Auto Layout</code>的性能，同时为开发者提供更简洁的<code>API</code>，如果你还在使用<code>frame</code>手写布局，不妨试试<code>Auto Layout</code>。下面我将介绍<code>iOS</code>中几种常用的布局方法。</p>
<blockquote>
<h3 id="2、Auto-Layout各个版本不同用法"><a href="#2、Auto-Layout各个版本不同用法" class="headerlink" title="2、Auto Layout各个版本不同用法"></a>2、Auto Layout各个版本不同用法</h3></blockquote>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如我要设置一个宽高为120,居中显示的View，效果如下图：<br><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a81951bcc0e40d29af0ab2a38f35db0~tplv-k3u1fbpfcp-zoom-1.image" alt="AutoLayoutdemo3.png"></p>
<h5 id="1、用frame手写布局"><a href="#1、用frame手写布局" class="headerlink" title="1、用frame手写布局"></a>1、用frame手写布局</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIView *centerView &#x3D; [[UIView alloc] init];</span><br><span class="line">centerView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">[self.view addSubview:centerView];</span><br><span class="line">CGFloat width &#x3D; self.view.frame.size.width;</span><br><span class="line">CGFloat height &#x3D; self.view.frame.size.height;</span><br><span class="line">[centerView setFrame:CGRectMake(width &#x2F; 2 - (60), height &#x2F; 2 - (60), 120, 120)];</span><br></pre></td></tr></table></figure>
<h5 id="2、iOS-6提供的NSLayoutConstraint语法添加约束"><a href="#2、iOS-6提供的NSLayoutConstraint语法添加约束" class="headerlink" title="2、iOS 6提供的NSLayoutConstraint语法添加约束"></a>2、iOS 6提供的NSLayoutConstraint语法添加约束</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">centerView.translatesAutoresizingMaskIntoConstraints &#x3D; NO;</span><br><span class="line"> NSLayoutConstraint *consW &#x3D; [NSLayoutConstraint constraintWithItem:centerView</span><br><span class="line">                                                          attribute:NSLayoutAttributeWidth</span><br><span class="line">                                                          relatedBy:NSLayoutRelationEqual</span><br><span class="line">                                                             toItem:self.view</span><br><span class="line">                                                          attribute:NSLayoutAttributeWidth</span><br><span class="line">                                                         multiplier:0</span><br><span class="line">                                                           constant:120.0</span><br><span class="line">                              ];</span><br><span class="line"> NSLayoutConstraint *consH &#x3D; [NSLayoutConstraint constraintWithItem:centerView</span><br><span class="line">                                                          attribute:NSLayoutAttributeHeight</span><br><span class="line">                                                          relatedBy:NSLayoutRelationEqual</span><br><span class="line">                                                             toItem:self.view attribute:NSLayoutAttributeHeight</span><br><span class="line">                                                         multiplier:0</span><br><span class="line">                                                           constant:120.0</span><br><span class="line">                              ];</span><br><span class="line"> NSLayoutConstraint *consX &#x3D; [NSLayoutConstraint constraintWithItem:centerView</span><br><span class="line">                                                          attribute:NSLayoutAttributeCenterX</span><br><span class="line">                                                          relatedBy:NSLayoutRelationEqual</span><br><span class="line">                                                             toItem:self.view</span><br><span class="line">                                                          attribute:NSLayoutAttributeCenterX</span><br><span class="line">                                                         multiplier:1.0</span><br><span class="line">                                                           constant:0.0</span><br><span class="line">                              ];</span><br><span class="line"> NSLayoutConstraint *consY &#x3D; [NSLayoutConstraint constraintWithItem:centerView</span><br><span class="line">                                                          attribute:NSLayoutAttributeCenterY</span><br><span class="line">                                                          relatedBy:NSLayoutRelationEqual</span><br><span class="line">                                                             toItem:self.view</span><br><span class="line">                                                          attribute:NSLayoutAttributeCenterY</span><br><span class="line">                                                         multiplier:1.0</span><br><span class="line">                                                           constant:0.0</span><br><span class="line">                              ];</span><br><span class="line"> [self.view addConstraints:@[consW,consH,consX,consY]];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3、用VFL语法"><a href="#3、用VFL语法" class="headerlink" title="3、用VFL语法"></a>3、用VFL语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">centerView.translatesAutoresizingMaskIntoConstraints &#x3D; NO;</span><br><span class="line">   [self.view addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:[centerView(120)]&quot; options:0 metrics:nil views:views]];</span><br><span class="line">   [self.view addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;[centerView(120)]&quot; options:0 metrics:nil views:views]];</span><br><span class="line">   [self.view addConstraint:[NSLayoutConstraint constraintWithItem:centerView attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterY multiplier:1 constant:0]];</span><br><span class="line">   [self.view addConstraint:[NSLayoutConstraint constraintWithItem:centerView attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterX multiplier:1 constant:0]];</span><br></pre></td></tr></table></figure>
<h5 id="4、使用第三方开源框架Masonry或SnapKit"><a href="#4、使用第三方开源框架Masonry或SnapKit" class="headerlink" title="4、使用第三方开源框架Masonry或SnapKit"></a>4、使用第三方开源框架<a href="https://github.com/SnapKit/Masonry">Masonry</a>或<a href="https://github.com/SnapKit/SnapKit">SnapKit</a></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__weak typeof (self) weakSelf &#x3D; self;</span><br><span class="line">[centerView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.size.mas_equalTo(CGSizeMake(120, 120));</span><br><span class="line">    make.center.equalTo(weakSelf.view);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let centerView:UIView &#x3D; UIView.init()</span><br><span class="line">view.addSubview(centerView)</span><br><span class="line">centerView.backgroundColor &#x3D; UIColor.red</span><br><span class="line">centerView.snp.makeConstraints &#123; (make) in</span><br><span class="line">   make.width.equalTo(120)</span><br><span class="line">   make.height.equalTo(120)</span><br><span class="line">   make.center.equalTo(view)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5、使用iOS-9之后Apple提供的NSLayoutAnchor"><a href="#5、使用iOS-9之后Apple提供的NSLayoutAnchor" class="headerlink" title="5、使用iOS 9之后Apple提供的NSLayoutAnchor"></a>5、使用iOS 9之后Apple提供的<a href="https://developer.apple.com/documentation/uikit/nslayoutanchor">NSLayoutAnchor</a></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let centerView:UIView &#x3D; UIView.init()</span><br><span class="line">view.addSubview(centerView)</span><br><span class="line">centerView.backgroundColor &#x3D; UIColor.red</span><br><span class="line">centerView.translatesAutoresizingMaskIntoConstraints &#x3D; false</span><br><span class="line">centerView.centerXAnchor.constraint(equalTo: view.centerXAnchor, constant: 0).isActive &#x3D; true</span><br><span class="line">centerView.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: 0).isActive &#x3D; true</span><br><span class="line">centerView.widthAnchor.constraint(equalToConstant: 120).isActive &#x3D; true</span><br><span class="line">centerView.heightAnchor.constraint(equalToConstant: 120).isActive &#x3D; true</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;通过上面的代码对比，使用<code>frame</code>手写布局只要几行代码就搞定了，使用<code>NSLayoutConstraint</code>语法和<code>VFL</code>语法是最复杂的，尤其是<code>NSLayoutConstraint</code>语法要用30多行代码才能是想同样的效果，代码行数越多出错的概率也就成正比上升，所以这就是很多开发者不愿使用<code>Auto Layout</code>（或者说不愿意使用系统提供API来实现）的原因之一吧。</p>
<p> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如果你的<code>App</code>要兼容<code>iOS 9</code>以下的各个版本，建议使用<a href="https://github.com/SnapKit/Masonry">Masonry</a>,如果只兼容iOS 9以上的版本，建议使用<a href="https://github.com/SnapKit/SnapKit">SnapKit</a>或者系统提供的<a href="https://developer.apple.com/documentation/uikit/nslayoutconstraint">NSLayoutAnchor</a> API，毕竟<code>Masonry</code>这个库已经2年没有更新了。</p>
<p>在这里我推荐优先使用<code>NSLayoutAnchor</code>，第三方的开源库随时都面临着一些问题：</p>
<ul>
<li><code> iOS</code> 系统版本的更新造成的适配和兼容问题，如果是开源代码要等到苹果发布新版本，代码的作者再做兼容和适配</li>
<li> 代码的作者停止更新这些代码了，这对我们开发者来说就很被动了，我们要么自己修改这些代码，要么选择更新的开源代码</li>
<li> 使用系统库可在打包时可以减少包大小</li>
</ul>
<blockquote>
<h3 id="3、Auto-Layout的生命周期"><a href="#3、Auto-Layout的生命周期" class="headerlink" title="3、Auto Layout的生命周期"></a>3、<code>Auto Layout</code>的生命周期</h3></blockquote>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;前面说到苹果的<code>Auto Layout</code>是基于<code>Cassowary</code>算法的，苹果在此基础上提供了一套<code>Layout Engine</code>引擎，由它来管理页面的布局，来完成创建、更新、销毁等。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;在<code>APP</code>启动后，会开启一个常驻线程来监听约束变化，当约束发生变化后会出发<code>Deffered Layout Pass</code>(延迟布局传递)，在里面做容错处理（如有些视图在更新约束时没有确定或缺失布局申明），完成后进入约束监听变化的状态。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;当下一次刷新视图（如调用<code>layoutIfNeeded()</code>）时，<code>Layout Engine</code>会从上到下调用<code>layoutSubviews()</code>，然后通过<code>Cassowary</code>算法计算各个子视图的大小和位置，算出来后将子视图的<code>frame</code>从<code>layout Engine</code>里拷贝出来，在之后的处理就和手写<code>frame</code>的绘制、渲染的过程一样了。使用<code>Auto Layout</code>和手写<code>frame</code>多的工作就在布局计算上。</p>
<blockquote>
<h3 id="4、NSLayoutAnchor常用属性"><a href="#4、NSLayoutAnchor常用属性" class="headerlink" title="4、NSLayoutAnchor常用属性"></a>4、<code>NSLayoutAnchor</code>常用属性</h3></blockquote>
<ul>
<li>leadingAnchor</li>
<li>trailingAnchor</li>
<li>leftAnchor</li>
<li>rightAnchor</li>
<li>topAnchor</li>
<li>bottomAnchor</li>
<li>widthAnchor</li>
<li>heightAnchor</li>
<li>centerXAnchor</li>
<li>centerYAnchor</li>
<li>firstBaselineAnchor</li>
<li>lastBaselineAnchor</li>
</ul>
<p>对于<code>NSLayoutAnchor</code>的一些常用属性，通过其命名就能看出来其作用，这里不做赘述，如果想了解更多请查阅<a href="https://developer.apple.com/documentation/uikit/nslayoutanchor#//apple_ref/occ/instm/NSLayoutAnchor/constraintEqualToAnchor:constant:">Apple Developer NSLayoutAnchor</a>。</p>
<blockquote>
<h3 id="5、Auto-Layout几个更新约束的方法"><a href="#5、Auto-Layout几个更新约束的方法" class="headerlink" title="5、Auto Layout几个更新约束的方法"></a>5、Auto Layout几个更新约束的方法</h3></blockquote>
<ul>
<li><p><a href="https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout">setNeedsLayout</a>: 告知页面需要更新，但是不会立刻开始更新。执行后会立刻调用<code>layoutSubviews</code>。</p>
</li>
<li><p><a href="https://developer.apple.com/documentation/uikit/uiview/1622507-layoutifneeded">layoutIfNeeded</a>: 告知页面布局立刻更新。所以一般都会和<code>setNeedsLayout</code>一起使用。如果希望立刻生成新的<code>frame</code>需要调用此方法，利用这点一般布局动画可以在更新布局后直接使用这个方法让动画生效。</p>
</li>
<li><p><a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews">layoutSubviews</a>: 更新子<code>View</code>约束</p>
</li>
<li><p> <a href="https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints">setNeedsUpdateConstraints</a>:需要更新约束，但是不会立刻开始</p>
</li>
<li><p> <a href="https://developer.apple.com/documentation/uikit/uiview/1622595-updateconstraintsifneeded">updateConstraintsIfNeeded</a>:立刻更新约束</p>
</li>
<li><p> <a href="https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints">updateConstraints</a>:更新<code>View</code>约束</p>
</li>
</ul>
<blockquote>
<h3 id="6、NSLayoutAnchor使用注意事项"><a href="#6、NSLayoutAnchor使用注意事项" class="headerlink" title="6、NSLayoutAnchor使用注意事项"></a>6、<code>NSLayoutAnchor</code>使用注意事项</h3></blockquote>
<h5 id="1、在使用NSLayoutAnchor为视图添加约束时一定要先把translatesAutoresizingMaskIntoConstraints设置false"><a href="#1、在使用NSLayoutAnchor为视图添加约束时一定要先把translatesAutoresizingMaskIntoConstraints设置false" class="headerlink" title="1、在使用NSLayoutAnchor为视图添加约束时一定要先把translatesAutoresizingMaskIntoConstraints设置false"></a>1、在使用<code>NSLayoutAnchor</code>为视图添加约束时一定要先把<code>translatesAutoresizingMaskIntoConstraints</code>设置<code>false</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">centerView.translatesAutoresizingMaskIntoConstraints &#x3D; false</span><br></pre></td></tr></table></figure>
<h5 id="2、在使用safeAreaLayoutGuide适配iPhone-X-等机型时要对iOS-11之前的系统做适配，否则会导致低版本系统上程序Crash"><a href="#2、在使用safeAreaLayoutGuide适配iPhone-X-等机型时要对iOS-11之前的系统做适配，否则会导致低版本系统上程序Crash" class="headerlink" title="2、在使用safeAreaLayoutGuide适配iPhone X 等机型时要对iOS 11之前的系统做适配，否则会导致低版本系统上程序Crash"></a>2、在使用<code>safeAreaLayoutGuide</code>适配<code>iPhone X</code> 等机型时要对<code>iOS 11</code>之前的系统做适配，否则会导致低版本系统上程序Crash</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if #available(iOS 11.0, *) &#123;</span><br><span class="line">     tableView.topAnchor.constraint(equalTo: self.view.safeAreaLayoutGuide.topAnchor, constant: 0).isActive &#x3D; true</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">     tableView.topAnchor.constraint(equalTo: self.view.topAnchor, constant: 0).isActive &#x3D; true</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="3、设置约束后要将其激活，即设置isActive为true"><a href="#3、设置约束后要将其激活，即设置isActive为true" class="headerlink" title="3、设置约束后要将其激活，即设置isActive为true"></a>3、设置约束后要将其激活，即设置<code>isActive</code>为<code>true</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let centerX: NSLayoutConstraint &#x3D; centerView.centerXAnchor.constraint(equalTo: view.centerXAnchor, constant: 0)</span><br><span class="line">centerX.isActive &#x3D; true</span><br></pre></td></tr></table></figure>
<h5 id="4、leadingAnchor-不要和-leftAnchor混用"><a href="#4、leadingAnchor-不要和-leftAnchor混用" class="headerlink" title="4、leadingAnchor 不要和 leftAnchor混用"></a>4、<code>leadingAnchor</code> 不要和 <code>leftAnchor</code>混用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">centerView.leadingAnchor.constraint(equalTo: view.leftAnchor, constant: 0).isActive &#x3D; true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">centerView.leftAnchor.constraint(equalTo: view.leadingAnchor, constant: 0).isActive &#x3D; true</span><br></pre></td></tr></table></figure>
<p>以上2种写法，在编译时不会出现任何问题，但是在运行时就会报错，并会导致程序Crash,官方的说法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">While the NSLayoutAnchor class provides additional type checking, it is still possible to create </span><br><span class="line">invalid constraints. For example, the compiler allows you to constrain one view’s leadingAnchor</span><br><span class="line"> with another view’s leftAnchor, since they are both NSLayoutXAxisAnchor instances. However, </span><br><span class="line">Auto Layout does not allow constraints that mix leading and trailing attributes with left or right </span><br><span class="line">attributes. As a result, this constraint crashes at runtime.</span><br></pre></td></tr></table></figure>
<p>同理，<code>trailingAnchor</code>和<code>rightAnchor</code>也不能混用。</p>
<h5 id="5、如何刷新某个约束"><a href="#5、如何刷新某个约束" class="headerlink" title="5、如何刷新某个约束"></a>5、如何刷新某个约束</h5><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如我要修改一个<code>UIView</code>的宽度：<br>通过代码添加约束，可把<code>UIView</code>的宽度设置类属性，然后在需要的地方修改<code>constant</code>的参数，然后在刷新约束即可，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var centerView: UIView! </span><br><span class="line">var centerWidth: NSLayoutConstraint! </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">self.centerView &#x3D; UIView.init()</span><br><span class="line">view.addSubview(self.centerView)</span><br><span class="line">self.centerView.backgroundColor &#x3D; UIColor.red</span><br><span class="line">self.centerView.translatesAutoresizingMaskIntoConstraints &#x3D; false</span><br><span class="line">self.centerView.centerXAnchor.constraint(equalTo: view.centerXAnchor, constant: 0).isActive &#x3D; true</span><br><span class="line">self.centerView.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: 0).isActive &#x3D; true</span><br><span class="line">self.centerWidth &#x3D; self.centerView.widthAnchor.constraint(equalToConstant: 120)</span><br><span class="line">self.centerWidth.isActive &#x3D; true</span><br><span class="line">self.centerView.heightAnchor.constraint(equalToConstant: 120).isActive &#x3D; true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.centerWidth.constant &#x3D; 250</span><br><span class="line">weak var weakSelf &#x3D; self</span><br><span class="line">UIView.animate(withDuration: 0.35, animations: &#123;</span><br><span class="line">   weakSelf?.centerView.superview?.layoutIfNeeded()</span><br><span class="line">&#125;) &#123; (finished) in</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd12831dda304b3e9c4f5666f408e300~tplv-k3u1fbpfcp-zoom-1.image" alt="layoutDemo5.gif"></p>
<p>如果是<code>xib</code>或者<code>storyboard</code>，那就更简单了，直接摁住键盘<code>control</code>键，拖到对应的类里，然后在需要的地方修改约束并刷新即可。操作如下：<br><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e4c22a448af4ecfb08ac31267efce56~tplv-k3u1fbpfcp-zoom-1.image" alt="AutoLayoutdemo6.gif"></p>
<h5 id="6、设置宽高比"><a href="#6、设置宽高比" class="headerlink" title="6、设置宽高比"></a>6、设置宽高比</h5><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;在开发中，我们会遇到一些需求要求根据<code>UIView</code>的宽高比来设置约束，如一般情况下显示视频的宽高比是16:9，通过代码设置宽高比如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">centerView.heightAnchor.constraint(equalToConstant: 90).isActive &#x3D; true</span><br><span class="line">centerView.widthAnchor.constraint(equalTo: centerView.heightAnchor, multiplier: 16 &#x2F; 9).isActive &#x3D; true</span><br></pre></td></tr></table></figure>
<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d907322de88f4bc28837d6d72acef973~tplv-k3u1fbpfcp-zoom-1.image" alt="layoutDemo7.png"></p>
<blockquote>
<h3 id="7、Auto-Layout自适应UITableViewCell高度使用"><a href="#7、Auto-Layout自适应UITableViewCell高度使用" class="headerlink" title="7、Auto Layout自适应UITableViewCell高度使用"></a>7、<code>Auto Layout</code>自适应<code>UITableViewCell</code>高度使用</h3></blockquote>
<h5 id="1、-使用rowHeight设置高度"><a href="#1、-使用rowHeight设置高度" class="headerlink" title="1、 使用rowHeight设置高度"></a>1、 使用<code>rowHeight</code>设置高度</h5><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;一般情况下，如果<code>UITableView</code>的每个<code>Cell</code>高度是固定的我们可以直接指定一个值即可，如果没有设置<code>UITableView</code>的高度，系统会默认设置<code>rowHeight</code>高度是44。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tableview.rowHeight &#x3D; 44;</span><br></pre></td></tr></table></figure>
<p>也可以通过UITableViewDelegate的代理来设置UItableView的高度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;</span><br><span class="line">       return 50</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果通过手动计算每个<code>UItableViewCell</code>的高度，也在这个代理中实现，通过计算返回每个<code>UItableViewCell</code>的高度。</p>
<h5 id="2、使用estimatedRowHeight设置高度"><a href="#2、使用estimatedRowHeight设置高度" class="headerlink" title="2、使用estimatedRowHeight设置高度"></a>2、使用<code>estimatedRowHeight</code>设置高度</h5><p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<code>UItableView</code>继承自<code>UIScrollView</code>,<code>UIScrollView</code>的滚动需要设置其<code>contentSize</code>后，然后根据自身的<code>bounds、contentInset、contentOffset</code>等属性来计算出可滚动的长度。而<code>UITableView</code>在初始化时并不知道这些参数，只有在设置了<code>delegate</code>和<code>dataSource</code>之后，根据创建的<code>UITableViewCell</code>的个数和加载的<code>UITableViewCell</code>的高度之后才能算出可滚动的长度。</p>
<p>在使用<code>Auto Layout</code>自适应<code>UITableViewCell</code>高度时应提前设置一个估算值，当然这个估算值越接近真实值越好。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tableView.rowHeight &#x3D; UITableView.automaticDimension</span><br><span class="line">tableView.estimatedRowHeight &#x3D; 200</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123;</span><br><span class="line">   return 200    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/207509923e2b4898b3fbbdc502dca252~tplv-k3u1fbpfcp-zoom-1.image" alt="Autolayoutdemo2.png"></p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;如上图所示：这个界面就是用<code>Auto Layout + estimatedRowHeight</code>完成自适应高度的，在添加约束时要按照从上到下的书讯设置每一个<code>UIView</code>的顶部（<code>top</code>）到上一个的视图底部的（<code>bottom</code>）距离，同时要计算<code>UITableViewCell</code>内部所有控件的高度。那么问题来了，用户发布的内容详情没有得到数据之前时没办法算出其高度的，此处可以先给内容文字<code>UILabel</code>设置一个默认高度，然后让其根据内容填充自动计算高度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> topicInfoLab.heightAnchor.constraint(greaterThanOrEqualToConstant: 20).isActive &#x3D; true;</span><br><span class="line"> topicInfoLab.font &#x3D; UIFont.init(name: &quot;Montserrat-SemiBold&quot;, size: 12)</span><br><span class="line">topicInfoLab.numberOfLines &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>如果用户发布内容没有图片，直接设置发布内容UILabel距离UITableView距离底部的约束距离即可；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">detailsLab.bottomAnchor.constraint(equalTo: self.contentView.bottomAnchor, constant: -8).isActive &#x3D; true</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果用户发布的内容有图片，那么在计算出每张图片的位置和大小之后，一定要给最后一张图片设置距离<code>UItableViewCell</code>底部(<code>bottom</code>)的约束距离。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(idx, obj) in imageArray.enumerated() &#123;</span><br><span class="line">&#x2F;&#x2F;.....计算图片的大小和位置</span><br><span class="line">if idx &#x3D;&#x3D; imageArray.count - 1 &#123;</span><br><span class="line">   &#x2F;&#x2F;设置最后一张图片距离底部的约束</span><br><span class="line">   photo.bottomAnchor.constraint(equalTo: self.contentView.bottomAnchor, constant: -8).isActive &#x3D; true</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/413e2c97f7a54f48814fb1a20d019eba~tplv-k3u1fbpfcp-zoom-1.image" alt="layoutDemo8.png"></p>
<p>实现思路如上图所示，具体实现的请看<a href="https://github.com/dengfeng520/One-Swift">代码</a></p>
<blockquote>
<h3 id="8、-Compression-Resistance-Priority-和-Hugging-Priority使用"><a href="#8、-Compression-Resistance-Priority-和-Hugging-Priority使用" class="headerlink" title="8、 Compression Resistance Priority 和 Hugging Priority使用"></a>8、 <code>Compression Resistance Priority</code> 和 <code>Hugging Priority</code>使用</h3></blockquote>
<p><code>Compression Resistance Priority</code> 和 <code>Hugging Priority</code>在实际使用中往往配合使用，分别处理在同义水平线上多个view之间内容过少和内容过多而造成的互相压挤的情况。</p>
<p><code>Hugging Priority</code>的意思就是自包裹的优先级，优先级越高，则优先将尺寸按照控件的内容进行填充。</p>
<p><code>Compression Resistance Priority</code>，意思是说当不够显示内容时，根据这个优先级进行切割。优先级越低，越容易被切掉。</p>
<table>
<thead>
<tr>
<th align="center"><code>ContentHuggingPriority</code></th>
<th align="center">表示当前的<code>UIView</code>的内容不想被拉伸</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>ContentCompressionResistancePriority</code></td>
<td align="center">表示当前的<code>UIView</code>的内容不想被收缩</td>
</tr>
<tr>
<td align="center">默认情况下: <code>HuggingPriority</code> = 250</td>
<td align="center">默认情况下: <code>CompressionResistancePriority</code> = 750</td>
</tr>
</tbody></table>
<p>如设置2个<code>UILabel</code>的拉伸优先级可使用代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fristLab.setContentHuggingPriority(UILayoutPriority(rawValue: 251), for: .horizontal)</span><br><span class="line">secondLab.setContentCompressionResistancePriority(UILayoutPriority(rawValue: 750), for: .horizontal)</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a>9、总结</h3></blockquote>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;本文主要分享了苹果<code>Auto Layout</code>的几种实现方法和注意事项，对于<code>Auto Layout</code>在实际开发中的使用是采用纯代码、还是<code>xib</code> + 代码，还是<code>storyboard</code> + 代码，还是<code>xib</code> + <code>storyboard</code> + 代码的方式实现，主要看团队的要求、个人的习惯，以及<code>App</code>的繁琐程度。<br>对于<code>Auto Layout</code>在视图上的使用，个人建议如果UI比较简单或者单一的界面可使用<code>Auto Layout</code>，如果UI的操作或刷新很复杂的界面，建议还是<code>frame</code> + 手动布局的方式。</p>
<hr>
<p><a href="https://github.com/dengfeng520/RPChat">本文demo，请戳这里</a></p>
<p>友情链接：</p>
<p><a href="https://ming1016.github.io/2015/11/03/deeply-analyse-autolayout/#more">深入剖析Auto Layout，分析iOS各版本新增特性</a></p>
<p><a href="https://time.geekbang.org/column/article/85332">Auto Layout 是怎么进行自动布局的，性能如何？</a></p>
<p><a href="https://developer.apple.com/videos/play/wwdc2018/220">Apple Developer High Performance Auto Layout</a></p>
<p><a href="https://developer.apple.com/documentation/uikit/nslayoutconstraint">Apple Develope NSLayoutConstraint</a></p>
<p><a href="https://developer.apple.com/videos/play/wwdc2018/202/">WWDC 2018 What’s New in Cocoa Touch</a></p>
]]></content>
  </entry>
  <entry>
    <title>基于MVVM构建聊天App （二）登录UI实现</title>
    <url>/2021/01/05/%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2UI%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h6 align='right'>小时光</h6>

<h3 id="1、一个完整的开发流程"><a href="#1、一个完整的开发流程" class="headerlink" title="1、一个完整的开发流程"></a>1、一个完整的开发流程</h3><p>一般的，一个正常的流程包括：</p>
<ul>
<li>产品定需求，给出原型图</li>
<li>团队确认需求</li>
<li>由设计师开始设计图，同步开发做开发前的准备工作，如技术调查，前后端如何配合等</li>
<li>设计师完成设计后，团队对比设计图和原型图再次确认需求</li>
<li>开发团队开始开发工作</li>
<li>开发完成后由开发者自测 一般我们在开发中编写的单元测试代码也属于自测</li>
<li>开发者自测后由产品测试，事实上在开发过程中，产品也应该实时的关注开发</li>
<li>交由专业测试人员做测试</li>
<li>发布内测版本，做大规模测试</li>
<li>提交App Store审核</li>
</ul>
<h3 id="2、storyboard的App启动过程"><a href="#2、storyboard的App启动过程" class="headerlink" title="2、storyboard的App启动过程"></a>2、storyboard的App启动过程</h3><p><strong>UIApplicationMain</strong></p>
<p>一般的如果新建了一个<code>Objective-C</code>工程，默认先<code>main</code>函数，<code>main</code>函数内部会调用<code>UIApplicationMain</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但在<code>Swift</code>项目中，并没有<code>main.m</code>文件也没有<code>main</code>函数。<code>Swift</code>工程是在<code>AppDelegate</code>中用一个<code>@UIApplicationMain</code>标签。那么<code>UIApplicationMain</code>做了哪些操作呢：</p>
<ul>
<li><p>创建<code>UIApplication</code>单例对象</p>
</li>
<li><p>创建<code>UIApplication</code>的委托对象，即<code>AppDelegate</code></p>
</li>
<li><p>开启事件循环监听系统事件，当坚挺到对应的系统事件时会通知<code>AppDelegate</code></p>
</li>
<li><p>创建最底层的<code>UIWindows</code>对象，</p>
</li>
<li><p>读取<code>Info.plist</code>中设置的默认启动<code>storyboard</code>文件名称</p>
</li>
<li><p>加载设置的<code>is Initial View Controller</code><strong>storyboard</strong>文件，同时创建对应的<code>View Controller</code>对象</p>
</li>
<li><p>设置创建的<code>View Controller</code>为<code>UIWindows</code>的根视图<code>rootViewController</code></p>
</li>
<li><p>显示<code>Windows</code>上的试图</p>
<p>运行工程可以看到如下图： 最底层是一个<strong>UIWindwos</strong></p>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/28/172fa5dc09551fd3?w=919&h=828&f=png&s=431032" alt="windows"></p>
<h3 id="3、没有storyboard的启动"><a href="#3、没有storyboard的启动" class="headerlink" title="3、没有storyboard的启动"></a>3、没有storyboard的启动</h3><p> 一般的一个工程，默认从<code>main.storyboard</code>中的设置的<code>Initial view controller</code>启动的，那么我们该如何设置自己的初始启动<code>View Controller</code>呢？</p>
<p>在前面我们工程的结构：<strong>RPChat_iOS</strong>文件夹下是UI显示以及交互相关的代码，所以在<strong>RPChat_iOS</strong>中新建一个<strong>SignIn文件夹</strong>该目录下为登录相关的UI代码：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/1/173095ed9d6b11e0?w=202&h=386&f=png&s=121214" alt="SignIn"></p>
<p>新建登陆界面<code>Controller</code>命名为<code>SignInViewController</code></p>
<p>在<strong>AppDelegate</strong><code>didFinishLaunchingWithOptions launchOptions</code>回调方法中添加代码，设置SignInViewController为默认启动控制器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if #available(iOS 13, *) &#123;</span><br><span class="line">    </span><br><span class="line">&#125; else &#123;</span><br><span class="line">     window &#x3D; UIWindow.init()</span><br><span class="line">     window?.frame &#x3D; UIScreen.main.bounds</span><br><span class="line">     window?.makeKeyAndVisible()</span><br><span class="line">     let signInVC &#x3D; SignInViewController()</span><br><span class="line">     window?.rootViewController &#x3D; signInVC</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<strong>SceneDelegate</strong><code>options connectionOptions</code>方法中添加代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guard let windowScene &#x3D; (scene as? UIWindowScene) else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">window &#x3D; UIWindow(frame: windowScene.coordinateSpace.bounds)</span><br><span class="line">window?.windowScene &#x3D; windowScene</span><br><span class="line">window?.backgroundColor &#x3D; .white</span><br><span class="line">let tabBar &#x3D; SignInViewController()</span><br><span class="line">window?.rootViewController &#x3D; tabBar</span><br><span class="line">window?.makeKeyAndVisible()</span><br></pre></td></tr></table></figure>

<h3 id="4、登录UI的实现"><a href="#4、登录UI的实现" class="headerlink" title="4、登录UI的实现"></a>4、登录UI的实现</h3><p>先看一下这是最终效果图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/1/1730924e872c0e71?w=1242&h=2688&f=png&s=130841" alt="light Mode"></p>
<h5 id="4-1、Auto-Layout"><a href="#4-1、Auto-Layout" class="headerlink" title="4.1、Auto Layout"></a>4.1、<code>Auto Layout</code></h5><p>至于UI，考虑到版本兼容和后期维护我采用了系统<code>NSLayoutAnchor</code>适配，</p>
<p><code>NSLayoutAnchor</code>常用属性</p>
<ul>
<li>leadingAnchor</li>
<li>trailingAnchor</li>
<li>leftAnchor</li>
<li>rightAnchor</li>
<li>topAnchor</li>
<li>bottomAnchor</li>
<li>widthAnchor</li>
<li>heightAnchor</li>
<li>centerXAnchor</li>
<li>centerYAnchor</li>
<li>firstBaselineAnchor</li>
<li>lastBaselineAnchor</li>
</ul>
<p>关于<code>Auto Layout</code>其他更多使用细节请参考官方文档:</p>
<p><a href="https://developer.apple.com/videos/play/wwdc2018/202/">High Performance Auto Layout</a></p>
<p><a href="https://developer.apple.com/documentation/uikit/nslayoutconstraint">Apple Develope NSLayoutConstraint</a></p>
<p><a href="https://developer.apple.com/documentation/uikit/nslayoutanchor">Apple Develope NSLayoutAnchor</a></p>
<p><a href="https://developer.apple.com/videos/play/wwdc2018/202/">WWDC 2018 What’s New in Cocoa Touch</a></p>
<h5 id="4-2、UI实现"><a href="#4-2、UI实现" class="headerlink" title="4.2、UI实现"></a>4.2、UI实现</h5><p>新建一个<code>View</code>命名<code>SignInRootView</code>作为登录界面的主<code>View</code>，采用懒加载的方式初始化视图</p>
<p>最顶部的<code>Logo</code>图片实现代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lazy var logoImg: UIImageView &#x3D; &#123;</span><br><span class="line">        self.addSubview($0)</span><br><span class="line">        $0.translatesAutoresizingMaskIntoConstraints &#x3D; false</span><br><span class="line">        let top &#x3D; $0.topAnchor.constraint(equalTo: self.safeAreaLayoutGuide.topAnchor, constant: 44)</span><br><span class="line">        let centerX &#x3D; $0.centerXAnchor.constraint(equalTo: self.centerXAnchor, constant: 0)</span><br><span class="line">        let width &#x3D; $0.widthAnchor.constraint(equalToConstant: 120)</span><br><span class="line">        let height &#x3D; $0.heightAnchor.constraint(equalToConstant: 120)</span><br><span class="line">        NSLayoutConstraint.activate([top, centerX, width, height])</span><br><span class="line">        return $0</span><br><span class="line">    &#125;(UIImageView())</span><br></pre></td></tr></table></figure>
<p>用户名输入框实现代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lazy var accountNumberView: UIView &#x3D; &#123;</span><br><span class="line">       self.addSubview($0)</span><br><span class="line">       $0.translatesAutoresizingMaskIntoConstraints &#x3D; false</span><br><span class="line">       let top &#x3D; $0.topAnchor.constraint(equalTo: logoImg.bottomAnchor, constant: 20)</span><br><span class="line">       let left &#x3D; $0.leftAnchor.constraint(equalTo: self.leftAnchor, constant: 40)</span><br><span class="line">       let right &#x3D; $0.rightAnchor.constraint(equalTo: self.rightAnchor, constant: -40)</span><br><span class="line">       let height &#x3D; $0.heightAnchor.constraint(equalToConstant: 50)</span><br><span class="line">       NSLayoutConstraint.activate([top, left, right, height])</span><br><span class="line">       $0.layer.cornerRadius &#x3D; 25</span><br><span class="line">       return $0</span><br><span class="line">   &#125;(UIView())</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   lazy var accountNumberLab: UITextField &#x3D; &#123;</span><br><span class="line">       accountNumberView.addSubview($0)</span><br><span class="line">       $0.translatesAutoresizingMaskIntoConstraints &#x3D; false</span><br><span class="line">       $0.topAnchor.constraint(equalTo: accountNumberView.topAnchor, constant: 0).isActive &#x3D; true</span><br><span class="line">       $0.leftAnchor.constraint(equalTo: accountNumberView.leftAnchor, constant: 16).isActive &#x3D; true</span><br><span class="line">       $0.rightAnchor.constraint(equalTo: accountNumberView.rightAnchor, constant: -16).isActive &#x3D; true</span><br><span class="line">       $0.bottomAnchor.constraint(equalTo: accountNumberView.bottomAnchor, constant: 0).isActive &#x3D; true</span><br><span class="line">       $0.font &#x3D; UIFont.init(name: &quot;PingFangTC-Semibold&quot;, size: 19)</span><br><span class="line">       return $0</span><br><span class="line">   &#125;(UITextField())</span><br></pre></td></tr></table></figure>
<p>密码输入框实现代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lazy var inputPasswordView: UIView &#x3D; &#123;</span><br><span class="line">           self.addSubview($0)</span><br><span class="line">           $0.translatesAutoresizingMaskIntoConstraints &#x3D; false</span><br><span class="line">           let top &#x3D; $0.topAnchor.constraint(equalTo: accountNumberView.bottomAnchor, constant: 20)</span><br><span class="line">           let left &#x3D; $0.leftAnchor.constraint(equalTo: self.leftAnchor, constant: 40)</span><br><span class="line">           let right &#x3D; $0.rightAnchor.constraint(equalTo: self.rightAnchor, constant: -40)</span><br><span class="line">           let height &#x3D; $0.heightAnchor.constraint(equalToConstant: 50)</span><br><span class="line">           NSLayoutConstraint.activate([top, left, right, height])</span><br><span class="line">           $0.layer.cornerRadius &#x3D; 25</span><br><span class="line">           return $0</span><br><span class="line">       &#125;(UIView())</span><br><span class="line">    </span><br><span class="line">       </span><br><span class="line">    lazy var inputPasswordTxt: UITextField &#x3D; &#123;</span><br><span class="line">           inputPasswordView.addSubview($0)</span><br><span class="line">           $0.translatesAutoresizingMaskIntoConstraints &#x3D; false</span><br><span class="line">           $0.topAnchor.constraint(equalTo: inputPasswordView.topAnchor, constant: 0).isActive &#x3D; true</span><br><span class="line">           $0.leftAnchor.constraint(equalTo: inputPasswordView.leftAnchor, constant: 16).isActive &#x3D; true</span><br><span class="line">           $0.rightAnchor.constraint(equalTo: inputPasswordView.rightAnchor, constant: -16).isActive &#x3D; true</span><br><span class="line">           $0.bottomAnchor.constraint(equalTo: inputPasswordView.bottomAnchor, constant: 0).isActive &#x3D; true</span><br><span class="line">           $0.font &#x3D; UIFont.init(name: &quot;PingFangTC-Semibold&quot;, size: 19)</span><br><span class="line">           return $0</span><br><span class="line">       &#125;(UITextField())</span><br></pre></td></tr></table></figure>
<p>登录按钮实现代码： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lazy var signInBtn: UIButton &#x3D; &#123;</span><br><span class="line">        self.addSubview($0)</span><br><span class="line">        $0.translatesAutoresizingMaskIntoConstraints &#x3D; false</span><br><span class="line">        let top &#x3D; $0.topAnchor.constraint(equalTo: inputPasswordView.bottomAnchor, constant: 20)</span><br><span class="line">        let left &#x3D; $0.leftAnchor.constraint(equalTo: self.leftAnchor, constant: 40)</span><br><span class="line">        let right &#x3D; $0.rightAnchor.constraint(equalTo: self.rightAnchor, constant: -40)</span><br><span class="line">        let height &#x3D; $0.heightAnchor.constraint(equalToConstant: 50)</span><br><span class="line">        NSLayoutConstraint.activate([top, left, right, height])</span><br><span class="line">        $0.layer.cornerRadius &#x3D; 25</span><br><span class="line">        $0.titleLabel?.font &#x3D; UIFont.init(name: &quot;PingFangTC-Semibold&quot;, size: 20)</span><br><span class="line">        $0.setTitle(NSLocalizedString(&quot;Sign In&quot;, comment: &quot;&quot;), for: .normal)</span><br><span class="line">        return $0</span><br><span class="line">   &#125;(UIButton())</span><br></pre></td></tr></table></figure>
<p>此处代码较多，具体实现请看代码： <a href="https://github.com/dengfeng520/RPChat">gitub RPChat</a></p>
<h5 id="4-3、设置背景颜色"><a href="#4-3、设置背景颜色" class="headerlink" title="4.3、设置背景颜色"></a>4.3、设置背景颜色</h5><p>由于设计师给出的颜色一般为16进制，此处需要做一个转码处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class func hexStringToColor(_ hexadecimal: String) -&gt; UIColor &#123;</span><br><span class="line">        var cstr &#x3D; hexadecimal.trimmingCharacters(in:  CharacterSet.whitespacesAndNewlines).uppercased() as NSString;</span><br><span class="line">        if(cstr.length &lt; 6)&#123;</span><br><span class="line">            return UIColor.clear;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cstr.hasPrefix(&quot;0X&quot;))&#123;</span><br><span class="line">            cstr &#x3D; cstr.substring(from: 2) as NSString</span><br><span class="line">        &#125;</span><br><span class="line">        if(cstr.hasPrefix(&quot;#&quot;))&#123;</span><br><span class="line">            cstr &#x3D; cstr.substring(from: 1) as NSString</span><br><span class="line">        &#125;</span><br><span class="line">        if(cstr.length !&#x3D; 6)&#123;</span><br><span class="line">            return UIColor.clear;</span><br><span class="line">        &#125;</span><br><span class="line">        var range &#x3D; NSRange.init()</span><br><span class="line">        range.location &#x3D; 0</span><br><span class="line">        range.length &#x3D; 2</span><br><span class="line">        let rStr &#x3D; cstr.substring(with: range);</span><br><span class="line">        range.location &#x3D; 2;</span><br><span class="line">        let gStr &#x3D; cstr.substring(with: range)</span><br><span class="line">        range.location &#x3D; 4;</span><br><span class="line">        let bStr &#x3D; cstr.substring(with: range)</span><br><span class="line">        var r :UInt32 &#x3D; 0x0;</span><br><span class="line">        var g :UInt32 &#x3D; 0x0;</span><br><span class="line">        var b :UInt32 &#x3D; 0x0;</span><br><span class="line">        Scanner.init(string: rStr).scanHexInt32(&amp;r);</span><br><span class="line">        Scanner.init(string: gStr).scanHexInt32(&amp;g);</span><br><span class="line">        Scanner.init(string: bStr).scanHexInt32(&amp;b);</span><br><span class="line">        return UIColor.init(red: CGFloat(r)&#x2F;255.0, green: CGFloat(g)&#x2F;255.0, blue: CGFloat(b)&#x2F;255.0, alpha: 1)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以用设计师给的16进制设置背景颜色：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signInBtn.backgroundColor &#x3D; UIColor.hexStringToColor(&quot;0xF5BE62&quot;)</span><br></pre></td></tr></table></figure>
<h5 id="4-4、Drak-Mode适配"><a href="#4-4、Drak-Mode适配" class="headerlink" title="4.4、Drak Mode适配"></a>4.4、Drak Mode适配</h5><h6 id="4-4-1、文本和UIView背景颜色适配"><a href="#4-4-1、文本和UIView背景颜色适配" class="headerlink" title="4.4.1、文本和UIView背景颜色适配"></a>4.4.1、文本和UIView背景颜色适配</h6><p>由于<code>iOS 13</code>之后苹果处理<code>Drak Mode</code>,作为开发者也应该做相应的兼容处理。现在我在代码中并没有此时调整模拟器为暗模式，运行工程可以看到在暗模式下，用户名和密码输入框背景色不见了。此时就应该做暗模式的兼容处理。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/1/1730940682f94d7e?w=1242&h=2688&f=png&s=128055" alt="drak mode"></p>
<p>此处我的做法也很简单，对<code>UIColor</code>做<code>extension</code>处理，然后再扩展方法中分别对<code>Drak Mode</code>和<code>Light Mode</code>两种模式做对应的处理，代码如下： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension UIColor &#123;</span><br><span class="line">   &#x2F;&#x2F;&#x2F; 当前是否是暗模式</span><br><span class="line">    public class var drakMode: Bool &#123;</span><br><span class="line">        if #available(iOS 13.0, *) &#123;</span><br><span class="line">            let currentMode &#x3D; UITraitCollection.current.userInterfaceStyle</span><br><span class="line">            if currentMode &#x3D;&#x3D; .dark &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    public class func isDrakMode() -&gt; Bool &#123;</span><br><span class="line">        if #available(iOS 13.0, *) &#123;</span><br><span class="line">            let currentMode &#x3D; UITraitCollection.current.userInterfaceStyle</span><br><span class="line">            if currentMode &#x3D;&#x3D; .dark &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; UIView背景颜色</span><br><span class="line">    public class var darkModeViewColor: UIColor &#123;</span><br><span class="line">        if #available(iOS 13.0, *) &#123;</span><br><span class="line">            return .systemBackground</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return .white</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class func configDarkModeViewColor() -&gt; UIColor &#123;</span><br><span class="line">        if #available(iOS 13.0, *) &#123;</span><br><span class="line">            return .systemBackground</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return .white</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 文字颜色</span><br><span class="line">    public class var darkModeTextColor: UIColor &#123;</span><br><span class="line">        if #available(iOS 13.0, *) &#123;</span><br><span class="line">            if drakMode &#x3D;&#x3D; true &#123;</span><br><span class="line">                return .white</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return .black</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return .black</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class func configDarkModeTxtColor() -&gt; UIColor &#123;</span><br><span class="line">        if #available(iOS 13.0, *) &#123;</span><br><span class="line">            if drakMode &#x3D;&#x3D; true &#123;</span><br><span class="line">                return .white</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return .black</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return .black</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 子UIView背景颜色</span><br><span class="line">    public class var subDarkModeViewColor: UIColor &#123;</span><br><span class="line">        if #available(iOS 13.0, *) &#123;</span><br><span class="line">            if drakMode &#x3D;&#x3D; true &#123;</span><br><span class="line">                return UIColor(red: 100&#x2F;255, green: 100&#x2F;255, blue: 100&#x2F;255, alpha: 1)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return .groupTableViewBackground</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return .groupTableViewBackground</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class func configSubDarkModeViewColor() -&gt; UIColor &#123;</span><br><span class="line">        if #available(iOS 13.0, *) &#123;</span><br><span class="line">            if drakMode &#x3D;&#x3D; true &#123;</span><br><span class="line">                return UIColor(red: 100&#x2F;255, green: 100&#x2F;255, blue: 100&#x2F;255, alpha: 1)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return .groupTableViewBackground</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return .groupTableViewBackground</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 设置Placeholder文字颜色</span><br><span class="line">    public class var placeholderColor: UIColor &#123;</span><br><span class="line">        if #available(iOS 13.0, *) &#123;</span><br><span class="line">            if drakMode &#x3D;&#x3D; true &#123;</span><br><span class="line">                return UIColor(red: 255, green: 255, blue: 255, alpha: 0.25)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return UIColor(red: 0, green: 0, blue: 0, alpha: 0.25)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return UIColor(red: 0, green: 0, blue: 0, alpha: 0.25)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class func configPlaceholderColor() -&gt; UIColor &#123;</span><br><span class="line">        if #available(iOS 13.0, *) &#123;</span><br><span class="line">            if drakMode &#x3D;&#x3D; true &#123;</span><br><span class="line">                return UIColor(red: 255, green: 255, blue: 255, alpha: 0.25)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return UIColor(red: 0, green: 0, blue: 0, alpha: 0.25)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return UIColor(red: 0, green: 0, blue: 0, alpha: 0.25)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要在设置颜色时通过方法或者属性设置即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">accountNumberView.backgroundColor &#x3D; .subDarkModeViewColor</span><br><span class="line">inputPasswordView.backgroundColor &#x3D; .subDarkModeViewColor</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">accountNumberView.backgroundColor &#x3D; UIColor.configSubDarkModeViewColor()</span><br><span class="line">inputPasswordView.backgroundColor &#x3D; UIColor.configSubDarkModeViewColor()</span><br></pre></td></tr></table></figure>
<p>从结果上来说，这两种方式没有任何区别。一般用属性的话在设置或计算时看起来更自然一些，例如我用 <code>a = 0</code>会比<code>a = getData()</code> 看起来更直观自然一些。<br>《Clearn Code》一书中强调，对方法或函数的命名尽量使用动词或动词短语，所以在使用一个方法时，通常的代码表示要做一些事情。此处我只是修改<code>UIView</code>的背景颜色，所以我个人觉得使用属性设置更直观一些。</p>
<h6 id="4-4-2、图片DrakMode适配"><a href="#4-4-2、图片DrakMode适配" class="headerlink" title="4.4.2、图片DrakMode适配"></a>4.4.2、图片DrakMode适配</h6><p>在Xcode中修改图片为Any,Dark，Xcode会自动生成一组新的暗模式下的填充图片，把图片拖入即可。<br><img src="https://upload-images.jianshu.io/upload_images/1214383-e124e54aec36e840.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DrakMode"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1214383-f43ddf384b598988.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="drak Mode"></p>
<h6 id="4-4-3、监听traitCollection的变化"><a href="#4-4-3、监听traitCollection的变化" class="headerlink" title="4.4.3、监听traitCollection的变化"></a>4.4.3、监听<strong>traitCollection</strong>的变化</h6><p>在一些特殊的地方需要根据当前系统是否处于暗模式分别作出处理，如一般情况下隐私协议用WKWebView加载,在正常情况下为白色背景黑色文字，在暗模式下为黑色背景白色文字，此时上面的代码已经不能满足我的需求了。此时就需要对当前系统是否是暗模式做监听处理。</p>
<p>我的做法是定一个DrakModeProtocol协议，在需要监听的Controller中，遵循这个协议即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 协议</span><br><span class="line">public protocol DrakModeProtocol : NSObjectProtocol &#123;</span><br><span class="line">    @available(iOS 13.0, *)</span><br><span class="line">    var traitCollection: UITraitCollection &#123; get &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    @available(iOS 13.0, *)</span><br><span class="line">    func traitCollectionDidChange(_ traitCollection: UITraitCollection?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 使用方法</span><br><span class="line">extension MineWKWebViewController: DrakModeProtocol &#123;</span><br><span class="line">    override func traitCollectionDidChange(_ traitCollection: UITraitCollection?) &#123;</span><br><span class="line">           if #available(iOS 13.0, *) &#123;</span><br><span class="line">               if UITraitCollection.current.userInterfaceStyle &#x3D;&#x3D; .dark &#123;</span><br><span class="line">                   webView.evaluateJavaScript(&quot;document.body.style.backgroundColor&#x3D;\&quot;#000000\&quot;&quot;) &#123; (data, error) in</span><br><span class="line">                       </span><br><span class="line">                   &#125;</span><br><span class="line">                   webView.evaluateJavaScript(&quot;document.body.style.webkitTextFillColor&#x3D;\&quot;#FFFFFF\&quot;&quot;) &#123; (data, error) in</span><br><span class="line">                       </span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   webView.evaluateJavaScript(&quot;document.body.style.backgroundColor&#x3D;\&quot;#FFFFFF\&quot;&quot;) &#123; (data, error) in</span><br><span class="line">                       </span><br><span class="line">                   &#125;</span><br><span class="line">                   webView.evaluateJavaScript(&quot;document.body.style.webkitTextFillColor&#x3D;\&quot;#000000\&quot;&quot;) &#123; (data, error) in</span><br><span class="line">                       </span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45758010c13f408eb0ba42166dba5b36~tplv-k3u1fbpfcp-zoom-1.image" alt="隐私协议"></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef595234a7af43879feef7cb686d0f84~tplv-k3u1fbpfcp-zoom-1.image" alt="隐私协议"></p>
<p>再次运行项目，可以看到界面已经兼容了暗模式：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/1/17309250eeaae02b?w=1242&h=2688&f=png&s=132283" alt="drak Mode"></p>
<h6 id="4-4-4、iOS-13之前老版本采用微软的开源库FluentDarkModeKit"><a href="#4-4-4、iOS-13之前老版本采用微软的开源库FluentDarkModeKit" class="headerlink" title="4.4.4、iOS 13之前老版本采用微软的开源库FluentDarkModeKit"></a>4.4.4、iOS 13之前老版本采用微软的开源库<code>FluentDarkModeKit</code></h6><p> 关于<code>FluentDarkModeKit</code>使用细节请参考<a href="https://github.com/microsoft/FluentDarkModeKit">microsoft  FluentDarkModeKit</a></p>
<p>本文主要写了： </p>
<ul>
<li>不通过storyboard启动App</li>
<li>登录UI的实现</li>
<li>Drak Mode的适配</li>
</ul>
<p>[本文demo: Github RPChat](</p>
]]></content>
  </entry>
  <entry>
    <title>Runtime之指针和结构体</title>
    <url>/2020/04/28/Runtime%E4%B9%8B%E6%8C%87%E9%92%88%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h6 align='right'>小时光</h6>

<blockquote>
<h3>1、C语言指针</h3>
</blockquote>
<p>#####（1.1）、什么是指针</p>
<p>一般的，在定义数据对象时，需要说明对象的名称和数据类型，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int test &#x3D; 0;</span><br></pre></td></tr></table></figure>
<p>申明数据类型的作用时告诉IDE要为多想分配多大的存储空间（字节），以及对象中要存储什么类型的值。</p>
<p>对象名称的作用是对应分配到的内存单元，允许按照名称来访问，如我定义<code>test</code>这个变量，在程序中需要使用时，就可以通过<code>tes</code>来访问这个变量。但是在一些特殊情况下如由于作用域问题无法直接访问这个变量，那么可以通过访问这个变量的内存地址来访问这个变量。</p>
<p>因此C语言中形象的将变量的内存地址称为<strong>指针</strong>，即一个对象的地址就是该对象的指针。</p>
<p>举个例子：我申请的int类型的<code>test</code>的指针为40001，但并不表示地址40001指的是<code>test</code>.</p>
<p>此处需要注意，<strong>40001只是这个变量的首地址</strong>，我申请的int类型的<code>test</code>在内存中占四个字节，所以40001，40002，40003，40004这四个内存地址才是<code>test</code>的内存。</p>
<p>所以我们常说的，<strong>变量(对象)的指针实际上是这个变量(对象)在内存中的首地址</strong>。</p>
<p>使用指针有哪些好处呢？</p>
<ul>
<li>提高存储效率</li>
<li>间接访问由于作用域不可见的变量</li>
<li>访问动态的内存空间</li>
</ul>
<p>#####（1.2）、指针和指针变量的区别</p>
<p>指针是地址值，指针变量是存储指针的变量，我们可以通过指针变量间接访问（或者存取）一个对象。</p>
<p>#####（1.3）、指针的分类</p>
<ul>
<li>（1.3.1）、普通的指针</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 111;</span><br><span class="line">int *pa &#x3D; &amp;a;</span><br><span class="line">char p &#x3D; &#39;C&#39;;</span><br><span class="line">char *pb &#x3D; &amp;p;</span><br></pre></td></tr></table></figure>
<p>代码<code>int *pa = &amp;a;</code>的作用是指针赋值，那么该如何验证是否赋值成功并如何使用这个值呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *pdd &#x3D; pa;</span><br><span class="line">printf(&quot;取值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;%d,%d\n&quot;,*pa,*pdd);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>定义一个pdd指针，然后打印指针pdd所指向的值。最终看到的结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">取值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;111,111</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码已经完成了指针的赋值和取值操作。</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/Runtime/C_Pointer.png?raw=true" alt="指针"></p>
<p>上图演示了指针和变量在内存中的关系，111是int型，<code>C</code>是char型。<code>pa</code>是111的指针，指向111在内存中的首地址。同理pb也指向了<code>C</code>的首地址。</p>
<p>实际上，在内存中一个类型表示的是这变量在内存中所占的大小，因为int类型在内存中占用了4个字节的内存大小,<code>C</code>占用了一个字节的空间。</p>
<p>此时已经知道变量的类型是int类型、内存中的指针首地址以及该变量所占内存大小，就可以从首地址取四个字节的长度就代表着这个变量在内存中的值。</p>
<ul>
<li>（1.3.2）、指针的指针</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 指针的指针 赋值</span><br><span class="line">int **ppa  &#x3D; &amp;pa; </span><br><span class="line">&#x2F;&#x2F; 取值</span><br><span class="line">printf(&quot;\n**ppa&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;%d&quot;,**ppa);</span><br></pre></td></tr></table></figure>
<p>此处<code>ppa</code>指向的是<code>pa</code>的地址，<code>pa</code>指向的是int型a的地址，所以打印出来就是a的值。</p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/Runtime/C_Point_Point.png?raw=true" alt="指针"></p>
<p>如上图所示：<code>ppa</code>指向的存放<code>&amp;a</code>的首地址，即是<code>pa</code>,<code>ppb</code>指向存放<code>&amp;b</code>的首地址。</p>
<p>既然普通的类型需要占用内存空间，那么指针也是需要占用内存空间的。<br>我们通过指针的指针拿到这个指针，再通过这个指针拿到这个指针所指向的内容。</p>
<ul>
<li>（1.3.3）、数组指针</li>
</ul>
<p>指针指向的是一个对象在内存中的首地址，那么数组指针指向的是什么呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char array[] &#x3D; &quot;hello&quot;;</span><br><span class="line">char *arrayPointer &#x3D; array;</span><br></pre></td></tr></table></figure>
<p>此处定义了一个char类型数组，然后取数组指针。此处我通过数组遍历对数组中的每个元素的内存地址，然后和数组指针做一次比较：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf(&quot;\narrayPointer&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;%p\n&quot;,arrayPointer);</span><br><span class="line">for (int i &#x3D; 0;i&lt;sizeof(array);i++) &#123;</span><br><span class="line">    printf(&quot;\ni,everyone&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;%d,%p\n&quot;,i,&amp;array[i]);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arrayPointer&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;0x7ffee815584a</span><br><span class="line"></span><br><span class="line">i,everyone&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;0,0x7ffee815584a</span><br><span class="line"></span><br><span class="line">i,everyone&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1,0x7ffee815584b</span><br><span class="line"></span><br><span class="line">i,everyone&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2,0x7ffee815584c</span><br><span class="line"></span><br><span class="line">i,everyone&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;3,0x7ffee815584d</span><br><span class="line"></span><br><span class="line">i,everyone&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;4,0x7ffee815584e</span><br><span class="line"></span><br><span class="line">i,everyone&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;5,0x7ffee815584f</span><br></pre></td></tr></table></figure>
<p>可以看到数组的指针和这个数组第一个元素的指针是一样的，所以可以得出结论：__数组的指针并不是这个数组的指针，而是数组第一个元素的首地址指针__。<br><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/Runtime/C_Pointer_Array.png?raw=true" alt="数组的指针"></p>
<p>在获取数组元素的时候可以通过第一个元素的首地址+元素在内存中的字节长度，从而获取到第二个元素的内存地址，同理可以得到不同元素的指针.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i &#x3D; 0;i&lt;sizeof(array);i++) &#123;</span><br><span class="line">   printf(&quot;\neveryone&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;%c\n&quot;,*(array + i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">everyone&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;h</span><br><span class="line"></span><br><span class="line">everyone&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;e</span><br><span class="line"></span><br><span class="line">everyone&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;l</span><br><span class="line"></span><br><span class="line">everyone&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;l</span><br><span class="line"></span><br><span class="line">everyone&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;o</span><br></pre></td></tr></table></figure>
<p>那么从数组中取值就有2种方法，第一传统的下标取值，第二通过元素指针取值。</p>
<ul>
<li>（1.3.4）、函数指针</li>
</ul>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/Runtime/function_Pointer.png?raw=true" alt="函数的指针"></p>
<p>函数的指针和函数非常类似，在函数前面加上一个指针括号，我们拿到函数的指针之后，就可以调用这个指针来执行函数。此处定义2个函数，一个返回int类型，一个返回int类型的指针,此处需要注意，函数指针和返回指针的函数是两个不同概念。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int getMax(int i,int j) &#123;</span><br><span class="line">    return i&gt;j?i:j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int *getMin(int i,int j) &#123;</span><br><span class="line">    int result &#x3D; i&lt;j?i:j;</span><br><span class="line">    int *pointer &#x3D; &amp;result;</span><br><span class="line">    return pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么，该如何通过指针调用函数呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int (*funcOne)(int,int);</span><br><span class="line">funcOne &#x3D; getMax;</span><br><span class="line">int result &#x3D; funcOne(10001,10086);</span><br><span class="line">printf(&quot;\nresult&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;%d\n&quot;,result);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>定义一个函数指针并赋值，通过调用指针来调用这个函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *funcTwo &#x3D; getMin(10001, 10086);</span><br><span class="line">printf(&quot;funcTwo&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;%d&quot;,*funcTwo);</span><br></pre></td></tr></table></figure>
<p>调用返回指针的函数时先定义指针来接收函数的返回值。这个指针类型应为函数返回指针所指向的类型。</p>
<blockquote>
<h3>2、结构体</h3>
</blockquote>
<p>结构体是由一系列的相同或者不同的类型构成的数据集合，Swift中的元组和结构体非常类似。</p>
<p>#####（2.1）结构体的组成</p>
<p>结构体一般由结构体名、结构体变量、结构体成员组成.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 结构体名 + 结构体成员 + 变量名</span><br><span class="line">struct personAbout &#123;</span><br><span class="line">    char name;</span><br><span class="line">    int age;</span><br><span class="line">&#125;person;</span><br></pre></td></tr></table></figure>
<p>如代码所示，我定义了一个结构体，结构体名personAbout，变量名person，成员有2个，name和age; </p>
<p><img src="https://github.com/dengfeng520/xiaoshiguangBlog/blob/master/Runtime/Struct.png?raw=true" alt="Struct.png"></p>
<p>一般情况下，结构体的名和变量名可省略其中一个，但不能全部省去不写，也就是说下面这两种写法也可以定义一个结构体。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 结构体名 + 结构体成员</span><br><span class="line">struct personFrist &#123;</span><br><span class="line">    char name[20];</span><br><span class="line">    int *age;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 结构体变量 + 成员</span><br><span class="line">struct &#123;</span><br><span class="line">    char name[20];</span><br><span class="line">    int *age;</span><br><span class="line">&#125;personSecond;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>#####（2.2）结构体的使用</p>
<ul>
<li>继承</li>
</ul>
<p>例如在前面我定义了一个<code>person</code>的结构体，现在我又有一个对象，也包含name和age属性，此时可以采用结构体继承的方式。结构体继承和类的继承一样，直接冒号，继承的父类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct student: personAbout &#123;</span><br><span class="line">    int number;</span><br><span class="line">&#125;student;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置别名</li>
</ul>
<p>一般情况下通过<code>typedef</code>关键字为结构体设置别名，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 结构体的别名</span><br><span class="line">typedef struct studentFrist: personAbout &#123;</span><br><span class="line">    int number;</span><br><span class="line">    studentFrist() &#123;</span><br><span class="line">        number &#x3D; 10001;</span><br><span class="line">        age &#x3D; new int(17);</span><br><span class="line">        strcpy(name, &quot;韩梅梅&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;studentFrist;</span><br></pre></td></tr></table></figure>
<ul>
<li>结构体赋值 </li>
</ul>
<p>方法一：直接赋值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 结构体赋值 方法一</span><br><span class="line">int age &#x3D; 17;</span><br><span class="line">struct personAbout person &#x3D; &#123;&quot;李雷&quot;,&amp;age&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：可通过结构体的变量名赋值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">student.number &#x3D; 1000;</span><br><span class="line">strcpy(student.name,&quot;李雷&quot;);</span><br><span class="line">student.age &#x3D; new int(17);</span><br></pre></td></tr></table></figure>
<p>方法三:在定义的时候就给结构体赋值:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 结构体的继承</span><br><span class="line">struct student: personAbout &#123;</span><br><span class="line">    int number;</span><br><span class="line">    student() &#123;</span><br><span class="line">        number &#x3D; 10000;</span><br><span class="line">        age &#x3D; new int(16);</span><br><span class="line">        strcpy(name, &quot;李雷&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;student;</span><br></pre></td></tr></table></figure>
<ul>
<li>结构体取值</li>
</ul>
<p>1、直接取值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct studentZero stu;</span><br><span class="line">int number &#x3D; stu.number;</span><br></pre></td></tr></table></figure>
<p>2、别名取值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">studentFrist stuFrist;</span><br><span class="line">int stuNumber &#x3D; stuFrist.number;</span><br></pre></td></tr></table></figure>
<p>3、指针取值</p>
<p>先拿到结构体的指针，然后通过-&gt;得到结构体中的某个变量值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">studentFrist *stuPoiner &#x3D; &amp;stuFrist;</span><br><span class="line">int studentNumber &#x3D; stuPoiner-&gt;number;</span><br></pre></td></tr></table></figure>

<ul>
<li>结构体的位域</li>
</ul>
<p>部分属性在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。为了节省存储空间，并使处理简便，Ｃ语言又提供了一种数据结构，称为__位域__。所谓称为__位域__是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。在结构体中8位域等于一子节。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct teacher &#123;</span><br><span class="line">      unsigned int a: 1;</span><br><span class="line">      unsigned int b: 2;</span><br><span class="line">      unsigned int c: 3;</span><br><span class="line">  &#125;tc,*ptc;</span><br></pre></td></tr></table></figure>
<p>位域的赋值不能超过该域所能表示的最大值，如:</p>
<p>b只有2位，能表示的最大数为3，如超过3就会报黄点，Xcode会默认赋值为0，并显示警告:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Implicit truncation from &#39;int&#39; to bit-field changes value from 4 to 0</span><br></pre></td></tr></table></figure>
<p>所以在使用结构体位域时，我们应计算好位域的位数，避免出错。</p>
<p>–</p>
<p><a href="https://github.com/dengfeng520/Clangdemo.git">本文demo</a></p>
]]></content>
  </entry>
  <entry>
    <title>地铁三号线</title>
    <url>/2021/04/10/%E5%9C%B0%E9%93%81%E4%B8%89%E5%8F%B7%E7%BA%BF/</url>
    <content><![CDATA[<h6 align='right'>小时光</h6>
<h6 align='right'><a href='https://dengfeng520.github.io/'>我的博客</a></h6>

<h4 align='center'>
写一部小说需要三要素
</h4>
<h4 align='center'>
时间、地点、人物
</h4>
<h4 align='center'>
末班车、终点站、一个人
</h4>

<p><img src="/img/girl045.jpg" alt="地铁三号线"></p>
]]></content>
  </entry>
  <entry>
    <title>王者荣耀李信台词和语音包</title>
    <url>/2021/02/27/%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E6%9D%8E%E4%BF%A1%E5%8F%B0%E8%AF%8D%E5%92%8C%E8%AF%AD%E9%9F%B3%E5%8C%85/</url>
    <content><![CDATA[<h6 align='right'>小时光</h6>


<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=3&id=2487494968&auto=1&height=66"></iframe>


<p><a href="https://www.bilibili.com/video/BV1Zz4y127Mo">语音包来源</a></p>
<p><strong><a href="https://music.163.com/#/dj?id=2487494968&userid=114235047">网易音乐播放地址</a></strong></p>
<p>最近超喜欢玩李信这个英雄，<br>不仅帅气语音台词也超级棒。</p>
<p><img src="/img/img043.webp" alt="一念神魔"></p>
<p>这是最好的时代，这是最坏的时代，我们一无所有，我们蔚然矗立(统御)</p>
<p>没有欲望和执念，也无需欲望和执念，真好（狂暴）</p>
<p>没有领土的王，没有故乡的人（兰陵王）</p>
<p>讨厌看到他们离我而去，因为是战友么（狂暴）</p>
<p>羌笛吹落梅，让人分不清异乡和故里 (伽罗)</p>
<p>渴望靠近篝火，又恐惧被温暖灼伤（狂暴）</p>
<p>为何看不清故乡的模样，即使它就在心的中央（统御）</p>
<p>能提起沉重剑刃的手，握不住飞舞飘落的花（狂暴）</p>
<p>这里是，为我所统帅的战场（统御）</p>
<p>这里是，让我忘却野心的战场（狂暴）</p>
<p>不会让长安城将我遗忘（统御）</p>
<p>血肉之躯，燃烧一次足以（狂暴）</p>
<p>我们的共同点，是都想做第一个看到黎明的人吧（统御）</p>
<p>预言无用，不知道结局的人生才会刺激（明世隐）</p>
<p>今日的星辰，辉映太古的缘起，过往的注视，指引明日的生死（统御）</p>
<p>一无所有，至少能肆意如风（狂暴）</p>
<p>不知道轮回过的灵魂是否更懂得死亡（统御）</p>
<p>不会为不存在的天命，去压低脊梁（狂暴）</p>
<p>人生仅有一次的绝景（统御）</p>
<p>孤独，是双刃的锋芒（狂暴）</p>
<p>何处是吾乡（统御阵亡） </p>
<p>人间不值得（狂暴阵亡）</p>
<p>开疆易而守土难（统御）</p>
<p>崩刃的剑依旧致命，锈蚀的盾屹立如初（狂暴）</p>
<p>长城和长安之间，是无尽的彷徨（统御）</p>
<p>屠魔的少年终究成魔，存活最后的魔，做了救世主（狂暴）</p>
<p>听天，不会由命（统御）</p>
<p>单纯为不想死而挥剑（狂暴）</p>
<p>血肉之躯，燃烧一次足以（狂暴）</p>
<p>异乡人，怎能容忍故土脱离自己的手掌（兰陵王）</p>
<p>恐怕需要九倍的破坏力才能实现独一的执着（沈梦溪）</p>
<p>锋刃铸就信仰,奉承暗与光</p>
<p>长城之上是千亿的星空，星空之上是不灭的守望</p>
<p>如有一味绝境，非历十方生死（一念神魔出场）</p>
<p>一念通天，神魔无惧（一念神魔出场）</p>
<p>看看像我这样的凡人，都怎么诛灭神魔（一念神魔狂暴）</p>
<p>天生吾族，岂可轻弃（一念神魔统御）</p>
<p>天地不仁，大道无光（一念神魔狂暴）</p>
<p>化神为佑，沐临绝土（一念神魔统御）</p>
<p>独倚白夜，破魔为生（一念神魔狂暴）</p>
<p>此，天命也（一念神魔统御）</p>
<p>为何看不清故乡的模样，即使它就在心的中央（统御）</p>
<p>世上是否存在典籍，告诉我如何与自我和解（伽罗）</p>
<p>羌笛吹落梅，让人分不清异乡和故里 (伽罗)</p>
<p>失败之前，对面不会有想太多的时间（狂暴嘲讽）</p>
<p>无知无用无能无脑无聊，加起来，就是对面的无人队（统御嘲讽）</p>
<p>照彻，苦难的世间（统御）</p>
<p>击破，宿命的无常（狂暴）</p>
<p>去哪里寻找，救赎此界的力量（统御）</p>
<p>去哪里寻找，重造此界的力量（狂暴）</p>
<p>我，就是太阳（统御开启大招）</p>
<p>我，即是黑夜（狂暴开启大招）</p>
<p>天地无心，日月崇光（统御）</p>
<p>天开见光，流血滂滂（狂暴）</p>
<p>此剑，当斩，群魔授首（狂暴换统御）</p>
<p>此剑，当判，诸神谢罪（统御换狂暴）</p>
<p>我与我剑斩黄泉（统御）</p>
<p>哼，我心如冰，剑如霜（狂暴）</p>
<p>没有领土的王，没有故乡的人（兰陵王）</p>
<p>人生仅有一次的绝景（统御）</p>
<p>死亡是当英雄的前提（狂暴）</p>
<p>侯非侯，王非王，千乘万骑走北邙（统御）</p>
<p>渴望靠近篝火，又恐惧被温暖灼伤（狂暴）</p>
<p>随他陨落，随他沉沦，因他重返千年之盛（统御）</p>
<p>他人是地狱，再无法信任他人是轮回的地狱（狂暴）</p>
<p>这是最好的时代，这是最坏的时代，我们一无所有，我们蔚然矗立</p>
<p>投身天地之熔炉，总有些梦想和意志会因此薪火相传</p>
<p>能提起沉重剑刃的手，握不住飞舞飘落的花（狂暴）</p>
<p>雷电惧散（一念神魔出场）</p>
<p>这里是，为我所统帅的战场 （统御）</p>
<p>这里是，让我忘却野心的战场 （狂暴）</p>
<p>不会让长安城将我遗忘（统御）</p>
<p>唯有燃烧在长城的篝火，让我放下野望（狂暴）</p>
<p>听天，不会由命（统御）</p>
<p>孤独，是双刃的锋芒（狂暴）</p>
<p>长城和长安之间，是无尽的彷徨（统御）</p>
<p>一无所有，至少能肆意如风（狂暴）</p>
<p>不知道轮回过的灵魂是否更懂得死亡（统御）</p>
<p>屠魔的少年终究成魔，存活最后的魔，做了救世主（狂暴）</p>
<p>何处是吾乡（统御阵亡） </p>
<p>人间不值得（狂暴阵亡）</p>
<p>无数次，在人世的焦土上，祈望太阳（统御）</p>
<p>我也曾，在人世的焦土上，幻想太阳（狂暴）</p>
<p>吾持剑锋，以筑长城（统御）</p>
<p>血肉之躯，燃烧一次足以（狂暴）</p>
<p>异乡人，怎能容忍故土脱离自己的手掌（兰陵王）</p>
<p>不会为不存在的天命，去压低脊梁（狂暴）</p>
<p>至少梦里不可能存在这样的土地，这样的米饭吧（百里守约）</p>
<p>只有在梦里，才会做梦（庄周）</p>
<p>我们的共同点，是都想做第一个看到黎明的人吧（统御）</p>
<p>单纯为不想死而挥剑（狂暴）</p>
<p>背负守护的誓言 必以信成（统御）</p>
<p>血肉之躯，燃烧一次足以（狂暴）</p>
<p>不是力量，是诅咒（统御）</p>
<p>预言无用，不知道结局的人生才会刺激（明世隐）</p>
<p>今日的星辰，辉映太古的缘起，过往的注视，指引明日的生死（统御）</p>
<p>崩刃的剑依旧致命，锈蚀的盾屹立如初（狂暴）</p>
<p>缺少的：<br>猫有九条命，那么家谱也有九倍长吧（沈梦溪）</p>
<p>双面的刃，伤人又伤己（凯）</p>
<p>百炼之志，当我问鼎（一念神魔统御）</p>
<p>如果害怕就跑吧（一念神魔狂暴）</p>
<p>我早就，无路可退了（狂暴阵亡）</p>
<p>光明，始于先驱者（一念神魔统御） </p>
<p>像面对黑夜一样，面对死亡（一念神魔阵亡）</p>
<p>光明神已陨落，现在由光明引领我（一念神魔统御）</p>
<p>越是没有武器，越要变得强大 （一念神魔狂暴）</p>
<p>越是没有武器，越要变得强大 （一念神魔统御）</p>
]]></content>
  </entry>
  <entry>
    <title>iOS多线程之GCD</title>
    <url>/2021/03/01/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8BGCD/</url>
    <content><![CDATA[<h6 align='right'>小时光</h6>

<p>前一篇<a href="https://dengfeng520.github.io/2021/02/06/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%A7%88/">iOS 多线程概览</a>简单介绍了iOS 中<code>Operation</code>的基础用法。<br>由于GCD简单易用，任务更简单纯粹，执行效率高，本身性能高这些优点，使得GCD在实际开发的使用和面试中出现的频率非常高。掌握GCD及其多线程技术点并将其运用于开发中是开发一个良好易用App的基础之一。本文主要整理了GCD的一些知识点和基础用法。</p>
<h3 id="1、GCD概览"><a href="#1、GCD概览" class="headerlink" title="1、GCD概览"></a>1、GCD概览</h3><p>GCD全称是<code>Grand Central Dispatch</code>，是Apple为开发者提供的一个多线程编程的方案，它是一个在线程池模式的基础上执行的并发任务，GCD充分利用硬件的多核性能，让开发者编写出更高效的代码。</p>
<h3 id="2、GCD的队列和任务"><a href="#2、GCD的队列和任务" class="headerlink" title="2、GCD的队列和任务"></a>2、GCD的队列和任务</h3><h4 id="2-1、队列"><a href="#2-1、队列" class="headerlink" title="2.1、队列"></a>2.1、队列</h4><ul>
<li><p>主队列(main Queue): 在主线程中执行的任务,主要用于处理UI相关的任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let main &#x3D; DispatchQueue.main</span><br></pre></td></tr></table></figure></li>
<li><p>串行队列（serial Queue）: 任务按照先后顺序执行，一般只分配一个线程，同一时刻只会执行一个任务，并严格按照任务顺序执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let serialQueue &#x3D; DispatchQueue(label: &quot;com.tsn.demo.serialQueue&quot;)</span><br></pre></td></tr></table></figure>
<p>例如串行队列中有三个下载图片任务，系统会根据这三个任务加入到队列的顺序执行，下载完成第一张图片后才会下载第二张图片，第二张图片下载完成后才会下载第三张图片。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32d364cdc3bc4ce1aae755df1436cd63~tplv-k3u1fbpfcp-watermark.image" alt="串行队列"></p>
</li>
<li><p>并行队列（concurrent Queue）: 多个任务同时执行，完成的顺序不一定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let concurrentQueue &#x3D; DispatchQueue(label: &quot;com.tsn.demo.concurrentQueue&quot;, attributes: .concurrent)</span><br></pre></td></tr></table></figure>
<p>创建队列时设置<code>attributes</code>属性为<code>concurrent</code>就是并行队列。GCD会根据当前系统的状况至少为并行队列分配一个线程，且线程允许被任何队列的任务阻塞。</p>
</li>
</ul>
<p>如果是用并行队列来下载图片，GCD会根据当前系统状况开启多个线程下载图片，下载图片任务之间互不影响，完成的时间也不一定。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f19855970a864b9d9e5a76c10f9b5588~tplv-k3u1fbpfcp-watermark.image" alt="并行队列"></p>
<ul>
<li><p>全局并发队列 （global Queue）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let globalQueue &#x3D; DispatchQueue.global()</span><br><span class="line">let globalQueue &#x3D; DispatchQueue.global(qos: .background)</span><br></pre></td></tr></table></figure>
<p>全局并发队列系统提供了6个不同的优先级别，分别是<code>background、utility、default、userInitiated、userInteractive、unspecified</code>。创建队列时，其中<code>qos</code>参数表示的是队列的优先级别,可以使用默认优先级，也可以单独指定。</p>
</li>
</ul>
<h4 id="2-2、任务"><a href="#2-2、任务" class="headerlink" title="2.2、任务"></a>2.2、任务</h4><p> GCD的任务一般我们认为是程序执行时做的事情，如一个API调用，一个方法、函数等。</p>
<ul>
<li>同步任务</li>
</ul>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queue.sync &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>同步任务一经提交会在当前线程执行立即执行，不会开启新线程，并且会阻塞当前线程，当前任务在执行完并返回结果后才能执行下一步。</strong></p>
<p> 如图所示，今天公司给我安排了一个开发任务A，当我正在开发时又出现了一个很紧急任务B此时我只能暂停做到一半的任务A来执行任务B，当B任务完成后才能继续开发任务A，这种执行方式为同步。</p>
<p>  <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbd50ceaae5c477e86e5bc76614bee27~tplv-k3u1fbpfcp-watermark.image" alt="同步任务">  </p>
<ul>
<li><p>异步任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">queue.async &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>*异步任务提交后不会阻塞当前线程，会新建另一个线程执行。**</p>
<p>如图所示，今天给我安排了任务A，同时给另一个同事安排了任务B，我们两开发的是同一个App此处可以看作是一个队列，无论是谁先完成任务告知对方，然后完成代码merge即可。这种执行方式可以看作是异步。</p>
</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99b0bec6cc0f494f889fe889b58b3c2e~tplv-k3u1fbpfcp-watermark.image" alt="异步任务"></p>
<ul>
<li><p>栅栏任务</p>
<p>栅栏任务会对队列中的任务进行阻隔，先把队列中已有的任务全部执行完然后再执行栅栏任务。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b57508eec65454b8cd7ab1b5ae3b6ca~tplv-k3u1fbpfcp-watermark.image" alt="栅栏任务"></p>
</li>
<li><p>迭代任务</p>
<p>如果说使用并行队列是为了提高程序的执行效率，那么迭代任务就是为了更高效的更全面的利用手机性能来执行任务。<br>GCD使用<code>concurrentPerform</code>方法执行迭代任务，类似于<code>Objective-C</code>的<code>dispatch_apply</code>方法。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let musicArray &#x3D; Array&lt;AnyObject?&gt;(repeating: nil, count: 10)</span><br><span class="line">DispatchQueue.concurrentPerform(iterations: musicArray.count) &#123; (index) in</span><br><span class="line">    print(&quot;-----------执行查找操作-----------&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3、队列详细属性"><a href="#2-3、队列详细属性" class="headerlink" title="2.3、队列详细属性"></a>2.3、队列详细属性</h4><p>  前面已经给出一般我们创建队列，系统提供的完成的创建方法:</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let concurrentQueue &#x3D; DispatchQueue(label: &quot;com.tsn.demo.concurrentQueue&quot;, qos: .default, attributes: .concurrent, autoreleaseFrequency: .inherit, target: nil)</span><br></pre></td></tr></table></figure>
<h6 id="2-3-1-常用API"><a href="#2-3-1-常用API" class="headerlink" title="2.3.1 常用API"></a>2.3.1 常用API</h6><ul>
<li><p>Dispatch.main 主线程队列</p>
</li>
<li><p>Dispatch.global 全局队列</p>
</li>
<li><p>DispatchQueue(label:, qos:, attributes:, autoreleaseFrequency:, target:) 新建一个队列</p>
</li>
<li><p>queue.label 设置线程名称，label为队列名称，一般采用**<code>com</code>+公司缩写+工程名+线程名**的命名方式。</p>
</li>
<li><p>setTarget(queue: DispatchQueue?) 设置指定队列 </p>
<p>​    </p>
<h6 id="2-3-2、QoS-队列在执行上是有优先级的，更高的优先级可以享受更多的计算资源，从高到低的顺序为："><a href="#2-3-2、QoS-队列在执行上是有优先级的，更高的优先级可以享受更多的计算资源，从高到低的顺序为：" class="headerlink" title="2.3.2、QoS: 队列在执行上是有优先级的，更高的优先级可以享受更多的计算资源，从高到低的顺序为："></a>2.3.2、QoS: 队列在执行上是有优先级的，更高的优先级可以享受更多的计算资源，从高到低的顺序为：</h6><ul>
<li>userInteractive</li>
<li>userInitiated</li>
<li>default</li>
<li>utility</li>
<li>background</li>
</ul>
</li>
</ul>
<h6 id="2-3-3、Attributes标识队列类型"><a href="#2-3-3、Attributes标识队列类型" class="headerlink" title="2.3.3、Attributes标识队列类型"></a>2.3.3、Attributes标识队列类型</h6><ul>
<li>concurrent: 标识队列为并行队列</li>
<li>initiallyInactive: 标识队列运行中的任务需要手动触发，不设置此属性，向队列中添加任务自动运行，通过<code>queue.activate()</code>方法触发任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let initiallyInactiveQueue &#x3D; DispatchQueue(label: &quot;com.tsn.demo.initiallyInactiveQueue&quot;, qos: .default, attributes: .initiallyInactive, autoreleaseFrequency: .inherit, target: nil)</span><br><span class="line">initiallyInactiveQueue.async &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br><span class="line">initiallyInactiveQueue.async &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br><span class="line">initiallyInactiveQueue.async &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br><span class="line">initiallyInactiveQueue.activate()</span><br></pre></td></tr></table></figure>
<h6 id="2-3-4、AutoreleaseFrequency-表示autorelease-pool的自动释放频率，autorelease-pool用来处理任务对象的内存周期。系统提供了三个属性"><a href="#2-3-4、AutoreleaseFrequency-表示autorelease-pool的自动释放频率，autorelease-pool用来处理任务对象的内存周期。系统提供了三个属性" class="headerlink" title="2.3.4、AutoreleaseFrequency: 表示autorelease pool的自动释放频率，autorelease pool用来处理任务对象的内存周期。系统提供了三个属性:"></a>2.3.4、AutoreleaseFrequency: 表示<code>autorelease pool</code>的自动释放频率，<code>autorelease pool</code>用来处理任务对象的内存周期。系统提供了三个属性:</h6><ul>
<li>inherit: 继承目标队列的该属性</li>
<li>workItem: 跟随每个任务的执行周期自动创建和释放</li>
<li>never: 需要手动管理内存</li>
</ul>
<h6 id="2-3-5、Target-一般创建的队列不设置，如果没有设置系统会自动设置，最终都指向系统主队列或全局并发队列。"><a href="#2-3-5、Target-一般创建的队列不设置，如果没有设置系统会自动设置，最终都指向系统主队列或全局并发队列。" class="headerlink" title="2.3.5、Target: 一般创建的队列不设置，如果没有设置系统会自动设置，最终都指向系统主队列或全局并发队列。"></a>2.3.5、Target: 一般创建的队列不设置，如果没有设置系统会自动设置，最终都指向系统<code>主队列</code>或<code>全局并发队列</code>。</h6> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let queue &#x3D; DispatchQueue(label: &quot;com.tsn.demo.queue&quot;, qos: .default, attributes: .concurrent, autoreleaseFrequency: .inherit, target: nil)</span><br></pre></td></tr></table></figure>
<p>  即然最终都是指向<code>主队列</code>或<code>全局并发队列</code>，那为什么不直接将任务添加到<code>主队列</code>或<code>全局并发队列</code>中呢？通过自定义队列可以将任务分组管理，这样可以防止自定义队列阻塞主队列。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  let queue &#x3D; DispatchQueue(label: &quot;com.tsn.demo.queue&quot;, qos: .default, attributes: .concurrent, autoreleaseFrequency: .inherit, target: .main)</span><br><span class="line">let queue &#x3D; DispatchQueue(label: &quot;com.tsn.demo.queue&quot;, qos: .default, attributes: .concurrent, autoreleaseFrequency: .inherit, target: .global())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3、任务和队列不同组合方式"><a href="#3、任务和队列不同组合方式" class="headerlink" title="3、任务和队列不同组合方式"></a>3、任务和队列不同组合方式</h3><h4 id="3-1-同步-串行"><a href="#3-1-同步-串行" class="headerlink" title="3.1 同步 + 串行"></a>3.1 同步 + 串行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;3.1-----------\(Thread.current)-----------start&quot;)</span><br><span class="line">serialQueue.sync &#123;</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;3.1.1-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">serialQueue.sync &#123;</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;3.1.2-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">serialQueue.sync &#123;</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;3.1.3-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">serialQueue.sync &#123;</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;3.1.4-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;3.1-----------\(Thread.current)-----------end&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.1-----------&lt;NSThread: 0x600000f58700&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------start</span><br><span class="line">3.1.1-----------&lt;NSThread: 0x600000f58700&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------</span><br><span class="line">3.1.2-----------&lt;NSThread: 0x600000f58700&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------</span><br><span class="line">3.1.3-----------&lt;NSThread: 0x600000f58700&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------</span><br><span class="line">3.1.4-----------&lt;NSThread: 0x600000f58700&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------</span><br><span class="line">3.1-----------&lt;NSThread: 0x600000f58700&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------end</span><br></pre></td></tr></table></figure>
<p>可以得出结论： </p>
<ul>
<li>不开启新线程，所有任务都是在主线程中执行的</li>
<li>任务是按顺序执行的，每次只执行一个任务</li>
</ul>
<h4 id="3-2-异步-串行"><a href="#3-2-异步-串行" class="headerlink" title="3.2 异步 + 串行"></a>3.2 异步 + 串行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;3.2-----------\(Thread.current)-----------start&quot;)</span><br><span class="line">serialQueue.async &#123;</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;3.2.1-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">serialQueue.async &#123;</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;3.2.2-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">serialQueue.async &#123;</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;3.2.3-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">serialQueue.async &#123;</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;3.2.4-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;3.2-----------\(Thread.current)-----------end&quot;)</span><br></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.2-----------&lt;NSThread: 0x600001974840&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------start</span><br><span class="line">3.2-----------&lt;NSThread: 0x600001974840&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------end</span><br><span class="line">3.2.1-----------&lt;NSThread: 0x6000019748c0&gt;&#123;number &#x3D; 11, name &#x3D; (null)&#125;-----------</span><br><span class="line">3.2.2-----------&lt;NSThread: 0x6000019748c0&gt;&#123;number &#x3D; 11, name &#x3D; (null)&#125;-----------</span><br><span class="line">3.2.3-----------&lt;NSThread: 0x6000019748c0&gt;&#123;number &#x3D; 11, name &#x3D; (null)&#125;-----------</span><br><span class="line">3.2.4-----------&lt;NSThread: 0x6000019748c0&gt;&#123;number &#x3D; 11, name &#x3D; (null)&#125;-----------</span><br></pre></td></tr></table></figure>
<ul>
<li>开启新线程，注意此处只开启了一条新线程</li>
<li>所有的任务是在<code>start</code>和<code>end</code>之后执行的，异步任务不做等待会直接执行后面的任务</li>
<li>所有的任务是按顺序执行的</li>
</ul>
<h4 id="3-3-同步-并行"><a href="#3-3-同步-并行" class="headerlink" title="3.3 同步 + 并行"></a>3.3 同步 + 并行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;3.3-----------\(Thread.current)-----------start&quot;)</span><br><span class="line">concurrentQueue.sync &#123;</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;3.3.1-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">concurrentQueue.sync &#123;</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;3.3.2-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">concurrentQueue.sync &#123;</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;3.3.3-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">concurrentQueue.sync &#123;</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&quot;3.3.4-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;3.3-----------\(Thread.current)-----------end&quot;)</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.3-----------&lt;NSThread: 0x600003914840&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------start</span><br><span class="line">3.3.1-----------&lt;NSThread: 0x600003914840&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------</span><br><span class="line">3.3.2-----------&lt;NSThread: 0x600003914840&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------</span><br><span class="line">3.3.3-----------&lt;NSThread: 0x600003914840&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------</span><br><span class="line">3.3.4-----------&lt;NSThread: 0x600003914840&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------</span><br><span class="line">3.3-----------&lt;NSThread: 0x600003914840&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------end</span><br></pre></td></tr></table></figure>
<ul>
<li>所有的任务都是在主线程中执行的，没有开启新线程</li>
<li>所有的任务是在<code>start</code>和<code>end</code>之间执行的，同步任务需要等待队列的任务执行结果</li>
<li>任务是按照先后顺序执行的，虽然并发队列可以开启多个线程并且可以同时执行多个任务，但是本身不能创建新线程。</li>
</ul>
<h4 id="3-4-异步-并行"><a href="#3-4-异步-并行" class="headerlink" title="3.4 异步 + 并行"></a>3.4 异步 + 并行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;3.4-----------\(Thread.current)-----------start&quot;)</span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">     sleep(1)</span><br><span class="line">     print(&quot;3.4.1-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">     sleep(1)</span><br><span class="line">     print(&quot;3.4.2-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">     sleep(1)</span><br><span class="line">     print(&quot;3.4.3-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">     sleep(1)</span><br><span class="line">     print(&quot;3.4.4-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;3.4-----------\(Thread.current)-----------end&quot;)</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.4-----------&lt;NSThread: 0x6000035407c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------start</span><br><span class="line">3.4-----------&lt;NSThread: 0x6000035407c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------end</span><br><span class="line">3.4.3-----------&lt;NSThread: 0x600003550340&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;-----------</span><br><span class="line">3.4.4-----------&lt;NSThread: 0x6000035450c0&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;-----------</span><br><span class="line">3.4.1-----------&lt;NSThread: 0x600003545340&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;-----------</span><br><span class="line">3.4.2-----------&lt;NSThread: 0x600003544000&gt;&#123;number &#x3D; 7, name &#x3D; (null)&#125;-----------</span><br></pre></td></tr></table></figure>
<ul>
<li>所有的任务是在<code>start</code>和<code>end</code>之后执行的，异步任务不做等待会直接执行后面的任务</li>
<li>每个任务都开启了一个新线程来执行，异步执行可以开启新线程，并发队列可以同时执行多个任务</li>
</ul>
<h4 id="3-5-同步-主队列"><a href="#3-5-同步-主队列" class="headerlink" title="3.5 同步+主队列"></a>3.5 同步+主队列</h4><h5 id="3-5-1-在主线程中调用-同步-主队列"><a href="#3-5-1-在主线程中调用-同步-主队列" class="headerlink" title="3.5.1 在主线程中调用 同步 + 主队列"></a>3.5.1 在主线程中调用 同步 + 主队列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let mainQueue &#x3D; DispatchQueue.main</span><br><span class="line">mainQueue.sync &#123;</span><br><span class="line">   sleep(1)</span><br><span class="line">   print(&quot;1-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">mainQueue.sync &#123;</span><br><span class="line">   sleep(1)</span><br><span class="line">   print(&quot;2-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">mainQueue.sync &#123;</span><br><span class="line">   sleep(1)</span><br><span class="line">   print(&quot;3-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码，发现没有打印任何东西，原因是是我把任务放在了主线程队列中，由于同步任务会等待当前队列中的任务完成后才会继续执行的特性，此时主队列和我添加的任务会互相等待，所以任务不会执行也没有任何打印。</p>
<h5 id="3-5-1-在其他线程中调用-同步-主队列"><a href="#3-5-1-在其他线程中调用-同步-主队列" class="headerlink" title="3.5.1 在其他线程中调用 同步 + 主队列"></a>3.5.1 在其他线程中调用 同步 + 主队列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let queue &#x3D; DispatchQueue(label: &quot;com.tsn.test.queue&quot;, attributes: .concurrent)</span><br><span class="line">queue.async &#123;</span><br><span class="line">   print(&quot;0-----------\(Thread.current)-----------start&quot;)</span><br><span class="line">   let mainQueue &#x3D; DispatchQueue.main</span><br><span class="line">   mainQueue.sync &#123;</span><br><span class="line">      sleep(1)</span><br><span class="line">      print(&quot;1-----------\(Thread.current)-----------&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">   mainQueue.sync &#123;</span><br><span class="line">      sleep(1)</span><br><span class="line">      print(&quot;2-----------\(Thread.current)-----------&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">   mainQueue.sync &#123;</span><br><span class="line">      sleep(1)</span><br><span class="line">      print(&quot;3-----------\(Thread.current)-----------&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">   print(&quot;4-----------\(Thread.current)-----------end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0-----------&lt;NSThread: 0x600001f08580&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------start</span><br><span class="line">1-----------&lt;NSThread: 0x600001f08580&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------</span><br><span class="line">2-----------&lt;NSThread: 0x600001f08580&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------</span><br><span class="line">3-----------&lt;NSThread: 0x600001f08580&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------</span><br><span class="line">4-----------&lt;NSThread: 0x600001f08580&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------end</span><br></pre></td></tr></table></figure>
<ul>
<li>虽然我新建了一个线程，但任务依旧是在主线程中执行的,没有开启新线程</li>
<li>所有任务都是在<code>start</code>和<code>end</code>之间执行的</li>
<li>主队列是串行队列，所以任务是按顺序执行的</li>
</ul>
<h4 id="3-6-异步-主队列"><a href="#3-6-异步-主队列" class="headerlink" title="3.6 异步+主队列"></a>3.6 异步+主队列</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;3.6-----------\(Thread.current)-----------start&quot;)</span><br><span class="line">let mainQueue &#x3D; DispatchQueue.main</span><br><span class="line">mainQueue.async &#123;</span><br><span class="line">     sleep(1)</span><br><span class="line">     print(&quot;3.6.1-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">mainQueue.async &#123;</span><br><span class="line">     sleep(1)</span><br><span class="line">     print(&quot;3.6.2-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">mainQueue.async &#123;</span><br><span class="line">     sleep(1)</span><br><span class="line">     print(&quot;3.6.3-----------\(Thread.current)-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;3.6-----------\(Thread.current)-----------end&quot;)</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.6-----------&lt;NSThread: 0x600002590240&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------start</span><br><span class="line">3.6-----------&lt;NSThread: 0x600002590240&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------end</span><br><span class="line">3.6.1-----------&lt;NSThread: 0x600002590240&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------</span><br><span class="line">3.6.2-----------&lt;NSThread: 0x600002590240&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------</span><br><span class="line">3.6.3-----------&lt;NSThread: 0x600002590240&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;-----------</span><br></pre></td></tr></table></figure>
<ul>
<li>所有的任务都是在主线程中执行的，没有开启新线程</li>
<li>所有任务都是在<code>start</code>和<code>end</code>之后执行的</li>
<li>任务是按顺序执行的</li>
</ul>
<p>对于上面的各个组合做一个整理，如下表所示:</p>
<table>
<thead>
<tr>
<th align="left">区别</th>
<th align="right">串行队列</th>
<th align="center">并行队列</th>
<th align="center">主队列</th>
</tr>
</thead>
<tbody><tr>
<td align="left">同步(sync)</td>
<td align="right">不开启新线程，串行执行</td>
<td align="center">没有开启新线程，串行执行</td>
<td align="center">1、在主线程中调用时会造成死锁；2、在其他线程中调用时:不开启新线程在主线程中执行，串行执行</td>
</tr>
<tr>
<td align="left">异步(async)</td>
<td align="right">开启一条新线程，串行执行</td>
<td align="center">开启多个新线程，并行执行</td>
<td align="center">没有开启新线程，串行执行</td>
</tr>
</tbody></table>
<h3 id="4、GCD队列和任务详解"><a href="#4、GCD队列和任务详解" class="headerlink" title="4、GCD队列和任务详解"></a>4、GCD队列和任务详解</h3><p>前面简单介绍了GCD的任务和队列，此处结合例子和示例代码来进一步说明GCD实际开发中的使用。</p>
<p> (1)、串行队列和并行队列: 拿平时下载电影来举例说明，默认情况下视频资源的下载按照从上到下的顺序来下载（这就是串行队列）。但此时我的的目标是下载所有的电影，我并不关心电影下载的顺序，所以此时可以让多个下载任务同时执行。（这就是并行队列）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 串行队列</span><br><span class="line">let serialQueue &#x3D; DispatchQueue(label: &quot;com.tsn.demo.serialQueue&quot;)</span><br><span class="line">&#x2F;&#x2F; 并行队列 </span><br><span class="line">let concurrentQueue &#x3D; DispatchQueue(label: &quot;com.tsn.demo.concurrentQueue&quot;, attributes: .concurrent)</span><br></pre></td></tr></table></figure>
<p> (2)、对于多个下载任务而言，可以多个下载任务同时下载各个下载任务之间互不影响（这是异步执行）。但是在播放视频时只能等前一个视频播放完了才能播放第二个视频(这是同步执行)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 同步执行</span><br><span class="line">queue.sync &#123;</span><br><span class="line">    &#x2F;&#x2F; 播放视频一</span><br><span class="line">&#125;</span><br><span class="line">queue.sync &#123;</span><br><span class="line">    &#x2F;&#x2F; 播放视频二</span><br><span class="line">&#125;</span><br><span class="line">queue.sync &#123;</span><br><span class="line">    &#x2F;&#x2F; 播放视频三</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 异步执行</span><br><span class="line">queue.async &#123;</span><br><span class="line">    &#x2F;&#x2F; 下载视频一</span><br><span class="line">&#125;</span><br><span class="line">queue.async &#123;</span><br><span class="line">    &#x2F;&#x2F; 下载视频二</span><br><span class="line">&#125;</span><br><span class="line">queue.async &#123;</span><br><span class="line">    &#x2F;&#x2F; 下载视频三</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> (3)、如果视频还在下载中就点了播放键，此时要保证视频、音频、弹幕这三个捆绑到一起下载（这是任务组）。只有这三个下载任务全部完了在播放视频（栅栏任务）。</p>
<p>栅栏任务示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let barrierQueue &#x3D; DispatchQueue(label: &quot;com.tsn.demo.barrierQueue&quot;, attributes: .concurrent)</span><br><span class="line"></span><br><span class="line">let barrierTask &#x3D; DispatchWorkItem(qos: .default, flags: .barrier) &#123;</span><br><span class="line">    &#x2F;&#x2F; 点击开始播放视频</span><br><span class="line">    print(&quot;-----------开始播放------------&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">barrierQueue.async &#123;</span><br><span class="line">   &#x2F;&#x2F; 下载视频</span><br><span class="line">    print(&quot;-----------下载视频------------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">barrierQueue.async &#123;</span><br><span class="line">    &#x2F;&#x2F; 下载音频</span><br><span class="line">    print(&quot;-----------下载音频------------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">barrierQueue.async &#123;</span><br><span class="line">    &#x2F;&#x2F; 下载弹幕</span><br><span class="line">    print(&quot;-----------下载弹幕------------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 栅栏任务</span><br><span class="line">barrierQueue.async(execute: barrierTask)</span><br></pre></td></tr></table></figure>
<p>运行代码，打印的结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----------下载视频------------</span><br><span class="line">-----------下载音频------------</span><br><span class="line">-----------下载弹幕------------</span><br><span class="line">-----------开始播放------------</span><br></pre></td></tr></table></figure>
<p>在实际的开发中，视频的播放、下载、缓存要比上面的举例要复杂的多。如在传输过程中可能会出现丢包、掉帧等情况。</p>
<p>(4)、如果在下载途中，因为其他操作如我点击了暂停，或来了个电话（这是挂起队列），过了一会又点击继续开始下载（唤醒队列），同时这些操作还要用到下载任务的暂停和继续。</p>
<p>GCD可以把尚未执行的任务挂起，但是不影响正在执行和已执行的任务，挂起的任务后续可手动在其唤醒。<br><code>suspend()</code>方法挂起任务，<code>resume()</code>方法唤醒任务，此处要注意的是<strong>调用唤醒的次数必须等于挂起的次数，否则就会出现不可预测的错误。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SuspendAndResum &#123;</span><br><span class="line">    let queue &#x3D; DispatchQueue(label: &quot;com.tsn.demo.concurrentQueue&quot;, attributes: .concurrent)</span><br><span class="line">    &#x2F;&#x2F; 记录队列挂起的次数</span><br><span class="line">    var index &#x3D; 0</span><br><span class="line">    </span><br><span class="line">    init() &#123;</span><br><span class="line">        &#x2F;&#x2F; 模拟任务挂起</span><br><span class="line">        configQueue()</span><br><span class="line">        DispatchQueue.main.asyncAfter(deadline: .now() + 5) &#123;</span><br><span class="line">            &#x2F;&#x2F; 模拟任务唤醒</span><br><span class="line">            self.testResume()</span><br><span class="line">            &#x2F;&#x2F; 唤醒任务后继续下载 下载完成后播放视频</span><br><span class="line">            self.goOnQueue()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func configQueue() &#123;</span><br><span class="line">        queue.async &#123;</span><br><span class="line">            print(&quot;-----------模拟下载视频-----------&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        queue.async &#123;</span><br><span class="line">            print(&quot;-----------模拟下载音频-----------&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        queue.async &#123;</span><br><span class="line">            print(&quot;-----------模拟下载弹幕-----------&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 通过栅栏挂起任务</span><br><span class="line">        queue.async(execute: DispatchWorkItem(flags: .barrier) &#123;</span><br><span class="line">            self.testSuspend()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func goOnQueue() &#123;</span><br><span class="line">        queue.async &#123;</span><br><span class="line">            print(&quot;-----------继续下载视频-----------&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        queue.async &#123;</span><br><span class="line">            print(&quot;-----------继续下载音频-----------&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        queue.async &#123;</span><br><span class="line">            print(&quot;-----------继续下载弹幕-----------&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        let barrierTask &#x3D; DispatchWorkItem(qos: .default, flags: .barrier) &#123;</span><br><span class="line">            print(&quot;-----------下载完成，开始播放------------&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        queue.async(execute: barrierTask)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 挂起</span><br><span class="line">    func testSuspend() &#123;</span><br><span class="line">        index &#x3D; index + 1</span><br><span class="line">        queue.suspend()</span><br><span class="line">        print(&quot;-----------任务挂起-----------&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 唤醒</span><br><span class="line">    func testResume() &#123;</span><br><span class="line">        if index &#x3D;&#x3D; 1 &#123;</span><br><span class="line">            queue.resume()</span><br><span class="line">            index &#x3D;&#x3D; 0</span><br><span class="line">            print(&quot;-----------任务唤醒-----------&quot;)</span><br><span class="line">        &#125; else if index &lt; 1 &#123;</span><br><span class="line">            print(&quot;-----------唤醒次数超过挂起次数-----------&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            queue.resume()</span><br><span class="line">            index &#x3D; index - 1</span><br><span class="line">            print(&quot;-----------还需要\(index)才可以唤醒-----------&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let test &#x3D; SuspendAndResum()</span><br></pre></td></tr></table></figure>
<p>运行代码，最终打印的结果为： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----------模拟下载视频-----------</span><br><span class="line">-----------模拟下载音频-----------</span><br><span class="line">-----------模拟下载弹幕-----------</span><br><span class="line">-----------任务挂起-----------</span><br><span class="line">-----------任务唤醒-----------</span><br><span class="line">-----------继续下载视频-----------</span><br><span class="line">-----------继续下载音频-----------</span><br><span class="line">-----------继续下载弹幕-----------</span><br><span class="line">-----------下载完成，开始播放------------</span><br></pre></td></tr></table></figure>
<ul>
<li>(5)、一般一个队列都可以设置最大并发数，即使不设置GCD回根据当前系统的状态自动设置并发数。拿下载视频来说，我可以设置同时最大下载数，这样就可以控制同时进行的任务数。同时也可以通过信号量的方式来控制并发数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let queue &#x3D; DispatchQueue(label: &quot;com.tsn.demo.concurrentQueue&quot;, attributes: .concurrent)</span><br><span class="line">&#x2F;&#x2F; 设置最大并发数为5</span><br><span class="line">let semap &#x3D; DispatchSemaphore.init(value: 5)</span><br><span class="line">&#x2F;&#x2F; 信号量减1</span><br><span class="line">semap.wait()</span><br><span class="line">queue.async &#123;</span><br><span class="line">    &#x2F;&#x2F; 信号量加1</span><br><span class="line">    semap.signal()</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 信号量减1</span><br><span class="line">semap.wait()</span><br></pre></td></tr></table></figure>
<ul>
<li>(6)、我非常喜欢在睡前刷视频，这样我就有个需求，当我看完这个视频，比如说20分钟后就把视频关了，此时就用到了延迟任务（asyncAfter）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DispatchQueue.main.asyncAfter(deadline: .now() + 20 * 60) &#123;</span><br><span class="line">    print(&quot;-----------20分钟后关闭视频------------&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>(7)、我要查找出2020年所有新歌歌名里含有<code>爱</code>字的歌曲，由于要查找的数据源数据太多，采用遍历的方式效率并不是很好，此时就可以用到迭代任务（concurrentPerform）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 迭代任务</span><br><span class="line">let musicArray &#x3D; Array&lt;AnyObject?&gt;(repeating: nil, count: 1008611)</span><br><span class="line">DispatchQueue.concurrentPerform(iterations: 1008611) &#123; (index) in</span><br><span class="line">    print(&quot;-----------执行查找操作-----------&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5、任务组"><a href="#5、任务组" class="headerlink" title="5、任务组"></a>5、任务组</h3><p>任务组是将多个任务放到一个组里，<code>DispatchGroup</code>会等待组里面的任务都完成了之后通过<code>notify()</code>方法通知外部队列任务已全部完成。同时采用<code>enter()</code>和<code>leave()</code>配对方法，标识任务加入或离开任务组。</p>
<p>此处同样用下载视频来举例,将下载视频、音频、弹幕作为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建任务组</span><br><span class="line">let group &#x3D; DispatchGroup()</span><br><span class="line">&#x2F;&#x2F; 下载视频</span><br><span class="line">let videoQueue &#x3D; DispatchQueue(label: &quot;com.tsn.demo.video&quot;, attributes: .concurrent)</span><br><span class="line">videoQueue.async(group: group) &#123;</span><br><span class="line">    print(&quot;-----------开始下载视频-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 下载音频</span><br><span class="line">let audioQueue &#x3D; DispatchQueue.init(label: &quot;com.tsn.demo.audio&quot;, attributes: .concurrent)</span><br><span class="line">audioQueue.async(group: group) &#123;</span><br><span class="line">    print(&quot;-----------开始下载音频-----------&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 下载弹幕</span><br><span class="line">let bulletScreenQueue &#x3D; DispatchQueue.init(label: &quot;com.tsn.demo.audio&quot;, attributes: .concurrent)</span><br><span class="line">audioQueue.async(group: group) &#123;</span><br><span class="line">    print(&quot;-----------开始下载弹幕-----------&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>enter()</code>和<code>leave()</code>方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 进入任务组</span><br><span class="line">group.enter()</span><br><span class="line">videoQueue.async(group: group) &#123;</span><br><span class="line">    print(&quot;-----------开始下载视频-----------&quot;)</span><br><span class="line">    &#x2F;&#x2F; 退出任务组</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>notify()</code>方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 任务组通知</span><br><span class="line">group.notify(queue: .main) &#123;</span><br><span class="line">    print(&quot;-----------全部下载完成-----------&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>wait()</code>方法</li>
</ul>
<p>该方法会在所有任务完成后再执行当前线程中的后续代码，主要是起到阻塞线程的作用.同时也可以设置阻塞时间，如果所有任务都在指定时间内完成，否则等到时间结束后再恢复阻塞线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">group.wait()</span><br><span class="line">group.wait(timeout: .now() + 1)</span><br><span class="line">group.wait(wallTimeout: .now() + 1)</span><br></pre></td></tr></table></figure>
<blockquote>
<h3>6、DispatchSource</h3>
</blockquote>
<p><code>DispatchSource</code>用来监听系统底层一些对象的活动，当这些事件发生时，会自动向队列提交一个异步任务来处理这些事件。如我可以用<code>DispatchSource</code>监听电影是否成功下载到本地。</p>
<p><code>DispatchSource</code>的常用方法有:</p>
<ul>
<li>使用<code>makeFileSystemObjectSource、makeTimerSource</code>创建<code>source</code></li>
<li>通过<code>setEventHandler</code>方法设置监听</li>
<li>调用<code>resume()</code>方法开始监听</li>
<li>调用<code>setCancelHandler</code>方法取消监听</li>
</ul>
<p>一般也常用于创建计时器，示例代码，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var num &#x3D; 5</span><br><span class="line">let source: DispatchSourceTimer &#x3D; DispatchSource.makeTimerSource(flags: [], queue: .global())</span><br><span class="line">source.schedule(deadline: .now(), repeating: 1)</span><br><span class="line">&#x2F;&#x2F; 设置监听</span><br><span class="line">source.setEventHandler &#123;</span><br><span class="line">    num &#x3D; num - 1</span><br><span class="line">    if num &lt; 0 &#123;</span><br><span class="line">        source.cancel()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        print(&quot;num-----------\(num)-----------&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">source.resume()</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num-----------4-----------</span><br><span class="line">num-----------3-----------</span><br><span class="line">num-----------2-----------</span><br><span class="line">num-----------1-----------</span><br><span class="line">num-----------0-----------</span><br></pre></td></tr></table></figure>
<p>更多使用方法可参考<a href="https://developer.apple.com/documentation/dispatch/dispatchsource">Apple Developer DispatchSource</a></p>
<blockquote>
<h3>7、线程安全</h3>
</blockquote>
<p>多个线程同时访问同一个数据源时很容易引发数据错乱和数据安全问题，这就是线程安全要解决的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for index in 0..&lt;123 &#123;</span><br><span class="line">    queue.async &#123;</span><br><span class="line">        array.remove(at: index)</span><br><span class="line">        print(&quot;-----------\(index)-----------&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for index in 0..&lt;123 &#123;</span><br><span class="line">    queue.async &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        array.remove(at: index)</span><br><span class="line">        print(&quot;-----------\(index)-----------&quot;)</span><br><span class="line">        lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面的代码，虽然两段代码打印的结果是一样的，但是第一段代码是线程不安全的，第二段代码是安全的。</p>
<h4 id="7-1、线程死锁"><a href="#7-1、线程死锁" class="headerlink" title="7.1、线程死锁"></a>7.1、线程死锁</h4><p>一般指多个线程互相等待而造成的线程循环等待。常见的有线程死锁有：</p>
<ul>
<li>主队列同步</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 线程死锁</span><br><span class="line">DispatchQueue.main.sync &#123;</span><br><span class="line">    print(&quot;-----------死锁-----------&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>串行 + 同步 + 嵌套同步自身队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 串行队列 + 同步 嵌套自身同步</span><br><span class="line">let serialQueue &#x3D; DispatchQueue.init(label: &quot;com.tsn.LockTestClass&quot;)</span><br><span class="line">serialQueue.sync &#123;</span><br><span class="line">    serialQueue.async &#123;</span><br><span class="line">        print(&quot;-----------死锁-----------&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>串行 + 异步 + 嵌套同步自身队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 串行队列 + 异步 嵌套自身同步</span><br><span class="line">let serialQueue &#x3D; DispatchQueue.init(label: &quot;com.tsn.LockTestClass&quot;)</span><br><span class="line">serialQueue.async &#123;</span><br><span class="line">    serialQueue.async &#123;</span><br><span class="line">        print(&quot;-----------死锁-----------&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，Xcode会抛出crash。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: Execution was interrupted, reason: EXC_BAD_INSTRUCTION (code&#x3D;EXC_I386_INVOP, subcode&#x3D;0x0).</span><br></pre></td></tr></table></figure>
<p>得出结论：<strong>不要在串行或主队列中嵌套执行同步任务，才能有效避免线程死锁。</strong></p>
<h4 id="7-2、线程安全的一些概念"><a href="#7-2、线程安全的一些概念" class="headerlink" title="7.2、线程安全的一些概念"></a>7.2、线程安全的一些概念</h4><ul>
<li>临界区：就是一段代码不能被并发执行，也就是说两个线程不能同时执行同一段代码。</li>
<li>竞态条件：两个或多个线程读写某些共享数据，而最后的结果取决于额线程运行的精确时序。</li>
<li>优先级反转： </li>
</ul>
<p>如图所示，有多个不同优先级的线程，在第一个时间点，低优先级的线程获取到了锁的资源，在第二个时间点高优先级的线程去获取这个加了锁的资源，但是此时这个资源正被低优先级的线程持有，此时高优先级的线程就会被挂起并等待资源的释放。此时我的中优先级的线程不需要获取锁所以会比低优先级优先运行，低优先级的线程只能等待中优先级的线程执行完之后才能去执行，所以低优先级线程也被挂起等待中优先级线程执行完成后在执行。造成的结果就是中优先级的线程会执行的非常顺利，而高优先级和中优先级线程却不能按照预期执行。这种情况就是优先级反转。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/671ce35400ae4d3da1c129681df3c352~tplv-k3u1fbpfcp-watermark.image" alt="优先级反转"></p>
<ul>
<li>并发与并行</li>
</ul>
<p>这两个概念和手机内核有关，并发是指多个线程同时执行。<br>并发是指通过内部的算法，把多个线程的执行做切换，看起来像多个线程是同时执行的。</p>
<h4 id="7-3、各种不同的线程锁"><a href="#7-3、各种不同的线程锁" class="headerlink" title="7.3、各种不同的线程锁"></a>7.3、各种不同的线程锁</h4><p> <a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/">不再安全的 OSSpinLock</a>这篇文中列举了iOS中各种不同的锁及其性能比较。</p>
<ul>
<li>7.3.1、自旋锁 (Spin Lock）</li>
</ul>
<p>自旋锁，任意时刻只有一个线程能够获得锁，其他线程忙等待直到获得锁。SpinLock会一直检测是否获取某个锁，虽然效率很好，但是非常消耗系统内存。所以应该慎重使用。</p>
<ul>
<li>7.3.2、互斥锁（Mutex Lock）</li>
</ul>
<p>在<code>Objective-C</code>中可以用<code>@synchronized</code>来实现互斥锁。其本质是调用<code>objc_sync_enter</code>和<code>objc_sync_exit</code>方法。因此在Swift中互斥锁的实现方式是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)configMutex(id)lockData &#123;</span><br><span class="line">    @synchronized(lockData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func synchronized(lockData: AnyObject, ) &#123;</span><br><span class="line">   objc_sync_enter(lockData)</span><br><span class="line">   objc_sync_exit(lockData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考<a href="https://swifter.tips/lock/">猫神：LOCK</a></p>
<p>关于iOS中更多的线程锁可参考： <a href="https://juejin.cn/post/6844903446177382413">掘金 深入理解 iOS 开发中的锁</a></p>
<hr>
<p>本文主要整理了<strong>GCD</strong>的基础知识点和简单使用，如果有错误或不对的地方，欢迎指出和补充。</p>
<p>相关链接：</p>
<p> <a href="https://developer.apple.com/documentation/dispatch">Apple Developer Dispatch</a></p>
<p> <a href="https://developer.apple.com/documentation/dispatch">Apple Developer Concurrency Programming Guide</a></p>
<p> <a href="https://github.com/apple/swift-corelibs-libdispatch">GCD Apple官方源码</a></p>
<p> <a href="https://www.humancode.us/2014/08/14/target-queues.html">GCD Target Queues</a></p>
<p> <a href="https://time.geekbang.org/course/detail/100034001-161815">Swift核心技术与实战: 多线程</a></p>
<p> <a href="https://juejin.cn/post/6844903566398717960">掘金 iOS多线程：『GCD』详尽总结</a></p>
<p> <a href="https://github.com/dengfeng520/RPDemo/tree/main/GCD">本文demo</a></p>
]]></content>
  </entry>
  <entry>
    <title>Inherit from a Swift class in Objective C OC继承Swift类)</title>
    <url>/2020/07/15/OC%E7%BB%A7%E6%89%BFSwift%E7%B1%BB/</url>
    <content><![CDATA[<h6 align='right'>小时光</h6>

<p>搜到的相关资料基本来自这个帖子**<a href="https://stackoverflow.com/questions/35244592/inherit-from-a-swift-class-in-objective-c">Inherit from a Swift class in Objective C
</a>**。事实上一楼回复已经说的很明确了，<code>Objective-C</code>不能继承<code>Swift</code>类。</p>
<p><strong>Unfortunately, it’s not possible to subclass a Swift class in Objective-C. Straight from the docs:</strong></p>
<p>那么换个思路，为什么一定要用继承呢？用<code>category</code>可以吗？经过我的测试是可以的，代码如下： </p>
<p><strong>Swift文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">@objcMembers open class TestModel: NSObject &#123;</span><br><span class="line">    var testName: String &#x3D; String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>OC的.h文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">&#x2F;&#x2F; 桥接文件</span><br><span class="line">#import &quot;****-Swift.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface TestModel (Add)</span><br><span class="line">- (void)configTestName;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>OC的.m文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;TestModel+Add.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation TestModel (Add)</span><br><span class="line"></span><br><span class="line">- (void)configTestName &#123;</span><br><span class="line">    self.testName &#x3D; @&quot;12323&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Swift ARC(自动引用计数器)</title>
    <url>/2021/03/05/Swift%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    <content><![CDATA[<h6 align='right'>小时光</h6>



<p>Swift 采用ARC的方式来管理和追踪程序中的内存使用情况。ARC的全称（Automatic Reference Counting），一般叫做<strong>自动引用计数</strong>。在大多数情况下，开发者无需考虑内存管理问题，当不再需要使用实例对象时，ARC会自动释放这些内存。</p>
<p>ARC的引用计数一般应用于类的实例或闭包，而数组(Array)、字典(Dictionary)、字符串(String)、结构体(Structure)、枚举(enum)都是值类型，不是引用的方式来存储和传递的。官方文档的原文是：<code>Reference counting applies only to instances of classes. Structures and enumerations are value types, not reference types, and aren’t stored and passed by reference.</code></p>
<p>关于值类型和引用类型的区别，可参考官方博客：<a href="https://developer.apple.com/swift/blog/?id=10">Swift: Value and Reference Types</a></p>
<blockquote>
<h3 id="1、Swift中ARC是如何工作的"><a href="#1、Swift中ARC是如何工作的" class="headerlink" title="1、Swift中ARC是如何工作的"></a>1、Swift中ARC是如何工作的</h3></blockquote>
<h4 id="1-1、How-ARC-Works"><a href="#1-1、How-ARC-Works" class="headerlink" title="1.1、How ARC Works"></a>1.1、How ARC Works</h4><ul>
<li>每次创建一个类的实例，ARC就会自动为其分配内存，用来存储这个实例及其相关的属性</li>
<li>当该实例不再被使用时，ARC会释放这个实例所占用的内存</li>
<li>继续访问已释放的实例，如调用其方法或属性，那么可能会造成程序crash</li>
<li>为了解决访问已释放实例造成的crash问题，ARC会追踪每个引用当前实例累的属性、常量、和变量的数量。只要有一个有效的引用，ARC就不会释放这部分内存。</li>
<li>为此每次将一个类的实例赋值给一个属性（也可以是常量或变量）。这个属性就是这个实例的强引用。之所以称为强引用，是因为该属性强持有这个实例，并且只要这个强引用还存在，就不能销毁这个实例。</li>
</ul>
<p>用代码来说明，我有一个学生类，为其设置一个<code>name</code>属性用来保存这个学生的姓名，当我创建这类时，ARC会自动为这个类创建一部分空间用来保存<code>Student</code>实例及其属性。</p>
<p>为了更好的监听这个类的创建和销毁，我分别在<code>init</code>和<code>deinit</code>方法中通过打印来监听。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;init------------------Student&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;deinit------------------Student&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> studentTom: <span class="type">Student</span>? <span class="operator">=</span> <span class="type">Student</span>(name: <span class="string">&quot;Tom&quot;</span>) <span class="comment">// 引用计数为1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;init------------------Student&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，此时可以打看打印结果,说明此时的引用计数为1。此时没有释放这部分内存,如果我将这个实例直接置为nil呢</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">studentTom <span class="operator">=</span> <span class="literal">nil</span> <span class="comment">// 此时引用计数为0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;deinit------------------Student&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>当调用了<code>deinit</code>方法说明引用计数为0，ARC会自动释放该实例的内存。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> studentName <span class="operator">=</span> studentTom<span class="operator">!</span>.name</span><br></pre></td></tr></table></figure>
<p>当我把<code>studentTom</code>置为<code>nil</code>后，再次调用<code>studentTom</code>就会crash。Xcode同时会抛出一段异常:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">error: Execution was interrupted, reason: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=<span class="number">0x0</span>).</span><br></pre></td></tr></table></figure>
<p>为了防止出现这种情况，一般在使用可选类型(Optionals)时，应该优先做解析处理。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可选绑定解包</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> studentTom <span class="operator">=</span> studentTom &#123;</span><br><span class="line">    <span class="keyword">let</span> studentName <span class="operator">=</span> studentTom.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// guard 语法解包</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> studentTom <span class="operator">=</span> studentTom <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="keyword">let</span> studentName <span class="operator">=</span> studentTom.name</span><br></pre></td></tr></table></figure>
<p>如果因为需要我将该学生信息进行<code>copy</code>操作呢，此时引用计数就变成了2，为了验证我的猜想，修改代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> studentCopy: <span class="type">Student</span>? <span class="operator">=</span> studentTom <span class="comment">// 引用计数为2</span></span><br><span class="line">studentTom <span class="operator">=</span> <span class="literal">nil</span> <span class="comment">// 引用计数为1</span></span><br></pre></td></tr></table></figure>
<p>再次运行代码，发现并没有调用<code>deinit</code>方法，当我进行<code>copy</code>操作的时候，其引用计数就变成了2，这时候再置为<code>nil</code>其引用计数是1，ARC并没有释放其内存。此时需要将<code>studentCopy</code>的值置空，将其引用计数清空，ARC就会自动清理这部分内存。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">studentCopy <span class="operator">=</span> <span class="literal">nil</span> <span class="comment">// 引用计数为0</span></span><br><span class="line"><span class="keyword">deinit</span><span class="operator">------------------</span><span class="type">Student</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="2、循环引用"><a href="#2、循环引用" class="headerlink" title="2、循环引用"></a>2、循环引用</h3></blockquote>
<p>前面说ARC为了保证被使用实例对象不被提前释放，而采用了强引用的方式。那么针对这种情况，对开发者而言是否就一劳永逸了呢，答案是否定的，当两个实例之前形成强持有环时，这两个实例的内存就永远不会得到释放，这就需要开发者来做一些处理保证这部分内存能够在不需要时得到释放。</p>
<h4 id="2-1、循环引用是如何产生的"><a href="#2-1、循环引用是如何产生的" class="headerlink" title="2.1、循环引用是如何产生的"></a>2.1、循环引用是如何产生的</h4><ul>
<li><p>两个实例彼此保持对方的强引用，使得每个实例都使对方的保持有效时会发生循环引用。</p>
<p>举例，现在我有一个老师类，对于老师和学生而言，老师要知道学生的信息，学生也要知道老师的信息，如老师的姓氏，所教授的课程等。</p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示老师所教授的课程 </span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> language <span class="comment">// 语文</span></span><br><span class="line">    <span class="keyword">case</span> english <span class="comment">// 英语</span></span><br><span class="line">    <span class="keyword">case</span> calculus <span class="comment">// 微积分</span></span><br><span class="line">    <span class="keyword">case</span> quantumMechanics <span class="comment">// 量子力学</span></span><br><span class="line">    <span class="keyword">case</span> geology <span class="comment">// 地质学</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> course: <span class="type">Course</span></span><br><span class="line">    <span class="keyword">var</span> student: <span class="type">Student</span>?</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">lastName</span>: <span class="type">String</span>, <span class="params">course</span>: <span class="type">Course</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.lastName <span class="operator">=</span> lastName</span><br><span class="line">        <span class="keyword">self</span>.course <span class="operator">=</span> course</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;init------------------Teacher&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;deinit------------------Teacher&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> teacher: <span class="type">Teacher</span>?</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;init------------------Student&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;deinit------------------Student&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> studentTom: <span class="type">Student</span>? <span class="operator">=</span> <span class="type">Student</span>(name: <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> teacherMars: <span class="type">Teacher</span>? <span class="operator">=</span> <span class="type">Teacher</span>(lastName: <span class="string">&quot;Mars&quot;</span>, course: .calculus)</span><br><span class="line"></span><br><span class="line">teacherMars<span class="operator">?</span>.student <span class="operator">=</span> studentTom</span><br><span class="line">studentTom<span class="operator">?</span>.teacher <span class="operator">=</span> teacherMars</span><br><span class="line"></span><br><span class="line">teacherMars <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">studentTom <span class="operator">=</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>运行上面的代码，发现无论如何都不会调用<code>deinit</code>方法。是因为他们各自引用这自己的对象，<code>studentTom</code>的<code>teacher</code>和<code>seacherMars</code>的<code>student</code>属性又相互引用了对方，此时在他们的引用计数都变成了2，于是就造成一个引用循环。他们之间的引用关系如下图所示：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5088863b043b449e8aae6343b3f0042d~tplv-k3u1fbpfcp-watermark.image" alt="强引用环"></p>
<h4 id="2-2、如何避免循环引用"><a href="#2-2、如何避免循环引用" class="headerlink" title="2.2、如何避免循环引用"></a>2.2、如何避免循环引用</h4><p>为了解决上面的引用循环问题，根据属性是否可选而采取不同的解决方案，当属性为可选时可以用<code>weak</code>关键字修饰，表示该属性为弱引用。当属性不可选时，可以用<code>unowned</code>关键字来修饰。无论是<code>weak</code>还是<code>unowned</code>,他们的思路都是一样的，不让某种形式的引用增加引用计数就好了。</p>
<h5 id="2-2-1-弱引用"><a href="#2-2-1-弱引用" class="headerlink" title="2.2.1 弱引用"></a>2.2.1 弱引用</h5><p>在上面的例子中，只需对任意一个属性设置为弱引用即可，当然也可以把两个属性都设置为<code>weak</code>,不过没有这么做的必要。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> student: <span class="type">Student</span>?</span><br></pre></td></tr></table></figure>
<p>此时两个实例之间的关系图如下所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10cee926d7674210b00b14c5642830ae~tplv-k3u1fbpfcp-watermark.image" alt="弱引用"></p>
<p>当我在弱引用下来释放<code>studentTom</code>的内存时，会是什么结果呢此时两个实例之间的关系如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">studentTom <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">teacherMars<span class="operator">?</span>.student</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;------------------<span class="subst">\(String(describing: teacherMars<span class="operator">?</span>.student))</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span><span class="operator">------------------</span><span class="type">Student</span></span><br><span class="line"><span class="keyword">init</span><span class="operator">------------------</span><span class="type">Teacher</span></span><br><span class="line"><span class="keyword">deinit</span><span class="operator">------------------</span><span class="type">Student</span></span><br><span class="line"><span class="operator">------------------</span><span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>通过上面打印的结果来看，<code>studentTom</code>实例的内存顺利释放了，那么当<code>studentTom</code>为<code>nil</code>时，ARC根据当前的情况进行了操作呢？</p>
<ul>
<li>首先<code>Student</code>对象就不再有任何<code>strong reference</code>了，<code>ARC</code>会立即回收这部分内存，同时<code>Teacher</code>对象的引用计数也会减一；</li>
<li>其次当<code>Student</code>对象被回收调之后，<code>teacher</code>这个<code>strong reference</code>也就不存在了。<code>Teacher</code>的引用计数就会减一；</li>
<li>由于<code>student</code>是一个<code>weak reference</code>,它的值会自动设置为<code>nil</code>，通过<code>teacherMars?.student</code>打印的结果为<code>nil</code>可以确认这一点。</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c0565838b5241329594ef698da722f4~tplv-k3u1fbpfcp-watermark.image" alt="弱引用01"></p>
<p>当我将其中任意一个属性设置为弱引用后，这时候把<code>teacherMars</code>和<code>studentTom</code>都设置为<code>nil</code>，<code>ARC</code>就能过顺利回收所有的内存，此时他们的关系如图所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">teacherMars <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">studentTom <span class="operator">=</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span><span class="operator">------------------</span><span class="type">Student</span></span><br><span class="line"><span class="keyword">init</span><span class="operator">------------------</span><span class="type">Teacher</span></span><br><span class="line"><span class="keyword">deinit</span><span class="operator">------------------</span><span class="type">Student</span></span><br><span class="line"><span class="operator">------------------</span><span class="literal">nil</span></span><br><span class="line"><span class="keyword">deinit</span><span class="operator">------------------</span><span class="type">Teacher</span></span><br></pre></td></tr></table></figure>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e685f24e6354696a9f99c2e1707b08c~tplv-k3u1fbpfcp-watermark.image" alt="弱引用02"></p>
<p>关于如何使用<code>weak</code>修饰的属性总结：</p>
<ul>
<li>弱引用不会增加实例的引用计数，因此不会阻止ARC销毁被引用的实例。所以使用弱引用后，即使两个实例互相持有也不会形成强引用环。</li>
<li>弱引用只能申明为变量类型，因为运行时他的值可能会改变。弱引用绝对不能申明为常量。在Swift中，用var关键字申明的为变量，用let关键字申明的为常量。</li>
<li>因为弱引用可以没有值，用弱引用来修饰的变量必须是<strong>可选类型</strong>。</li>
</ul>
<h5 id="2-2-3-无主引用"><a href="#2-2-3-无主引用" class="headerlink" title="2.2.3 无主引用"></a>2.2.3 无主引用</h5><p>虽然<code>weak</code>解决了循环引用的问题，但是不是所有的属性都是可选的，如果有一个不可以为<code>nil</code>的属性造成了循环引用，该怎么办呢？</p>
<ul>
<li>我可以把这个不可为<code>nil</code>的属性修改为可以为<code>nil</code></li>
<li>采用Swift为开发者提供的另一种解决方案，使用无主引用</li>
</ul>
<p>和弱引用相似，无主引用也不强制有实例对象。<strong>和弱引用不同的是，无主引用默认始终有值</strong>。在属性和变量前添加<code>unowned</code>关键字，就可以申明一个无主引用。</p>
<p>为了演示这个过程，我为每个学生添加了家庭作业<code>homeWork</code>属性，当然并不是所有的学生都会按时写作业，所以<code>homeWork</code>的类型是<code>optional</code>,然后来实现<code>HomeWork</code>类；</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 家庭作业</span></span><br><span class="line"><span class="keyword">var</span> homeWork: <span class="type">HomeWork</span>?</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeWork</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> student: <span class="type">Student</span></span><br><span class="line">    <span class="keyword">let</span> course: <span class="type">Course</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">student</span>: <span class="type">Student</span>, <span class="params">course</span>: <span class="type">Course</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.student <span class="operator">=</span> student</span><br><span class="line">        <span class="keyword">self</span>.course <span class="operator">=</span> course</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;init------------------HomeWork&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;deinit------------------HomeWork&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里既然有了家庭作业，那么我就要知道是谁写的，是哪门课程的作业,这里<code>studentName</code>和<code>course</code>就不能是一个<code>optional</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> david: <span class="type">Student</span>? <span class="operator">=</span> <span class="type">Student</span>(name: <span class="string">&quot;David Taylor&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> homeWork: <span class="type">HomeWork</span>? <span class="operator">=</span> <span class="type">HomeWork</span>(student: david<span class="operator">!</span>, course: .quantumMechanics)</span><br></pre></td></tr></table></figure>
<p>此处假设学生<code>david</code>完成了作业，那么可以用下面的代码来表示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">david<span class="operator">?</span>.homeWork <span class="operator">=</span> homeWork </span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span><span class="operator">------------------</span><span class="type">Student</span></span><br><span class="line"><span class="keyword">init</span><span class="operator">------------------</span><span class="type">HomeWork</span></span><br></pre></td></tr></table></figure>
<p>运行代码，发现并没有调用<code>deinit</code>方法，此时学生<code>david</code>和<code>homeWork</code>就形成了一个引用循环，他们之间的持有的关系是<code>david</code>和<code>homeWork</code>各自引用着自己的对象，<code>david</code>和<code>homeWork</code>互相引用着彼此。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/700cecb6aa074c93977d467e22d704d5~tplv-k3u1fbpfcp-watermark.image" alt="homeWork"></p>
<p>那么此时，我将<code>david</code>置为<code>nil</code>呢？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">david <span class="operator">=</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init------------------Student</span><br><span class="line">init------------------HomeWork</span><br></pre></td></tr></table></figure>
<p>运行代码，发现依旧没有调用<code>deinit</code>方法，此时虽然<code>david</code>实例为<code>nil</code>,实例<code>homeWork</code>也离开了自己的作用域。此时在内存中<code>david.homeWork</code>和<code>homeWork.student</code>之间的引用关系依旧会把这两个对象保持在内存中,他们关系如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7524800de1b34c93b9cf7e791a32110b~tplv-k3u1fbpfcp-watermark.image" alt="homework002"></p>
<p>当然此处可以使用<code>weak</code>关键字将其中任意一个强持有改成弱引用来解决这个问题。此处也可以使用系统提供的另一种解决方案：**非可选类型的属性前加<code>unowned</code>**，无主引用解决循环引用问题。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unowned</span> <span class="keyword">let</span> student: <span class="type">Student</span></span><br></pre></td></tr></table></figure>
<p>我们可以将任意一个强引用的属性前加<code>unowned</code>,就可以解决这个问题，唯一不同的是<code>Strong reference</code>变成了<code>unowned reference</code>,此时他们之间的引用关系是:</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a606dcd64e2048318a00a4bc076bb4dd~tplv-k3u1fbpfcp-watermark.image" alt="Homework003"></p>
<p>这时候再次运行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">david <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">homeWork <span class="operator">=</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span><span class="operator">------------------</span><span class="type">Student</span></span><br><span class="line"><span class="keyword">init</span><span class="operator">------------------</span><span class="type">HomeWork</span></span><br><span class="line"><span class="keyword">deinit</span><span class="operator">------------------</span><span class="type">Student</span></span><br><span class="line"><span class="keyword">deinit</span><span class="operator">------------------</span><span class="type">HomeWork</span></span><br></pre></td></tr></table></figure>
<p>可以看到<code>david</code>和<code>homeWork</code>都可以正常的被回收了，当<code>david</code>为<code>nil</code>时<code>Student</code>对象就会被ARC回收，而当<code>homeWork</code>为<code>nil</code>时，<code>homeWork</code>也就失去了他的作用也会被ARC回收其内存。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3075905820d4e6cb692f4fd2cea1f93~tplv-k3u1fbpfcp-watermark.image" alt="homewirkoo4"></p>
<p>如果我调用被释放的内存之后会怎样呢？修改代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">homeWork &#x3D; nil</span><br><span class="line">homeWork!.student</span><br></pre></td></tr></table></figure>
<p>程序执行时会crash并提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unexpectedly found nil while unwrapping an Optional value</span><br></pre></td></tr></table></figure>
<p>所以使用<code>unowned</code>虽然能解决不可选属性循环引用问题，但在实际开发中也应该注意<strong>在使用无主引用时要确保引用始终指向一个未销毁的实例</strong>。</p>
<p>虽然使用<code>weak</code>和<code>unowned</code>解决了<code>Class</code>中的强引用循环问题，但是<code>Class</code>并不是Swift中唯一的引用类型，Swift中<code>func、Closures</code>也是引用类型，至于<code>Closures</code>如何解决内存管理问题，可参考官方文档<a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">The Swift Programming Language: Closures</a>。</p>
<hr>
<p>本文参考：</p>
<p><a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html">《The Swift Programming Language》Automatic Reference Counting</a></p>
<p><a href="https://www.swiftbysundell.com/articles/handling-non-optional-optionals-in-swift/">Handling non-optional optionals in Swift</a></p>
<p><a href="https://time.geekbang.org/course/detail/100034001-165161">Swift中的自动引用计数</a></p>
<p><a href="https://boxueio.com/series/understand-ref-types">理解引用语义的自定义类型</a></p>
<p><a href="https://github.com/dengfeng520/RPDemo/tree/main/ARC/">本文demo</a></p>
]]></content>
  </entry>
  <entry>
    <title>被误解的inout</title>
    <url>/2021/03/17/%E8%A2%AB%E8%AF%AF%E8%A7%A3%E7%9A%84inout/</url>
    <content><![CDATA[<h6 align='right'>小时光</h6>
<h6 align='right'><a href='https://dengfeng520.github.io/'>我的博客</a></h6>

<p>在Swift中，函数的参数默认都是常量是不可以修改的，如果我需要在函数内部修改函数的某个参数，或者通过参数返回内容，就需要用<code>inout</code>关键字来修饰这个参数，在调用时在这个参数前加上<code>&amp;</code>即可。</p>
<p>如老师需要为学生的笔试成绩加上30分的平时成绩，就需要用到<code>inout</code>参数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">configStudent</span>(<span class="keyword">_</span> <span class="params">fraction</span>: <span class="keyword">inout</span> <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fraction <span class="operator">+</span> <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num <span class="operator">=</span> <span class="number">53</span></span><br><span class="line">configStudent(<span class="operator">&amp;</span>num)</span><br></pre></td></tr></table></figure>
<p>这里的<code>&amp;num</code>写法，在其他C系列语言中，如<code>C/C++</code>和<code>Objective-C</code>中，一般会认为是在传递变量的指针。实际上我在此之前也是这么认为的，直到在读到<a href="https://docs.swift.org/swift-book/">官方文档</a>函数部分章节后才知道其实<code>inout</code>关键字的用途并非如此。</p>
<h4 id="1、inout-只是-in-out"><a href="#1、inout-只是-in-out" class="headerlink" title="1、inout 只是 in - out"></a>1、inout 只是 in - out</h4><p>在官方文档中是这样说的：</p>
<p><code>You write an in-out parameter by placing the inout keyword right before a parameter’s type. An in-out parameter has a value that’s passed in to the function, is modified by the function, and is passed back out of the function to replace the original value. </code></p>
<p>文档上这里说的很明确，<code>inout</code>就是把参数传递给函数，被函数修改之后再替换初始值。也就是说<code>inout</code>就只是简单的<code>in-out</code>而没有其他的意思。</p>
<h4 id="2、inout的使用"><a href="#2、inout的使用" class="headerlink" title="2、inout的使用"></a>2、inout的使用</h4><h6 id="2-1、变量可以、常量不可以"><a href="#2-1、变量可以、常量不可以" class="headerlink" title="2.1、变量可以、常量不可以"></a>2.1、变量可以、常量不可以</h6><ul>
<li> 使用<code>inout</code>只能修饰变量</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">configStudent</span>(<span class="keyword">_</span> <span class="params">fraction</span>: <span class="keyword">inout</span> <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fraction <span class="operator">+</span> <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> num <span class="operator">=</span> <span class="number">53</span></span><br><span class="line">configStudent(<span class="operator">&amp;</span>num)</span><br></pre></td></tr></table></figure>
<p>在编译的时候，系统会直接报错<code>Cannot pass immutable value as inout argument: &#39;num&#39; is a &#39;let&#39; constant</code></p>
<p>修改代码<code>var num = 53</code>编译成功，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="operator">=</span> <span class="number">53</span></span><br><span class="line">configStudent(<span class="operator">&amp;</span>num)</span><br></pre></td></tr></table></figure>
<h6 id="2-2、可变数组中的常量也可以用inout"><a href="#2-2、可变数组中的常量也可以用inout" class="headerlink" title="2.2、可变数组中的常量也可以用inout"></a>2.2、可变数组中的常量也可以用<code>inout</code></h6><p>但是同样的，如果我修改一个可变数组中的参数吗？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testArray <span class="operator">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">testArray[<span class="number">1</span>] <span class="operator">=</span> configStudent(<span class="operator">&amp;</span>testArray[<span class="number">1</span>]) <span class="comment">// [1, 32, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p>编译代码，正常运行，说明数组中的下标操作也可以使用<code>inout</code>来修饰参数。</p>
<h6 id="2-3、自定义类型属性使用inout关键字"><a href="#2-3、自定义类型属性使用inout关键字" class="headerlink" title="2.3、自定义类型属性使用inout关键字"></a>2.3、自定义类型属性使用<code>inout</code>关键字</h6><p>如我现在要记录学生在上课签到时的位置，在得到学生的位置信息后再做一次校正处理，使用自定义类型，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Location</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lat: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> lon: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">configLocation</span>(<span class="keyword">_</span> <span class="params">num</span>: <span class="keyword">inout</span> <span class="type">Double</span>)</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(num <span class="operator">+</span> <span class="number">0.01</span>)</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">var</span> location <span class="operator">=</span> <span class="type">Location</span>(lat: <span class="number">37.33020</span>, lon: <span class="operator">-</span><span class="number">122.024348</span>)</span><br><span class="line">configLocation(<span class="operator">&amp;</span>location.lat)</span><br></pre></td></tr></table></figure>
<p>编译代码，正常运行。</p>
<p>使用上面的代码，我在得到学生的位置不仅要知道经纬度,还想知道这个学生的平时成绩，一般默认情况下老师会给所有学生设置平时成绩为30分，新增<code>fraction</code>属性作为平时成绩，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Location</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lat: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> lon: <span class="type">Double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> fraction: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">configFraction</span>(<span class="keyword">_</span> <span class="params">fraction</span>: <span class="keyword">inout</span> <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fraction <span class="operator">+</span> <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line">configFraction(<span class="operator">&amp;</span>location.fraction)</span><br></pre></td></tr></table></figure>
<p>此时我再次运行代码，编译时直接报错: <code>Cannot pass immutable value as inout argument: &#39;fraction&#39; is a get-only property</code>,也就是说对于自定义类的只读属性，不能使用<code>inout</code>参数；</p>
<p> 最终的结论是：<strong>自定义类型的属性同时有<code>get</code>和<code>set</code>方法，也可以作为<code>inout</code>参数。自定义类型中的只读属性不能使用<code>inout</code>参数</strong></p>
<hr>
<p>本文主要说了我曾经对<code>inout</code>修饰参数的一些误解，及<code>inout</code>修饰参数的使用，如果有不对的地方请指出。</p>
<p>本文参考:<a href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html">The Swift Programming Language：Functions</a></p>
<p><a href="https://github.com/dengfeng520/RPDemo/tree/main/Closures">本文代码</a></p>
]]></content>
  </entry>
  <entry>
    <title>Swift Closures</title>
    <url>/2021/03/25/Swift%20Closures/</url>
    <content><![CDATA[<h6 align='right'>小时光</h6>
<h6 align='right'><a href='https://dengfeng520.github.io/'>我的博客</a></h6>

<h3 id="1、What’s-the-closure"><a href="#1、What’s-the-closure" class="headerlink" title="1、What’s the closure?"></a>1、What’s the closure?</h3><p>作为<code>iOS</code>开发者对于<code>Objective-C</code>中的<code>Block</code>一定非常熟悉，在其他开发语言中，也把<code>closure</code>也称作<code>lambdas</code>等。简答来说，闭包就是一个独立的函数，一般用于捕获和存储定义在其上下文中的任何常量和变量的引用。</p>
<p><code>closure</code>的语法如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123; (parameters) -&gt; <span class="keyword">return</span> type <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>closure</code>能够使用常量形式参数、变量形式参数和输入输出形式的参数，但不能设置默认值。可变形式参数也可以使用，但需要在行参列表的最后使用。元组也可以被用来作为形式参数和返回类型。</p>
<p>实际上全局函数和内嵌函数也是一种特殊的闭包，（关于函数的相关概念可参考官方文档<a href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html">The Swift Programming Language: Functions</a>），闭包会根据其捕获值的情况分为三种形式：</p>
<ul>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>内嵌函数是一个有名字且能从其上层函数捕获值的闭包</li>
<li>闭包表达式是一个轻量级语法所写的可以捕获其上下文中常量或变量值的没有名字的闭包</li>
</ul>
<h3 id="2、各种不同类型的闭包"><a href="#2、各种不同类型的闭包" class="headerlink" title="2、各种不同类型的闭包"></a>2、各种不同类型的闭包</h3><p>如果需要将一个很长的闭包表达式作为函数最后一个实际参数传递给函数，使用尾随闭包将增强函数的可读性。尾随闭包一般作为函数行参使用。如系统提供的<code>sorted</code>,<code>map</code>等函数就是一个尾随闭包。</p>
<h5 id="2-1、尾随闭包（Trailing-Closure）"><a href="#2-1、尾随闭包（Trailing-Closure）" class="headerlink" title="2.1、尾随闭包（Trailing Closure）"></a>2.1、尾随闭包（Trailing Closure）</h5><p>尾随闭包虽然写在函数调用的括号之后，但仍是函数的参数。使用尾随闭包是，不要将闭包的参数标签作为函数调用的一部分。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strList <span class="operator">=</span> [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> numList: [<span class="type">Int</span>] <span class="operator">=</span> strList.map &#123; (num) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>(num) <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-2、逃逸闭包-（Escaping-Closure）"><a href="#2-2、逃逸闭包-（Escaping-Closure）" class="headerlink" title="2.2、逃逸闭包 （Escaping Closure）"></a>2.2、逃逸闭包 （Escaping Closure）</h5><p>当闭包作为一个实际参数传递给一个函数的时候，并且它会在函数返回之后调用，我们就说这个闭包逃逸，一般用<code> @escaping</code>修饰的函数形式参数来标明逃逸闭包。</p>
<ul>
<li>逃逸闭包一般用于异步任务的回调</li>
<li>逃逸闭包在函数返回之后调用</li>
<li>让闭包<code> @escaping</code>意味着必须在闭包中显式地引用self</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 逃逸闭包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestServer</span>(<span class="params">with</span> <span class="params">URL</span>: <span class="type">String</span>,<span class="params">parameter</span>: <span class="keyword">@escaping</span>(<span class="type">AnyObject</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尾随闭包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestServerTrailing</span>(<span class="params">losure</span>: () -&gt; <span class="type">Void</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EscapingTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">request</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 尾随闭包</span></span><br><span class="line">        requestServerTrailing &#123;</span><br><span class="line">            x <span class="operator">=</span> x <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逃逸闭包</span></span><br><span class="line">        requestServer(with: <span class="string">&quot;&quot;</span>) &#123; (obj, error) <span class="keyword">in</span></span><br><span class="line">            x <span class="operator">=</span> x <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Reference</span> to property &#x27;x&#x27; <span class="keyword">in</span> closure requires explicit use of &#x27;<span class="keyword">self</span>&#x27; to make capture semantics explicit</span><br></pre></td></tr></table></figure>
<p>修改代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">requestServer(with: <span class="string">&quot;&quot;</span>) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (obj, error) <span class="keyword">in</span></span><br><span class="line">     <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> <span class="operator">=</span> `self` <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">self</span>.x <span class="operator">=</span> <span class="keyword">self</span>.x <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>逃逸闭包的实际使用</li>
</ul>
<p>如我要设计一个下载图片管理类，异步下载图片下载完成后再返回主界面显示，这里就可以使用逃逸闭包来实现，核心代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DownLoadImageManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单例</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance <span class="operator">=</span> <span class="type">DownLoadImageManager</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.tsn.demo.escapingClosure&quot;</span>, attributes: .concurrent)</span><br><span class="line">    <span class="comment">// 逃逸闭包</span></span><br><span class="line">    <span class="comment">// path: 图片的URL</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">downLoadImageWithEscapingClosure</span>(<span class="params">path</span>: <span class="type">String</span>, <span class="params">completionHandler</span>: <span class="keyword">@escaping</span>(<span class="type">UIImage</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>)</span> &#123;</span><br><span class="line">        queue.async &#123;</span><br><span class="line">            <span class="type">URLSession</span>.shared.dataTask(with: <span class="type">URL</span>(string: path)<span class="operator">!</span>) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error &#123;</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;error===============<span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">                    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                        completionHandler(<span class="literal">nil</span>, error)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">guard</span> <span class="keyword">let</span> responseData <span class="operator">=</span> data, <span class="keyword">let</span> image <span class="operator">=</span> <span class="type">UIImage</span>(data: responseData) <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                        completionHandler(image, <span class="literal">nil</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.resume()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保证init方法在外部不会被调用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下载图片并显示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> path <span class="operator">=</span> <span class="string">&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_match%2F0%2F12056372662%2F0.jpg&amp;refer=http%3A%2F%2Finews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1618456758&amp;t=3df7a5cf69ad424954badda9bc7fc55f&quot;</span></span><br><span class="line"><span class="type">DownLoadImageManager</span>.sharedInstance.downLoadImageWithEscapingClosure(path: path) &#123; (image: <span class="type">UIImage</span>?, error: <span class="type">Error</span>?) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;error===============<span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> image <span class="operator">=</span> image <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;图片下载完成，显示图片: <span class="subst">\(image)</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> imageView <span class="operator">=</span> <span class="type">UIImageView</span>(image: image)</span><br><span class="line">        imageView.layer.cornerRadius <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffc81edc75454b09bb6195ecd8ae6f66~tplv-k3u1fbpfcp-watermark.image" alt="下载图片并展示"></p>
<p>以上的代码虽然能够完成对图片的下载管理，事实上在项目中下载并显示一张图片的处理要复杂的多，这里不做更多赘述，可参考官方的demo: <a href="https://developer.apple.com/documentation/uikit/uiimage/asynchronously_loading_images_into_table_and_collection_views">Asynchronously Loading Images into Table and Collection Views</a></p>
<h5 id="2-3、自动闭包-（Auto-Closure）"><a href="#2-3、自动闭包-（Auto-Closure）" class="headerlink" title="2.3、自动闭包 （Auto Closure）"></a>2.3、自动闭包 （Auto Closure）</h5><ul>
<li>自动闭包是一种自动创建的用来把座位实际参数传递给函数的表达式打包的闭包</li>
<li>自动闭包不接受任何参数，并且被调用时，会返回内部打包的表达式的值</li>
<li>自动闭包能过省略闭包的大括号，用一个普通的表达式来代替显式的闭包</li>
<li>自动闭包允许延迟处理，因此闭包内部的代码直到调用时才会运行。对于有副作用或者占用资源的代码来说很用</li>
</ul>
<p>如我有个家庭作业管理类，老师需要统计学生上交的作业同时处理批改后的作业，为了演示自动闭包，我用以下的代码来实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> spacePhysics <span class="comment">// 空间物理</span></span><br><span class="line">    <span class="keyword">case</span> nuclearPhysics <span class="comment">// 原子核物理</span></span><br><span class="line">    <span class="keyword">case</span> calculus <span class="comment">// 微积分</span></span><br><span class="line">    <span class="keyword">case</span> quantumMechanics <span class="comment">// 量子力学</span></span><br><span class="line">    <span class="keyword">case</span> geology <span class="comment">// 地质学</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="type">String</span>()</span><br><span class="line">    <span class="keyword">var</span> course: <span class="type">Course</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">course</span>: <span class="type">Course</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.course <span class="operator">=</span> course</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MARK: - 自动闭包</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> studentInfoArray: [<span class="type">StudentModel</span>] <span class="operator">=</span> [<span class="type">StudentModel</span>]()</span><br><span class="line">    <span class="comment">// 某个学生交了作业</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">autoAddWith</span>(<span class="keyword">_</span> <span class="params">student</span>: <span class="keyword">@autoclosure</span>() -&gt; <span class="type">StudentModel</span>)</span> &#123;</span><br><span class="line">        studentInfoArray.append(student())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 老师批改完了某个学生的作业</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">autoDeleteWith</span>(<span class="keyword">_</span> <span class="params">index</span>: <span class="keyword">@autoclosure</span>() -&gt; <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        studentInfoArray.remove(at: index())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>autoAddWith</code>表示学生某个学生交了作业，<code>autoDeleteWith</code>表示老师批改完了某个学生的作业。一般调用方式为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> studentManager: <span class="type">StudentManager</span> <span class="operator">=</span> <span class="type">StudentManager</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kate Bell 交了作业</span></span><br><span class="line">studentManager.autoAddWith(<span class="type">StudentModel</span>(name: <span class="string">&quot;Kate Bell&quot;</span>, course: .spacePhysics))</span><br><span class="line"><span class="comment">// Kate Bell 交了作业</span></span><br><span class="line">studentManager.autoAddWith(<span class="type">StudentModel</span>(name: <span class="string">&quot;Kate Bell&quot;</span>, course: .nuclearPhysics))</span><br><span class="line"><span class="comment">// Anna Haro 交了作业</span></span><br><span class="line">studentManager.autoAddWith(<span class="type">StudentModel</span>(name: <span class="string">&quot;Anna Haro&quot;</span>, course: .calculus))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 老师批改完了第一份作业</span></span><br><span class="line">studentManager.autoDeleteWith(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h5 id="2-4、自动-逃逸-（Autoclosure-Escaping-）"><a href="#2-4、自动-逃逸-（Autoclosure-Escaping-）" class="headerlink" title="2.4、自动 + 逃逸 （Autoclosure + Escaping ）"></a>2.4、自动 + 逃逸 （Autoclosure + Escaping ）</h5><p>如果想要自动闭包逃逸，可以同时使用<code>@autoclosure</code>和<code>@escaping</code>来标志。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">autoAddWith</span>(<span class="keyword">_</span> <span class="params">student</span>: <span class="keyword">@autoclosure</span> <span class="keyword">@escaping</span>() -&gt; <span class="type">StudentModel</span>)</span> &#123;</span><br><span class="line">    studentInfoArray.append(student())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、闭包捕获值"><a href="#3、闭包捕获值" class="headerlink" title="3、闭包捕获值"></a>3、闭包捕获值</h3><p>前面简单介绍了<strong>尾随闭包、逃逸闭包、自动闭包</strong>的概念和基本使用，这里来说闭包是如何捕获值的。在Swift中，值类型变量一般存储于栈（Stack）中，而像<code>func class closure</code>等引用类型存储于堆(Heap)内存中。而<code>closure</code>捕获值<strong>本质上是将存在栈(Stack)区的值存储到堆(Heap)区</strong>。</p>
<p>为了验证<code>closure</code>可以捕获哪些类型的值，用下面的代码做一个测试：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> test <span class="operator">=</span> <span class="type">String</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 常量</span></span><br><span class="line"><span class="keyword">let</span> index <span class="operator">=</span> <span class="number">10086</span></span><br><span class="line"><span class="comment">// 变量</span></span><br><span class="line"><span class="keyword">var</span> number <span class="operator">=</span> <span class="number">1008611</span></span><br><span class="line"><span class="comment">// 引用类型</span></span><br><span class="line"><span class="keyword">let</span> demo <span class="operator">=</span> <span class="type">Demo</span>()</span><br><span class="line"><span class="keyword">var</span> capturel <span class="operator">=</span> &#123;</span><br><span class="line">    number <span class="operator">=</span> <span class="number">1008611</span> <span class="operator">-</span> <span class="number">998525</span></span><br><span class="line">    demo.test <span class="operator">=</span> <span class="string">&quot;block test&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;index==========<span class="subst">\(index)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;number==========<span class="subst">\(number)</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;demo.test==========<span class="subst">\(demo.test)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">number <span class="operator">=</span> number <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">demo.test <span class="operator">=</span> <span class="string">&quot;test&quot;</span></span><br><span class="line">capturel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="comment">// index==========10086</span></span><br><span class="line"><span class="comment">// number==========10086</span></span><br><span class="line"><span class="comment">// demo.test==========block test</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，无论是常量、变量、还是引用类型调用<code>capturel()</code>后都可以正常打印数据。 无论是常量、变量、值类型还是引用类型，<code>Closure</code>都可捕获其值。事实上在Swift中作为优化<strong>当<code>Closure</code>中并没有修改或者在闭包的外面的值时，Swift可能会使用这个值的copy而不是捕获</strong>。同时Swift也处理了变量的内存管理操作，当变量不再需要时会被释放。</p>
<p>在来看一个实现递增的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementer</span>(<span class="keyword">_</span> <span class="params">amount</span>: <span class="type">Int</span>)</span> -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">// 内嵌函数 也是一种特殊的Closure</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">incrementerClosure</span>()</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        total <span class="operator">=</span> total <span class="operator">+</span> amount</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incrementerClosure</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中,<code>incrementerClosure</code>中捕获了<code>total</code>值，当我返回<code>incrementerClosure</code>时，理论上包裹<code>total</code>的函数就不存在了，但是<code>incrementerClosure</code>仍然可以捕获<code>total</code>值。可以得出结论：<strong>即使定义这些变量或常量的原作用域已经不存在了，但<code>closure</code>依旧能捕获这个值</strong>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementerTen <span class="operator">=</span> makeIncrementer(<span class="number">10</span>) <span class="comment">// () -&gt; Int</span></span><br><span class="line">incrementerTen() <span class="comment">// 10</span></span><br><span class="line">incrementerTen() <span class="comment">// 20</span></span><br><span class="line">incrementerTen() <span class="comment">// 30</span></span><br><span class="line"><span class="keyword">let</span> incrementerSix <span class="operator">=</span> makeIncrementer(<span class="number">6</span>) <span class="comment">// () -&gt; Int</span></span><br><span class="line">incrementerSix() <span class="comment">// 6</span></span><br><span class="line">incrementerSix() <span class="comment">// 12</span></span><br><span class="line">incrementerTen() <span class="comment">// 40</span></span><br><span class="line"><span class="keyword">let</span> alsoIncrementerTen <span class="operator">=</span> incrementerTen <span class="comment">// () -&gt; Int</span></span><br><span class="line">alsoIncrementerTen() <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，调用了递增闭包<code>incrementerTen</code>每次+10，当我新建一个<code>incrementerSix</code>闭包时就变成了+6递增，也就说产生了一个新的变量引用。</p>
<p>当调用<code>alsoIncrementerTen</code>后，返回的值是50，这里可以确定<code>Closure</code>是引用类型,是因为<code>alsoIncrementerTen</code> 引用了<code>incrementerTen</code>他们共享同一个内存。如果是值类型，<code>alsoIncrementerTen</code>返回的结果会是10,而不是50；</p>
<p>根据上面的代码关于闭包捕获值做出总结：</p>
<ul>
<li><code>closure</code>捕获值本质上是将存在栈(Stack)区的值存储到堆(Heap)区</li>
<li>当<code>Closure</code>中并没有修改或者在闭包的外面的值时，Swift可能会使用这个值的copy而不是捕获</li>
<li><code>Closure</code>捕获值时即使定义这些变量或常量的原作用域已经不存在了<code>closure</code>依旧能捕获这个值</li>
<li>如果建立了一个新的闭包调用，将会产生一个新的独立的变量的引用</li>
<li>无论什么时候赋值一个函数或者闭包给常量或变量，实际上都是将常量和变量设置为对函数和闭包的引用</li>
</ul>
<h3 id="4、Closure循环引用"><a href="#4、Closure循环引用" class="headerlink" title="4、Closure循环引用"></a>4、Closure循环引用</h3><p>Swift中的<code>closure</code>是引用类型,我们知道Swift中的引用类型是通过<code>ARC</code>机制来管理其内存的。在Swift中，两个引用对象互相持有对方时回产生强引用环，也就是常说的循环引用。虽然在默认情况下，Swift能够处理所有关于捕获的内存的管理的操作，但这并不能让开发者一劳永逸的不去关心内存问题，因为相对于对象产生的循环引用<code>Closure</code>产生循环引用的情况更复杂，所以在使用<code>Closure</code>时应该更小心谨慎。那么在使用<code>Closure</code>时一般哪些情况会产生循环引用问题呢？</p>
<h5 id="4-1、Closure捕获对象产生的循环引用"><a href="#4-1、Closure捕获对象产生的循环引用" class="headerlink" title="4.1、Closure捕获对象产生的循环引用"></a>4.1、<code>Closure</code>捕获对象产生的循环引用</h5><p>当分配了一个<code>Closure</code>给实例的属性，并且<code>Closure</code>通过引用该实例或者实例的成员来捕获实例，将会在<code>Closure</code>和实例之间产生循环引用。</p>
<p>这里我用学生<code>Student</code>类来做演示,假设现在学生需要做一个单项选择题，老师根据其返回的答案来判断是否正确。我将对照<code>Objective-C</code>中的<code>Block</code>来做一个对比,在Xcode中编写如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, AnswerEnum) &#123;</span><br><span class="line">    A,</span><br><span class="line">    B,</span><br><span class="line">    C,</span><br><span class="line">    D,</span><br><span class="line">&#125;;</span><br><span class="line">@interface Student : NSObject</span><br><span class="line">@property (copy, nonatomic) NSString *name;</span><br><span class="line">@property (copy, nonatomic) void (^replyClosure)(AnswerEnum answer);</span><br><span class="line">@end</span><br><span class="line">@implementation Student</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        if (self.replyClosure) &#123;</span><br><span class="line">            self.replyClosure(B);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface Teacher : NSObject</span><br><span class="line">@property (assign, nonatomic) BOOL isRight;</span><br><span class="line">@property (strong, nonatomic) Student *student;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Teacher</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.student.replyClosure &#x3D; ^(AnswerEnum answer) &#123;</span><br><span class="line">             &#x2F;&#x2F; Capturing &#39;self&#39; strongly in this block is likely to lead to a retain cycle</span><br><span class="line">             NSLog(@&quot;%@&quot;,self.student.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>其实上面的代码，不用运行在Build的时候就会警告<code>Capturing &#39;self&#39; strongly in this block is likely to lead to a retain cycle</code>。</p>
<p>那么在Swift中使用<code>closure</code>是否同样也会产生循环引用呢？我把<code>Objective-C</code>代码转换成<code>Swift</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Answer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">A</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">B</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">C</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">D</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="type">String</span>()</span><br><span class="line">    <span class="keyword">var</span> replyClosure: (<span class="type">Answer</span>) -&gt; <span class="type">Void</span> <span class="operator">=</span> &#123; <span class="keyword">_</span> <span class="keyword">in</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;Student: <span class="subst">\(name)</span>&gt;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;==========Student init==========<span class="subst">\(name)</span>&quot;</span>)</span><br><span class="line">        replyClosure(.<span class="type">B</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;==========Student deinit==========<span class="subst">\(<span class="keyword">self</span>.name)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isRight: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;==========Teacher init==========&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> student <span class="operator">=</span> <span class="type">Student</span>(name: <span class="string">&quot;Kate Bell&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> judgeClosure <span class="operator">=</span> &#123; (answer: <span class="type">Answer</span>) <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(student.name)</span> is <span class="subst">\(answer)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        student.replyClosure <span class="operator">=</span> judgeClosure</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;==========Teacher deinit==========&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Student</code>类有两个属性：<code>name</code>表示学生姓名，<code>replyClosure</code>表示学生回答问题这一动作并返回答题结果。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用并运行代码</span></span><br><span class="line"><span class="type">Teacher</span>()</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="operator">==========</span><span class="type">Teacher</span> <span class="keyword">init</span><span class="operator">==========</span></span><br><span class="line"><span class="operator">==========</span><span class="type">Student</span> <span class="keyword">init</span><span class="operator">==========</span><span class="type">Kate</span> <span class="type">Bell</span></span><br><span class="line"><span class="operator">==========</span><span class="type">Teacher</span> <span class="keyword">deinit</span><span class="operator">==========</span></span><br></pre></td></tr></table></figure>
<p>运行上面的代码，通过打印结果可以看到<code>Student</code>类并没有调用<code>deinit</code>方法，此处说明<code>Student</code>在被初始化后内存并没有释放。实际上在<code>judgeClosure</code>内部，只要我调用(捕获)了<code>student</code>，无论是任何操作,该部分内存都不能有效释放了。那么为什么会造成这种现象呢？下面做逐步分析：</p>
<ul>
<li>当我调用了闭包之后，闭包才会捕获值，在执行<code>student.replyClosure = judgeClosure</code>之后，在内存中他们的关系是这样的：</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba985325d30c491db6f833de0699f0d0~tplv-k3u1fbpfcp-watermark.image" alt="closure001.png"></p>
<p>在Swift中，<code>class、func、closure</code>都是引用类型，因此在上面的代码中，<code>student</code>和<code>judgeClosure</code>都指向各种对象的<code>strong reference</code>。</p>
<p>同时由于在闭包中捕获了<code>student</code>,因此<code>judgeClosure</code>闭包就有了一个指向<code>student</code>的强引用。最后当执行<code>student.replyClosure = judgeClosure</code>之后，让<code>replyClosure</code>也成了<code>judgeClosure</code>的强引用。此时<code>student</code>的引用计数为1，<code>judgeClosure</code>的引用计数是2。</p>
<ul>
<li>当超过作用域后，<code>student</code>和<code>judgeClosure</code>之间的引用关系是这样的：</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fcb9017fe6346f7a8cebba11d29c759~tplv-k3u1fbpfcp-watermark.image" alt="closure002.png"></p>
<p>此时，只有<code>Closure</code>对象的引用计数变成了1。于是<code>Closure</code>继续引用了<code>student</code>，<code>student</code>继续引用了他的对象<code>replyClosure</code>，而这个对象继续引用着<code>judgeClosure</code>。这样就造成了一个引用循环，所以就会出现内存无法正常释放的情况。</p>
<h5 id="4-2、closure属性的内部实现捕获self产生的循环引用"><a href="#4-2、closure属性的内部实现捕获self产生的循环引用" class="headerlink" title="4.2、closure属性的内部实现捕获self产生的循环引用"></a>4.2、closure属性的内部实现捕获self产生的循环引用</h5><p>同样的这里我先利用<code>Objective-C</code>的代码来举例，修改<code>Student</code>类的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation Student</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">       if (self.replyClosure) &#123;</span><br><span class="line">          self.replyClosure &#x3D; ^(AnswerEnum answer) &#123;</span><br><span class="line">             &#x2F;&#x2F; Capturing &#39;self&#39; strongly in this block is likely to lead to a retain cycle</span><br><span class="line">             NSLog(@&quot;%@&quot;,self);</span><br><span class="line">          &#125;;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>同样的在Build时编译器会警告，<code>Capturing &#39;self&#39; strongly in this block is likely to lead to a retain cycle</code>。</p>
<p>在Swift中虽然编译器不会警告，但也会产生同样产生循环引用问题。修改<code>Student</code>中定义<code>replyClosure</code>代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> replyClosure: (<span class="type">Answer</span>) -&gt; <span class="type">Void</span> <span class="operator">=</span> &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;replyClosure self=============<span class="subst">\(<span class="keyword">self</span>)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了保证在<code>replyClosure</code>内部调用<code>self</code>时<code>replyClosure</code>闭包已经正确初始化了，所以采用了<code>lazy</code>懒加载的方式。修改调用的代码为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span>(name: <span class="string">&quot;Tom&quot;</span>).replyClosure(.<span class="type">B</span>)</span><br></pre></td></tr></table></figure>
<p>运行代码，打印结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">==========</span><span class="type">Student</span> <span class="keyword">init</span><span class="operator">==========</span><span class="type">Kate</span> <span class="type">Bell</span></span><br><span class="line">replyClosure <span class="keyword">self</span><span class="operator">=============&lt;</span><span class="type">Student</span>: <span class="type">Tom</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于<code>Student</code>实例和<code>replyClosure</code>是互相强持有关系，即使超出了作用域他们之间依然存在着引用，所以内存不能有效释放。此时他们之间的引用关系是：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c0669bdd5c842c5bcb16b3439ca9d98~tplv-k3u1fbpfcp-watermark.image" alt="closure004.png"></p>
<p>在<code>Objective-C</code>中一般采用弱引用的方式解决<code>Block</code>和实例循环引用的问题，这里对<code>Block</code>和类实例之间产生循环引用的原因不做赘述，关于<code>Objective-C</code>中<code>Block</code>的更多使用细节可查阅<a href="https://book.douban.com/subject/24720270/">Objective-C高级编程: iOS与OS X多线程和内存管理</a>一书和苹果官方文档<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/bxGettingStarted.html#//apple_ref/doc/uid/TP40007502-CH7-SW4">Getting Started with Blocks</a>的内容。那么在Swift中该如何处理循环引用呢？在Swift中需要根据<code>closure</code>和<code>class</code>对象生命周期的不同，而采用不同的方案来解决循环引用问题。</p>
<h3 id="5、无主引用（unowned）"><a href="#5、无主引用（unowned）" class="headerlink" title="5、无主引用（unowned）"></a>5、无主引用（unowned）</h3><h5 id="5-1、使用unowned处理closure和类对象的引用循环"><a href="#5-1、使用unowned处理closure和类对象的引用循环" class="headerlink" title="5.1、使用unowned处理closure和类对象的引用循环"></a>5.1、使用unowned处理closure和类对象的引用循环</h5><p>为了更易理解，我修改<code>Teacher</code>类的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isRight: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;==========Teacher init==========&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> student <span class="operator">=</span> <span class="type">Student</span>(name: <span class="string">&quot;Kate Bell&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> judgeClosure <span class="operator">=</span> &#123; [student] (answer: <span class="type">Answer</span>) <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;student===========<span class="subst">\(student)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        student.replyClosure <span class="operator">=</span> judgeClosure</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;==========Teacher deinit==========&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只考虑<code>student</code>和<code>teacher</code>之间的引用关系，此时student<code>和</code>closure`之间存在着强引用关系，他们的引用计数都是2，在内存中他们之间的引用关系为：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7212bf008f964c66b94a87d414a9bd09~tplv-k3u1fbpfcp-watermark.image" alt="closure007.png"></p>
<p>超过作用域后，由于互相存在强引用<code>student</code>和<code>clousre</code>的引用计数并不为0，所以内存无法销毁，此时他们之间的引用关系为：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5178657660e44f19daa1349cc734554~tplv-k3u1fbpfcp-watermark.image" alt="closure008.png"></p>
<p>对于这种引用关系在前面的<a href="https://dengfeng520.github.io/2021/03/05/Swift%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8/">ARC</a>就已经说过，把循环的任意一方变成<code>unowned</code>或<code>weak</code>就好了。我将<code>student</code>设置为无主引用，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> judgeClosure <span class="operator">=</span> &#123; [<span class="keyword">unowned</span> student] (answer: <span class="type">Answer</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(student.name)</span> is <span class="subst">\(answer)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用无主引用后，他们之间的引用关系如下图所示：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6676faa700e423a8b835c4a5a8d83e0~tplv-k3u1fbpfcp-watermark.image" alt="closure009.png"></p>
<p>运行代码并打印：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 运行</span></span><br><span class="line"><span class="type">Teacher</span>()</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="operator">==========</span><span class="type">Teacher</span> <span class="keyword">init</span><span class="operator">==========</span></span><br><span class="line"><span class="operator">==========</span><span class="type">Student</span> <span class="keyword">init</span><span class="operator">==========</span><span class="type">Kate</span> <span class="type">Bell</span></span><br><span class="line"><span class="operator">==========</span><span class="type">Student</span> <span class="keyword">deinit</span><span class="operator">==========</span><span class="type">Kate</span> <span class="type">Bell</span></span><br><span class="line"><span class="operator">==========</span><span class="type">Teacher</span> <span class="keyword">deinit</span><span class="operator">==========</span></span><br></pre></td></tr></table></figure>
<p>可以看到<code>student</code>和<code>teacher</code>都可以正常被回收了，说明<code>closure</code>的内存也被回收了。当<code>closure</code>为<code>nil</code>时，<code>student</code>对象就会被<code>ARC</code>回收，而当<code>student</code>为<code>nil</code>时，<code>teacher</code>也就失去了他的作用会被ARC回收其内存。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b3cda113c1047f49705317c66be9fbb~tplv-k3u1fbpfcp-watermark.image" alt="closure010.png"></p>
<h5 id="5-2、unowned并不能解决所有的循环引用问题"><a href="#5-2、unowned并不能解决所有的循环引用问题" class="headerlink" title="5.2、unowned并不能解决所有的循环引用问题"></a>5.2、<code>unowned</code>并不能解决所有的循环引用问题</h5><p>虽然<code>unowned</code>能解决循环引用问题，但并不意味着，遇到的所有<code>closure</code>循环引用问题都可以用无主引用（unowned）来解决:</p>
<h6 id="5-2-1、示例代码一"><a href="#5-2-1、示例代码一" class="headerlink" title="5.2.1、示例代码一"></a>5.2.1、示例代码一</h6><p>同样用<code>Student</code>对象来举例，在”Kate Bell”学生回答完问题后，另一个<code>Tom</code>又回答了问题，他选择了<strong>C</strong>答案，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> student <span class="operator">=</span> <span class="type">Student</span>(name: <span class="string">&quot;Kate Bell&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> judgeClosure <span class="operator">=</span> &#123; [<span class="keyword">unowned</span> student] (answer: <span class="type">Answer</span>) <span class="keyword">in</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;student===========<span class="subst">\(student)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">student <span class="operator">=</span> <span class="type">Student</span>(name: <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">student.replyClosure <span class="operator">=</span> judgeClosure</span><br><span class="line">student.replyClosure(.<span class="type">C</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="comment">// ==========Student init==========Kate Bell</span></span><br><span class="line"><span class="comment">// ==========Student init==========Tom</span></span><br><span class="line"><span class="comment">// ==========Student deinit==========Kate Bell</span></span><br></pre></td></tr></table></figure>
<p>运行代码，程序会Crash并报错，<code>error: Execution was interrupted, reason: signal SIGABRT.</code>来分析一下为什么会这样：</p>
<ul>
<li>代码中首先创建了一个名为<code>Kate Bell</code>的学生对象，<code>judgeClosure</code>捕获了这个<code>student</code>对象</li>
<li>当<code>student = Student(name: &quot;Tom&quot;)</code>之后，由于<code>judgeClosure</code>是按照<code>unowned</code>的方式捕获的，此时<code>judgeClosure</code>内的<code>student</code>对象实际上已经不存了</li>
<li>名为<code>Tom</code>的<code>student</code>对象引用了<code>replyClosure</code>闭包</li>
<li>调用<code>student.replyClosure(.C)</code>的时候，<code>replyClosure</code>之前捕获的<code>student</code>对象已经不存在，此时就产生了Crash</li>
</ul>
<h6 id="5-2-1、示例代码二"><a href="#5-2-1、示例代码二" class="headerlink" title="5.2.1、示例代码二"></a>5.2.1、示例代码二</h6><p>那么，如果我将<code> student.replyClosure = judgeClosure</code>移动到最前面呢？修改代码如下： </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> student <span class="operator">=</span> <span class="type">Student</span>(name: <span class="string">&quot;Kate Bell&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> judgeClosure <span class="operator">=</span> &#123; [<span class="keyword">unowned</span> student] (answer: <span class="type">Answer</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;student===========<span class="subst">\(student)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">student.replyClosure <span class="operator">=</span> judgeClosure</span><br><span class="line">student <span class="operator">=</span> <span class="type">Student</span>(name: <span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">student.replyClosure(.<span class="type">C</span>)</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="comment">// ==========Student init==========Kate Bell</span></span><br><span class="line"><span class="comment">// ==========Student init==========Tom</span></span><br><span class="line"><span class="comment">// ==========Student deinit==========Kate Bell</span></span><br></pre></td></tr></table></figure>
<p>可以看到，名为<code>&quot;Kate Bell&quot;</code>的<code>student</code>对象正常销毁了，但是<code>Tom</code>学生对象并没有正常销毁，这是由于<code>replyClosure</code>闭包在其内部捕获了<code>self</code>造成的循环引用。此时他们之间的引用关系为：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c0669bdd5c842c5bcb16b3439ca9d98~tplv-k3u1fbpfcp-watermark.image" alt="closure004.png"></p>
<p>对于这种情况使用<code>unowned</code>并不能解决循环引用问题，所以只能采用另一种解决循环引用的方案<strong>弱引用(weak)</strong>,来告诉<code>closure</code><strong>当<code>closure</code>所捕获的对象已经被释放时，就不用在访问这个对象了。</strong></p>
<h3 id="6、弱引用（weak）"><a href="#6、弱引用（weak）" class="headerlink" title="6、弱引用（weak）"></a>6、弱引用（weak）</h3><h5 id="6-1、使用weak处理closure和类对象之间的引用循环"><a href="#6-1、使用weak处理closure和类对象之间的引用循环" class="headerlink" title="6.1、使用weak处理closure和类对象之间的引用循环"></a>6.1、使用weak处理closure和类对象之间的引用循环</h5><p>为了解决上面的的循环引用问题，我把<code>replyClosure</code>的代码修改为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> replyClosure: (<span class="type">Answer</span>) -&gt; <span class="type">Void</span> <span class="operator">=</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;replyClosure self=============<span class="subst">\(<span class="keyword">self</span>)</span>&quot;</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>重新执行代码，可以看到<code>Tom</code>学生对象可以正常释放了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==========Student init==========Kate Bell</span></span><br><span class="line"><span class="comment">// ==========Student init==========Tom</span></span><br><span class="line"><span class="comment">// ==========Student deinit==========Kate Bell</span></span><br><span class="line"><span class="comment">// ==========Student deinit==========Tom</span></span><br></pre></td></tr></table></figure>
<p>让<code>self</code>为弱引用后，<code>student</code>之间的引用关系是：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a6d3a6872634f52b07d06a97fd3a253~tplv-k3u1fbpfcp-watermark.image" alt="closure005.png"></p>
<p>当我使用了<code>weak</code>时，就意味这这个对象可能为<code>nil</code>,而在<code>closure</code>里捕获和使用一个<code>Optional</code>的值可能会发生一些不可预期的问题，此处需要做<code>unwrap</code>操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> replyClosure: (<span class="type">Answer</span>) -&gt; <span class="type">Void</span> <span class="operator">=</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">     <span class="keyword">guard</span> <span class="keyword">let</span> value <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;replyClosure self=============<span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当离开作用域后，<code>student</code>和<code>closure</code>的引用计数都为0，他们的内存就会合理的释放，他们之间的引用关系如下图所示：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aef0d9a77af74ad9a9ee915350db41da~tplv-k3u1fbpfcp-watermark.image" alt="closure006.png"></p>
<p>关于<code>closure</code>和类对象之间的循环问题，如何判断两者之间是否会产生循环引用，要根据一个类对象是否真的拥有正在使用的<code>closure</code>。如果类对象没有持有这个<code>closure</code>，那么就不必考虑循环引用问题。</p>
<h5 id="6-2、-weak并不能解决所有的循环引用问题"><a href="#6-2、-weak并不能解决所有的循环引用问题" class="headerlink" title="6.2、 weak并不能解决所有的循环引用问题"></a>6.2、 weak并不能解决所有的循环引用问题</h5><p>虽然<code>unowned</code>和<code>weak</code>能够解决<code>Closure</code>和类实例之间的循环引用问题，但这并不表示在任何<code>Closure</code>中都可以使用这种方案来解决问题。相反有时候滥用弱引用还会给带来一些诡异的麻烦和内存问题。</p>
<h6 id="6-2-1、滥用弱引用可能会造成一些不必要的麻烦"><a href="#6-2-1、滥用弱引用可能会造成一些不必要的麻烦" class="headerlink" title="6.2.1、滥用弱引用可能会造成一些不必要的麻烦"></a>6.2.1、滥用弱引用可能会造成一些不必要的麻烦</h6><p>这里我同样用<code>Student</code>类来举例，为学生添加一个写作业的任务：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doHomeWork</span>()</span> &#123;</span><br><span class="line">   <span class="comment">// 全局队列</span></span><br><span class="line">   <span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.global()</span><br><span class="line">   queue.async &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(<span class="keyword">self</span><span class="operator">?</span>.name)</span>:开始写作业&quot;</span>)</span><br><span class="line">          sleep(<span class="number">2</span>)</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(<span class="keyword">self</span><span class="operator">?</span>.name)</span>:完成作业&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟做家庭作业</span></span><br><span class="line"><span class="type">Student</span>(name: <span class="string">&quot;Kate Bell&quot;</span>).doHomeWork()</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">==========</span><span class="type">Student</span> <span class="keyword">init</span><span class="operator">==========</span></span><br><span class="line"><span class="operator">==========</span><span class="type">Student</span> <span class="keyword">deinit</span><span class="operator">==========</span></span><br><span class="line"><span class="type">Optional</span>(<span class="string">&quot;Kate Bell&quot;</span>):开始写作业</span><br><span class="line"><span class="literal">nil</span>:完成作业</span><br></pre></td></tr></table></figure>
<p>为什么完成的作业是<code>nil</code>呢？实际上这里并不需要使用弱引用，因为<code>async</code>方法中使用的<code>closure</code>并不归<code>student</code>对象持有，虽然<code>closure</code>会捕获<code>student</code>对象，但这两者之间并不会产生循环引用，反而因为弱引用的问题学生对象被提前释放了，但是如果这里我使用了强制拆包就又可能导致程序Crash。所以正确的理解<code>closure</code>和类对象的引用关系并合理的使用<code>weak</code>和<code>unowned</code>才能从本质上解决问题。</p>
<h6 id="6-2-2、使用withExtendedLifetime改进这个问题"><a href="#6-2-2、使用withExtendedLifetime改进这个问题" class="headerlink" title="6.2.2、使用withExtendedLifetime改进这个问题"></a>6.2.2、使用withExtendedLifetime改进这个问题</h6><p>那么有没有方法可以避免在错误的使用了<code>weak</code>之后造成的问题呢？这里可以使用Swift提供的<code>withExtendedLifetime</code>函数，它有两个参数： 第一个参数是要延长生命的对象，第二个对象是<code>clousre</code>，在这个<code>closure</code>返回之前，第一个参数会一直存活在内存中，修改<code>async closure</code>里的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.global()</span><br><span class="line">queue.async &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">   <span class="built_in">withExtendedLifetime</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(<span class="keyword">self</span><span class="operator">?</span>.name)</span>:开始写作业&quot;</span>)</span><br><span class="line">      sleep(<span class="number">2</span>)</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(<span class="keyword">self</span><span class="operator">?</span>.name)</span>:完成作业&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新编译代码，打印结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">==========</span><span class="type">Student</span> <span class="keyword">init</span><span class="operator">==========</span></span><br><span class="line"><span class="type">Optional</span>(<span class="string">&quot;Kate Bell&quot;</span>):开始写作业</span><br><span class="line"><span class="type">Optional</span>(<span class="string">&quot;Kate Bell&quot;</span>):完成作业</span><br><span class="line"><span class="operator">==========</span><span class="type">Student</span> <span class="keyword">deinit</span><span class="operator">==========</span></span><br></pre></td></tr></table></figure>
<h6 id="6-2-3、改进withExtendedLifetime语法"><a href="#6-2-3、改进withExtendedLifetime语法" class="headerlink" title="6.2.3、改进withExtendedLifetime语法"></a>6.2.3、改进withExtendedLifetime语法</h6><p>虽然<code>withExtendedLifetime</code>能过解决弱引用问题，如果有很多地方有要这样访问对象这样就很麻烦。这里有一个解决方案是对<code>withExtendedLifetime</code>做一个封装，,给<code>Optional</code>做一个扩展（extension）处理:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">withExtendedLifetime</span>(<span class="keyword">_</span> <span class="params">body</span>: (<span class="type">Wrapped</span>) -&gt; <span class="type">Void</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> value <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        body(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的代码： </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doHomeWork</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 全局队列</span></span><br><span class="line">    <span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.global()</span><br><span class="line">    queue.async &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>.withExtendedLifetime &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(<span class="keyword">self</span><span class="operator">?</span>.name)</span>:开始写作业&quot;</span>)</span><br><span class="line">            sleep(<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(<span class="keyword">self</span><span class="operator">?</span>.name)</span>:完成作业&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终打印的结果和之前一样，并且我还可以其他地方调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">==========</span><span class="type">Student</span> <span class="keyword">init</span><span class="operator">==========</span></span><br><span class="line"><span class="type">Optional</span>(<span class="string">&quot;Kate Bell&quot;</span>):开始写作业</span><br><span class="line"><span class="type">Optional</span>(<span class="string">&quot;Kate Bell&quot;</span>):完成作业</span><br><span class="line"><span class="operator">==========</span><span class="type">Student</span> <span class="keyword">deinit</span><span class="operator">==========</span></span><br></pre></td></tr></table></figure>
<p>本文主要介绍了<code>closure</code>基本概念、<code>closure</code>的类型、<code>closure</code>和类对象之间的内存问题及其解决方法，如果您发现我的理解有错误的地方，请指出。</p>
<hr>
<p>本文参考：</p>
<p><a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">The Swift Programming Language: Closures</a></p>
<p><a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#ID57">The Swift Programming Language: Automatic Reference Counting</a></p>
<p><a href="https://boxueio.com/series/understand-ref-types/episodes/184">容易让人犯错的closure内存管理</a></p>
<p><a href="https://github.com/dengfeng520/RPDemo/tree/main/Closures">本文demo</a></p>
]]></content>
  </entry>
  <entry>
    <title>Swift 结构体和类</title>
    <url>/2021/03/31/Swift%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="1、值类型和引用类型"><a href="#1、值类型和引用类型" class="headerlink" title="1、值类型和引用类型"></a>1、值类型和引用类型</h3><p>在iOS中虚拟内存分为五大内存分区：<strong>堆区、栈区、全局区、常量区、代码区</strong>。在Swift中根据对象在内存的存储位置不同分为值类型和引用类型。</p>
<ul>
<li><p>值类型： Swift中的值类型主要有：<code>enum，struct、Array、Dictionary、Tuple</code>等</p>
</li>
<li><p>引用类型：Swift中的引用类型主要有：<code>methods,class,clousre</code></p>
</li>
</ul>
<h5 id="1-1、值类型和引用类型的内存分配和管理方式"><a href="#1-1、值类型和引用类型的内存分配和管理方式" class="headerlink" title="1.1、值类型和引用类型的内存分配和管理方式"></a>1.1、值类型和引用类型的内存分配和管理方式</h5><p>Swift 中的值类型，一般存储于栈内存中（也不一定），由于栈的特性这部分内存是由CPU直接管理和优化的，对于值的copy也是深拷贝(deep copy)，当使用完一个值后系统会立即释放这部分内存。所以存储于栈上的内存在创建、使用、释放都非常效率。</p>
<p>一般情况下，当创建一个<code>struct</code>默认被存储于栈区。当编译器侦测到结构体变量被一个函数闭合的时候，此时这个结构体将存储在堆上。此处可参考<a href="https://objccn.io/products/advanced-swift/">《Swift 进阶》</a>一书中的<strong>结构体和类章节 闭包和可变性</strong>小节的内容。</p>
<p>Swift中的引用类型，一般存储于堆区，苹果采用ARC的方式来管理这部分内存，对于这部分内存的追踪就是对引用计数的追踪，当类对象被引用时引用计数+1，当引用计数为0时，ARC会释放这部分内存。</p>
<h3 id="2、复杂的值类型struct"><a href="#2、复杂的值类型struct" class="headerlink" title="2、复杂的值类型struct"></a>2、复杂的值类型<code>struct</code></h3><p>Swift提供了多种可以结构化存储数据的方式，<code>struct、enum、class</code>等。这里先说在开发中经常用作<code>Model</code>来使用的<code>struct</code>。</p>
<h5 id="2-1、struct的定义和初始化"><a href="#2-1、struct的定义和初始化" class="headerlink" title="2.1、struct的定义和初始化"></a>2.1、struct的定义和初始化</h5><p>从定义一个<code>struct</code>开始，这里我定义一个用来表示颜色的<code>struct</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> red: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> green: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> blue: <span class="type">Double</span></span><br><span class="line">    <span class="comment">// 透明度</span></span><br><span class="line">    <span class="keyword">var</span> alpha: <span class="type">Double</span>? <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我定义了四个属性，<code>red、double、blue</code>表示红绿蓝三色值，<code>alpha</code>表示透明度。这些属性所占用的内存空间决定了<code>Color</code>的大小。当我定义完四个属性后直接build,没有任何问题，这里首先来了解<code>struct</code>的初始化方法。</p>
<h6 id="2-1-1、Memberwise-initializer"><a href="#2-1-1、Memberwise-initializer" class="headerlink" title="2.1.1、Memberwise initializer"></a>2.1.1、<code>Memberwise initializer</code></h6><p>当我定义一个<code>struct</code>而不为其创建任何<code>init</code>方法，也可以正常运行，这是由于Swift编译器自动为这个<code>struct</code>创建了一个初始化方法，这种<code>init</code>方法叫做<code>Memberwise initializer</code>.当我需要使用这个<code>struct</code>时可以这样初始化一个<code>color</code>对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color <span class="operator">=</span> <span class="type">Color</span>(red: <span class="number">200</span>, green: <span class="number">200</span>, blue: <span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<h6 id="2-1-2-、Default-initializer"><a href="#2-1-2-、Default-initializer" class="headerlink" title="2.1.2 、Default initializer"></a>2.1.2 、<code>Default initializer</code></h6><p>如果我想在创建<code>color</code>对象的时候不指定参数,自动的给属性设置默认值，这时有两种方法可供选择：</p>
<ul>
<li><p>在定义每个属性时都为其设置默认值</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> red: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> green: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> blue: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> alpha: <span class="type">Double</span>? <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以在初始化<code>color</code>对象时，不用指定参数来初始化<code>color</code>对象了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color <span class="operator">=</span> <span class="type">Color</span>()</span><br></pre></td></tr></table></figure>
<p>这么做的要求就是在设置属性时必须为每个属性都设置默认值，因为Swift要求<code>init</code>方法必须初始化自定义类型的每一个属性。</p>
</li>
<li><p>在<code>init</code>方法中为每个属性设置默认值</p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> red: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> green: <span class="type">Double</span> </span><br><span class="line">    <span class="keyword">var</span> blue: <span class="type">Double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> alpha: <span class="type">Double</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">red</span>: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span>, <span class="params">green</span>: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span>, <span class="params">blue</span>: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span>, <span class="params">alpha</span>: <span class="type">Double</span>? <span class="operator">=</span> <span class="number">1</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.red <span class="operator">=</span> red</span><br><span class="line">        <span class="keyword">self</span>.green <span class="operator">=</span> green</span><br><span class="line">        <span class="keyword">self</span>.blue <span class="operator">=</span> blue</span><br><span class="line">        <span class="keyword">self</span>.alpha <span class="operator">=</span> alpha</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这和之前直接给属性设置默认值的方法效果是一样的。当为某个<code>struct</code>创建了<code>init</code>方法后一定要保证其正确性，因为当重写了<code>init</code>方法后，系统就不会在创建默认的<code>init</code>方法了。</p>
<h6 id="2-1-3、Failable-init"><a href="#2-1-3、Failable-init" class="headerlink" title="2.1.3、Failable init"></a>2.1.3、Failable init</h6><p>在使用<code>struct</code>作为model时，如果要将其显示在界面上最终都需要转换成字符串<code>String</code>，这里可以使用系统提供的<code>Codable</code>协议来把服务器返回的进行转换，当然也可以使用其他开源库来完成这些操作。由于在初始化时可能会解析<code>Data</code>数据失败，这里采用<code>init?</code>的方式来初始化，当解析失败时，直接返回<code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> red: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> green: <span class="type">Double</span> </span><br><span class="line">    <span class="keyword">var</span> blue: <span class="type">Double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> alpha: <span class="type">Double</span>? <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>,<span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> red</span><br><span class="line">        <span class="keyword">case</span> green</span><br><span class="line">        <span class="keyword">case</span> blue</span><br><span class="line">        <span class="keyword">case</span> alpha</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Color</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">init?</span>(<span class="params">data</span>: <span class="type">Data</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> model <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">JSONDecoder</span>().decode(<span class="type">Color</span>.<span class="keyword">self</span>, from: data) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> model</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-1-4、Type-property设置一个常用的值"><a href="#2-1-4、Type-property设置一个常用的值" class="headerlink" title="2.1.4、Type property设置一个常用的值"></a>2.1.4、<code>Type property</code>设置一个常用的值</h6><p>对于一个<code>struct</code>经常会使用的值，我们可以采用在<code>struct</code>中定义成<code>Type property</code>。如App的主题颜色是我在代码中要经常使用的，可以采用<code>Type roperty</code>的初始化方式。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> themeColor <span class="operator">=</span> <span class="type">Color</span>(red: <span class="number">200</span>, green: <span class="number">200</span>, blue: <span class="number">200</span>, alpha: <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当我要使用App主题颜色时</span></span><br><span class="line"><span class="keyword">let</span> color <span class="operator">=</span> <span class="type">Color</span>.themeColor</span><br></pre></td></tr></table></figure>
<p>当创建了默认主题颜色时，它不是<code>struct</code>对象的一部分，因此不会增加<code>    color</code>对象的大小,还可以使代码看起来更简洁明了。</p>
<h5 id="2-2、为struct添加方法"><a href="#2-2、为struct添加方法" class="headerlink" title="2.2、为struct添加方法"></a>2.2、为struct添加方法</h5><p>在Swift中不仅可以为<code>struct</code>添加属性还可以添加方法，只不过<code>struct</code>的方法，默认都是只读的，例如我要为<code>Color</code>添加一个修改透明度的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyWith</span>(<span class="params">alpha</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3、mutating关键字"><a href="#2-3、mutating关键字" class="headerlink" title="2.3、mutating关键字"></a>2.3、mutating关键字</h5><p>当我要在<code>struct</code>的方法中修改<code>struct</code>中的某个属性值时，要在这个方法前面加上<code>mutating</code>关键字。当添加<code>mutating</code>之后，Swift会隐式的把<code>self</code>标记为<code>inout</code>,这样就可以在方法中修改<code>struct</code>中的属性值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">modifyWith</span>(<span class="params">alpha</span>: <span class="type">Double</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.alpha <span class="operator">=</span> alpha</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-4、修改struct值"><a href="#2-4、修改struct值" class="headerlink" title="2.4、修改struct值"></a>2.4、修改<code>struct</code>值</h5><p>我定义了一个<code>color</code>对象，为了更好观察这个变量被修改时发生了什么，给他添加一个<code>didSet clousre</code>,只要<code>color</code>的值发生变化，就可以看到打印的内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color <span class="operator">=</span> <span class="type">Color</span>(red: <span class="number">200</span>, green: <span class="number">200</span>, blue: <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;color============<span class="subst">\(color)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我修改<code>color</code>的值，再看打印的结果。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colorB <span class="operator">=</span> <span class="type">Color</span>(red: <span class="number">100</span>, green: <span class="number">100</span>, blue: <span class="number">100</span>)</span><br><span class="line">color <span class="operator">=</span> colorB</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">color<span class="operator">============</span><span class="type">Color</span>(red: <span class="number">100.0</span>, green: <span class="number">100.0</span>, blue: <span class="number">100.0</span>, alpha: <span class="type">Optional</span>(<span class="number">1.0</span>))</span><br></pre></td></tr></table></figure>
<p>这里修改了<code>color</code>的值所以触发了<code>didSet</code>方法。</p>
<p>如果只修改<code>color</code>其中某个属性值,如我要修改<code>red</code>属性值为110，    </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">color.red <span class="operator">=</span> <span class="number">110</span></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">color<span class="operator">============</span><span class="type">Color</span>(red: <span class="number">110.0</span>, green: <span class="number">100.0</span>, blue: <span class="number">100.0</span>, alpha: <span class="type">Optional</span>(<span class="number">1.0</span>))</span><br></pre></td></tr></table></figure>
<p>可以看到依旧会打印，也就是说<strong>只要修改<code>color</code>的任何一个属性值，其实整个<code>color</code>变量都被修改了</strong>。</p>
<h3 id="3、引用类型class"><a href="#3、引用类型class" class="headerlink" title="3、引用类型class"></a>3、引用类型<code>class</code></h3><h5 id="3-1、class的定义和初始化"><a href="#3-1、class的定义和初始化" class="headerlink" title="3.1、class的定义和初始化"></a>3.1、class的定义和初始化</h5><p>当我定义一个表示颜色的类<code>MyColor</code>,为其设置四个属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> red: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> green: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> blue: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> alpha: <span class="type">Double</span>? <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我让这个类没有父类，也可以根据情况设置其父类。如果没有没有fu此时编译器会提示<code>Class &#39;MyColor&#39; has no initializers</code>,这是由于<strong>类是引用类型必须有一个完整的生命周期，类必须被明确的初始化、使用、最后被明确的释放</strong>。所以当我定义了一个类时必须明确的构建<code>init</code>方法。这也是<code>class</code>和<code>struct</code>的一个区别之一。</p>
<h6 id="3-1-1、默认init"><a href="#3-1-1、默认init" class="headerlink" title="3.1.1、默认init"></a>3.1.1、默认init</h6><p>一般的最简单的初始化方法可以直接调用<code>init</code>方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> color <span class="operator">=</span> <span class="type">MyColor</span>()</span><br></pre></td></tr></table></figure>
<p>如果我想像这样初始化一个<code>color</code>对象，可以使用<code>class</code>默认的初始化方法，<code>class</code>的默认初始化方法有两种：</p>
<ul>
<li><p>为每个属性设置默认值</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyColor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> red: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> green: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> blue: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> alpha: <span class="type">Double</span>? <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行代码，就可以编译成功。这种方式的确解决了编译报错问题，如果我想在初始化时为类的每个属性设置默认值就会报错，所以为每个属性都设置默认值的方式只适合表意简单的并且初始值固定或者在其内部赋值的<code>class</code>。如果我想类的外部为其设置属性值，可以采用其他的初始化方式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> color <span class="operator">=</span> <span class="type">MyColor</span>(red: <span class="number">100</span>, green: <span class="number">100</span>, blue: <span class="number">100</span>) <span class="comment">// Argument passed to call that takes no arguments</span></span><br></pre></td></tr></table></figure></li>
<li><p>在<code>init</code>方法中为每个属性设置默认值</p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">red</span>: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span>, <span class="keyword">_</span> <span class="params">green</span>: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span>, <span class="keyword">_</span> <span class="params">blue</span>: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span>, <span class="keyword">_</span> <span class="params">alpha</span>: <span class="type">Double</span>? <span class="operator">=</span> <span class="number">1</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">self</span>.red <span class="operator">=</span> red</span><br><span class="line">     <span class="keyword">self</span>.green <span class="operator">=</span> green</span><br><span class="line">     <span class="keyword">self</span>.blue <span class="operator">=</span> blue</span><br><span class="line">     <span class="keyword">self</span>.alpha <span class="operator">=</span> alpha</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">let</span> mycolorA <span class="operator">=</span> <span class="type">MyColor</span>()</span><br><span class="line"><span class="keyword">let</span> mycolorB <span class="operator">=</span> <span class="type">MyColor</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>这样就可以根据实际的需求来初始化<code>MyColor</code>类了。在Swift中，<strong>初始化类的<code>init</code>方法必须定义在<code>class</code>内部，而不能定义在<code>extension</code>里</strong>，否则会导致编译错误。<strong>而<code>struct</code>的<code>init</code>方法是可以定义在<code>extension</code>中</strong>，这也是<code>class</code>和<code>struct</code>的区别之一。</p>
<h5 id="3-2、-Convenience-init"><a href="#3-2、-Convenience-init" class="headerlink" title="3.2、 Convenience init"></a>3.2、 Convenience init</h5><p>如果构造方法前面没有<code>convenience</code>关键字称作<strong>便利构造方法</strong>。如果没有称作<strong>指定构造方法</strong>。</p>
<ul>
<li>便利构造方法： 初始化方法前有<code>convenience</code>关键字，不用对所有的属性进行初始化，因为便利构造方法依赖于指定构造方法。如果想给系统提供的类提供一个快捷创建的方法，就可以自定义一个便利构造方法</li>
<li>指定构造方法：必须对所有的属性初始化</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="function"><span class="keyword">init</span>(<span class="params">at</span>: (<span class="type">Double</span>, <span class="type">Double</span>, <span class="type">Double</span>, <span class="type">Double</span>?))</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(at.<span class="number">0</span>, at.<span class="number">1</span>, at.<span class="number">2</span>, at.<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3、Failable-init"><a href="#3-3、Failable-init" class="headerlink" title="3.3、Failable init"></a>3.3、Failable init</h5><p>在大多数时候和服务器交互数据为了统一和方便，会把所有的数据都采用字符串（String）格式， 这就需要在初始化的时候做一些处理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="function"><span class="keyword">init?</span>(<span class="params">at</span>: (<span class="type">String</span>, <span class="type">String</span>, <span class="type">String</span>, <span class="type">String</span>?))</span> &#123;</span><br><span class="line">     <span class="keyword">guard</span> <span class="keyword">let</span> red <span class="operator">=</span> <span class="type">Double</span>(at.<span class="number">0</span>), <span class="keyword">let</span> green <span class="operator">=</span> <span class="type">Double</span>(at.<span class="number">1</span>), <span class="keyword">let</span> blue <span class="operator">=</span> <span class="type">Double</span>(at.<span class="number">2</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">self</span>.<span class="keyword">init</span>(red, green, blue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>String</code>的<code>init</code>可能会失败，这里采用可选的形式来定义。在其实现中，如果<code>String</code>转<code>Double</code>失败，就返回<code>nil</code>，表示初始化失败。</p>
<h3 id="3、比较struct和class"><a href="#3、比较struct和class" class="headerlink" title="3、比较struct和class"></a>3、比较<code>struct</code>和<code>class</code></h3><p>前面分别简单介绍了<code>struct</code>和<code>class</code>，这里对这两者做一个比较：</p>
<h5 id="3-1-struct和class的共同点"><a href="#3-1-struct和class的共同点" class="headerlink" title="3.1 struct和class的共同点"></a>3.1 <code>struct</code>和<code>class</code>的共同点</h5><ul>
<li>都可以定义属性并用来保存值</li>
<li>都可以构建方法</li>
<li>都可以设置其每个属性的初始值以设置其初始状态</li>
<li>都可以采用下标的方式来访问他的值</li>
<li>都可以对其做<code>extension</code>操作，用来扩展其超出默认实现的功能</li>
<li>都可以遵循某个协议用来提供某些标准的功能</li>
</ul>
<h5 id="3-2、struct和class-的区别"><a href="#3-2、struct和class-的区别" class="headerlink" title="3.2、struct和class`的区别"></a>3.2、struct<code>和</code>class`的区别</h5><ul>
<li><p><code>struct</code>会默认生成<code>init</code>方法，<code>class</code>必须明确指定init方法</p>
</li>
<li><p><code>struct</code>不能继承（但是可以遵循协议）,<code>class</code>是可以继承的</p>
</li>
<li><p><code>struct</code>更多的是关注其值，当我修改<code>struct</code>其中任意属性值时整个<code>struct</code>都会被重新修改一次，<code>class</code>更多的是关注的是对象本身</p>
</li>
</ul>
<h3 id="4、struct和class的选择"><a href="#4、struct和class的选择" class="headerlink" title="4、struct和class的选择"></a>4、struct<code>和</code>class的选择</h3><p>Swift中<code>struct</code>和<code>class</code>有这么多共同点，那在实际开发中要如何选用<code>struct</code>和<code>class</code>呢，作为开发者需要根据当前的使用时机来选择使用哪种类型：</p>
<h5 id="4-1、默认情况下使用struct"><a href="#4-1、默认情况下使用struct" class="headerlink" title="4.1、默认情况下使用struct"></a>4.1、默认情况下使用<code>struct</code></h5><p>一般创建一个<code>struct</code>其会被存储于栈区，因为<code>struct</code>一般不涉及到堆内存分配，无论是创建、追踪还是销毁都非常快，所以默认情况下优先选择<code>struct</code>。</p>
<h5 id="4-2、是否需要继承或Protocol"><a href="#4-2、是否需要继承或Protocol" class="headerlink" title="4.2、是否需要继承或Protocol"></a>4.2、是否需要继承或<code>Protocol</code></h5><ul>
<li>如果对继承和协议没有要求，优先使用<code>struct</code></li>
<li>如果需要继承，那么只能使用<code>class</code></li>
</ul>
<h5 id="4-3、需要和Objective-C时，使用class"><a href="#4-3、需要和Objective-C时，使用class" class="headerlink" title="4.3、需要和Objective-C时，使用class"></a>4.3、需要和<code>Objective-C</code>时，使用<code>class</code></h5><p>当<code>Swift</code>和<code>Objective-C</code>交互时，可以在<code>class</code>前面加<code>@objcMembers</code>，或者要调用的方法和变量前加<code>@objc</code>，在要调用的<code>Objecrtive-C</code>文件中导入<code>#import &quot;工程名-Swift.h&quot;</code>,即可使用调用Swift类。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift 文件中</span></span><br><span class="line"><span class="keyword">@objc</span>Members <span class="class"><span class="keyword">class</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">coverModel</span>()</span> &#123;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Objective-C 文件中</span><br><span class="line">#import &quot;工程名-Swift.h&quot;</span><br><span class="line"></span><br><span class="line">Model *model &#x3D; [[Model alloc] init];</span><br><span class="line">[model coverModel];</span><br></pre></td></tr></table></figure>
<h5 id="4-4、需要控制身份时使用class"><a href="#4-4、需要控制身份时使用class" class="headerlink" title="4.4、需要控制身份时使用class"></a>4.4、需要控制身份时使用<code>class</code></h5><ul>
<li>当需要使用<code>===</code>比较两个实例一致性时。<code>===</code>会自动检查两个对象是否完全一致，包括存储数据的内存地址</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mycolorA <span class="operator">=</span> <span class="type">MyColor</span>()</span><br><span class="line"><span class="keyword">let</span> mycolorB <span class="operator">=</span> mycolorA</span><br><span class="line"><span class="keyword">if</span> mycolorA <span class="operator">===</span> mycolorB &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当需要创建用于共享、可改变的数据时</li>
</ul>
<h5 id="4-5、不控制身份时使用struct"><a href="#4-5、不控制身份时使用struct" class="headerlink" title="4.5、不控制身份时使用struct"></a>4.5、不控制身份时使用<code>struct</code></h5><ul>
<li>当需要使用<code>==</code>比较实例数据，用于比较两个值是否相等</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colorA <span class="operator">=</span> <span class="type">Color</span>(red: <span class="number">200</span>, green: <span class="number">200</span>, blue: <span class="number">200</span>)</span><br><span class="line"><span class="keyword">let</span> colorB <span class="operator">=</span> <span class="type">Color</span>(red: <span class="number">100</span>, green: <span class="number">100</span>, blue: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">if</span> colorA.alpha <span class="operator">==</span> colorB.alpha &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当需要在多线程中修改值时，优先使用<code>struct</code>，因为<code>struct</code>是线程安全的</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colorArray <span class="operator">=</span> [colorA, colorB, colorC, colorD, colorE]</span><br><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.global()</span><br><span class="line"><span class="keyword">let</span> count <span class="operator">=</span> colorArray.count</span><br><span class="line">queue.async &#123; [colorArray] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>colorArray.count &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;index=========<span class="subst">\(colorArray[index])</span>&quot;</span>)</span><br><span class="line">        <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">queue.async &#123;</span><br><span class="line">    <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">0.5</span>)</span><br><span class="line">    colorArray.remove(at: <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-------<span class="subst">\(colorArray.count)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码可以正常运行。</p>
<p>当然所谓的线程安全也是相对而言的，修改如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colorArray <span class="operator">=</span> [colorA, colorB, colorC, colorD, colorE]</span><br><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.global()</span><br><span class="line"><span class="keyword">let</span> count <span class="operator">=</span> colorArray.count</span><br><span class="line">queue.async &#123;</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>count &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;index=========<span class="subst">\(colorArray[index])</span>&quot;</span>)</span><br><span class="line">        <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">queue.async &#123;</span><br><span class="line">    <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">0.5</span>)</span><br><span class="line">    colorArray.removeLast()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-------<span class="subst">\(colorArray.count)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行代码就会Crash并打印错误：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Fatal error: Index out of range: file Swift/ContiguousArrayBuffer.swift, line <span class="number">444</span></span><br></pre></td></tr></table></figure>
<p>这是由于我移除了数组的最后一个元素，当需要打印最后一个（也就是第五个）元素时，数组中其实已经没有这个元素了，所以会数组越界Crash。而第一段代码之所以不会Crash，是因为在新的线程中会copy一份数组内容。所以当新建一个线程操作数据时copy值类型到新线程操作是线程安全的。</p>
<p>本文主要介绍了<code>struct</code>和<code>class</code>及其异同点，同时简单分析了在开发中应该如何选择<code>struct</code>还是<code>class</code>。如果我的理解有不对地方欢迎指出。</p>
<hr>
<p>本文参考：</p>
<p><a href="https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes">Apple Developer: Choosing Between Structures and Classes</a></p>
<p><a href="https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html"> The Swift Programming Language: Structures and Classes</a></p>
<p><a href="https://book.douban.com/subject/27044368/">Swift进阶：结构体和类</a></p>
]]></content>
  </entry>
  <entry>
    <title>Swift Timer循环引用问题</title>
    <url>/2021/04/10/Timer%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h6 align='right'>小时光</h6>

<h6 align='right'><a href='https://dengfeng520.github.io/'>我的博客</a></h6>

<h3 id="1、Timer产生循环引用的原因"><a href="#1、Timer产生循环引用的原因" class="headerlink" title="1、Timer产生循环引用的原因"></a>1、Timer产生循环引用的原因</h3><p>iOS 10之前使用<code>Timer</code>会因为循环引用造成持有<code>Timer</code>的<code>Controller</code>释放不掉，从而导致内存泄漏。iOS 10之后系统优化了这个问题。一般在iOS 10之前使用<code>Timer</code>的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time: <span class="type">Timer</span>?</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span>()</span> &#123;</span><br><span class="line">     <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">     time <span class="operator">=</span> <span class="type">Timer</span>.scheduledTimer(timeInterval: <span class="number">2</span>, target: <span class="keyword">self</span>, selector: #selector(timePrint), userInfo: <span class="literal">nil</span>, repeats: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timePrint</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;deinit---------------------11111&quot;</span>)</span><br><span class="line">    time<span class="operator">?</span>.invalidate()</span><br><span class="line">    time <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我在<code>Controller</code>中使用了<code>Timer</code>之后，这个<code>Controller</code>被<code>pop</code>或<code>dismiss</code>之后，其内存并不会释放，可以看到计时器也在正常运行，那么这是由于什么原因造成的呢？</p>
<h5 id="1-1、不仅仅是强引用问题"><a href="#1-1、不仅仅是强引用问题" class="headerlink" title="1.1、不仅仅是强引用问题"></a>1.1、不仅仅是强引用问题</h5><p>一般情况下，两个实例对象之前相互强引用会造成循环引用，那么按照理解，<code>Timer</code>和<code>Controller</code>之间的引用关系可能是这样的：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a983c288796b424c823c43418576d670~tplv-k3u1fbpfcp-watermark.image" alt="Timer001.png"></p>
<p>针对这种两者之间的强引用造成的循环引用，只要让其中一个为弱引用就可以解决问题，那么就来试试吧。</p>
<p>修改<code>time</code>为弱引用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> time: <span class="type">Timer</span>?</span><br></pre></td></tr></table></figure>
<p>再次运行代码，这时理想中他们之间的引用关系如下图所示，当<code>Controller</code>被释放时，因为是弱引用的关系此时<code>Timer</code>的内存也会被释放：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c7b6440fd314eca82c15ad3799094ca~tplv-k3u1fbpfcp-watermark.image" alt="Timer002.png"></p>
<p>再次运行代码，发现并没有如我所愿，当<code>Controller</code>被释放<code>Timer</code>依旧能够正常运行，所以他们的内存还是没有有效释放。为什么我使用了弱引用其内存还是没有释放掉呢？</p>
<h5 id="1-2、Timer和RunLoop之间的强引用"><a href="#1-2、Timer和RunLoop之间的强引用" class="headerlink" title="1.2、Timer和RunLoop之间的强引用"></a>1.2、<code>Timer</code>和<code>RunLoop</code>之间的强引用</h5><p>这里忽略了一个问题，<code>Timer</code>和<code>RunLoop</code>之间的关系，当<code>Timer</code>在创建之后会被当前线程的<code>RunLoop</code>进行一个强引用，如果这个对象是在主线程中创建的，那么就由主线程持有<code>Timer</code>。当我使用了弱引用后他们之间的引用关系是：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ede08b64090422288f15cfcea8b0608~tplv-k3u1fbpfcp-watermark.image" alt="Timer003.png"></p>
<p>虽然使用了弱引用，但是由于主线程中的<code>RunLoop</code>是常驻内存同时对<code>Timer</code>的强引用，<code>Timer</code>同时又对<code>Controller</code>强引用，那么这个<code>Controller</code>间接的被<code>RunLoop</code>间接的强引用。即使这个<code>Controller</code>被<code>pop</code>或<code>dismiss</code>，因为强引用的关系这部分内存也不能正常释放，这就会造成内存泄漏，并且可能会造成整个App Crash。当<code>Controller</code>被<code>pop</code>或<code>dismiss</code>时，他们在内存中的引用关系是：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe258ad368904e12b35a112ea0e9a9c0~tplv-k3u1fbpfcp-watermark.image" alt="Timer004.png"></p>
<p>关于<code>Timer</code>使用<code>Tatget</code>方式会产生循环引用的原因，国内搜到的一些博客认为是: <code>ViewController、Timer、Tatget</code>三者之间形成了一个相互强引用闭环造成的，但我在看了官方文档<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Timers/Articles/usingTimers.html#//apple_ref/doc/uid/20000807-CJBJCBDE">Using Timers: References to Timers and Object Lifetimes</a>后，个人并不认同这个观点，当然如果您有其他观点请指出并说明理由。官方文档的原文是：</p>
<p><code>Because the run loop maintains the timer, from the perspective of object lifetimes there’s typically no need to keep a reference to a timer after you’ve scheduled it. (Because the timer is passed as an argument when you specify its method as a selector, you can invalidate a repeating timer when appropriate within that method.) In many situations, however, you also want the option of invalidating the timer—perhaps even before it starts. In this case, you do need to keep a reference to the timer, so that you can stop it whenever appropriate. If you create an unscheduled timer (see Unscheduled Timers), then you must maintain a strong reference to the timer so that it is not deallocated before you use it.</code></p>
<p><code>A timer maintains a strong reference to its target. This means that as long as a timer remains valid, its target will not be deallocated. As a corollary, this means that it does not make sense for a timer’s target to try to invalidate the timer in its dealloc method—the dealloc method will not be invoked as long as the timer is valid.</code></p>
<h3 id="2、How-to-solve-it"><a href="#2、How-to-solve-it" class="headerlink" title="2、How to solve it ?"></a>2、How to solve it ?</h3><p>知道了造成<code>Timer</code>造成循环引用的原因，那么该如何解决<code>Timer</code>造成的循环引用问题呢？</p>
<h5 id="2-1、使用系统提供Block方法"><a href="#2-1、使用系统提供Block方法" class="headerlink" title="2.1、使用系统提供Block方法"></a>2.1、使用系统提供Block方法</h5><p>iOS 10之后，系统已经优化了这个问题，如果是iOS 10之后的版本，完全可以使用系统提供的<code>Block</code>回调方式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">#available</span>(<span class="keyword">iOS</span> <span class="number">10.0</span>, <span class="operator">*</span>) &#123;</span><br><span class="line">      <span class="comment">/// iOS 10之后采用`Block`方式解决Timer 循环引用问题</span></span><br><span class="line">      time <span class="operator">=</span> <span class="type">Timer</span>.scheduledTimer(withTimeInterval: <span class="number">2</span>, repeats: <span class="literal">true</span>, block: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (timer) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> `self` <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            <span class="keyword">self</span>.timePrint()</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上现在开发一款新的App时可以不考虑iOS 10以下的兼容处理，因为苹果官方统计的数据：<a href="https://developer.apple.com/support/app-store/">Apple Developer: iOS and iPadOS Usage</a>。截止2021年4月10号，只有**8%**的iPhone用户还在使用<code>iOS 13</code>以下的版本，就连微信这种达亿级用户的<code>App</code>都只支持iOS 11以后版本。当然对于一些比较老的App要支持iOS 10之前的系统或者你有一个爱抬杠的产品经理，那么只能做老系统的兼容处理。</p>
<h5 id="2-2、使用GCD提供的DispatchSource替换Timer"><a href="#2-2、使用GCD提供的DispatchSource替换Timer" class="headerlink" title="2.2、使用GCD提供的DispatchSource替换Timer"></a>2.2、使用GCD提供的<code>DispatchSource</code>替换<code>Timer</code></h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source: <span class="type">DispatchSourceTimer</span>?</span><br><span class="line"></span><br><span class="line">source <span class="operator">=</span> <span class="type">DispatchSource</span>.makeTimerSource(flags: [], queue: .global())</span><br><span class="line">source.schedule(deadline: .now(), repeating: <span class="number">2</span>)</span><br><span class="line">source.setEventHandler &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br><span class="line">source.resume()</span><br><span class="line"></span><br><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">     source<span class="operator">?</span>.cancel()</span><br><span class="line">     source <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3、模仿系统提供的closure"><a href="#2-3、模仿系统提供的closure" class="headerlink" title="2.3、模仿系统提供的closure"></a>2.3、模仿系统提供的<code>closure</code></h5><p>对系统的<code>Timer</code>做扩展处理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">rp_scheduledTimer</span>(<span class="title">timeInterval</span> <span class="title">ti</span>: <span class="title">TimeInterval</span>, <span class="title">repeats</span> <span class="title">yesOrNo</span>: <span class="title">Bool</span>, <span class="title">closure</span>: @<span class="title">escaping</span> (<span class="title">Timer</span>) -&gt; <span class="title">Void</span>) -&gt; <span class="title">Timer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.scheduledTimer(timeInterval: ti, target: <span class="keyword">self</span>, selector: #selector(<span class="type">RP_TimerHandle</span>(timer:)), userInfo: closure, repeats: yesOrNo)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@objc</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">RP_TimerHandle</span>(<span class="title">timer</span>: <span class="title">Timer</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> handleClosure <span class="operator">=</span> &#123; &#125;</span><br><span class="line">        handleClosure <span class="operator">=</span> timer.userInfo <span class="keyword">as!</span> () -&gt; ()</span><br><span class="line">        handleClosure()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">#available</span>(<span class="keyword">iOS</span> <span class="number">10.0</span>, <span class="operator">*</span>) &#123;</span><br><span class="line">      <span class="comment">/// iOS 10之后采用`Block`方式解决Timer 循环引用问题</span></span><br><span class="line">      time <span class="operator">=</span> <span class="type">Timer</span>.scheduledTimer(withTimeInterval: <span class="number">2</span>, repeats: <span class="literal">true</span>, block: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (timer) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> `self` <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            <span class="keyword">self</span>.timePrint()</span><br><span class="line">      &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/// iOS 10之前的解决方案： 模仿系统的`closure` 解决Timer循环引用问题</span></span><br><span class="line">      time <span class="operator">=</span> <span class="type">Timer</span>.rp_scheduledTimer(timeInterval: <span class="number">2</span>, repeats: <span class="literal">true</span>, closure: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (timer) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> `self` <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            <span class="keyword">self</span>.timePrint()</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timePrint</span>()</span> &#123;</span><br><span class="line">     <span class="comment">// de something...</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    time<span class="operator">?</span>.invalidate()</span><br><span class="line">    time <span class="operator">=</span> <span class="literal">nil</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-4、其他解决方法"><a href="#2-4、其他解决方法" class="headerlink" title="2.4、其他解决方法"></a>2.4、其他解决方法</h5><ul>
<li>使用<code>Runtime</code>给对象添加消息处理的方法</li>
<li>使用<code>NSProxy</code>类作为中间对象</li>
</ul>
<p>本文主要分析了在开发中使用<code>Timer</code>造成循环引用的原因和一些常用的解决方案。</p>
<p>本文参考：</p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Timers/Articles/usingTimers.html#//apple_ref/doc/uid/20000807-CJBJCBDE">Apple Developer: Using Timers</a></p>
<p><a href="https://stackoverflow.com/questions/16821736/weak-reference-to-nstimer-target-to-prevent-retain-cycle">stackoverflow: Weak Reference to NSTimer Target To Prevent Retain Cycle</a></p>
]]></content>
  </entry>
  <entry>
    <title>iOS 面试总结</title>
    <url>/2020/04/10/iOS%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="1、UI视图"><a href="#1、UI视图" class="headerlink" title="1、UI视图"></a>1、UI视图</h3><h5 id="1-1、常见面试问题"><a href="#1-1、常见面试问题" class="headerlink" title="1.1、常见面试问题"></a>1.1、常见面试问题</h5><ul>
<li>UITableView 重用机制</li>
<li>UITableView数据源同步</li>
<li>事件传递&amp;视图响应</li>
<li>图像显示原理</li>
<li>UI卡顿、掉帧</li>
<li>UI绘制原理、异步绘制</li>
<li>离屏渲染</li>
</ul>
<h5 id="1-2、UITableView重用机制"><a href="#1-2、UITableView重用机制" class="headerlink" title="1.2、UITableView重用机制"></a>1.2、UITableView重用机制</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b90aca35e5c4e7a8f773621d9ec0ac4~tplv-k3u1fbpfcp-watermark.image" alt="UITableView.png"></p>
<h3 id="2、事件传递"><a href="#2、事件传递" class="headerlink" title="2、事件传递"></a>2、事件传递</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回最终哪个UIView相应点击事件</span><br><span class="line">open func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView?</span><br><span class="line">&#x2F;&#x2F; 返回某一个点击的位置是否在视图范围内</span><br><span class="line">open func point(inside point: CGPoint, with event: UIEvent?) -&gt; Bool</span><br></pre></td></tr></table></figure>
<h3 id="3、UIView-和-CALayer"><a href="#3、UIView-和-CALayer" class="headerlink" title="3、UIView 和 CALayer"></a>3、UIView 和 CALayer</h3><ul>
<li>UIView提供内容以及负责处理触摸等事件，参与事件响应链</li>
<li>CALayer负责显示内容contents</li>
<li>体现了系统设置上的单一性原则</li>
</ul>
<h3 id="4、图像绘制原理"><a href="#4、图像绘制原理" class="headerlink" title="4、图像绘制原理"></a>4、图像绘制原理</h3><h5 id="4-1、UIView绘制原理"><a href="#4-1、UIView绘制原理" class="headerlink" title="4.1、UIView绘制原理"></a>4.1、UIView绘制原理</h5><h5 id="4-2、离屏渲染"><a href="#4-2、离屏渲染" class="headerlink" title="4.2、离屏渲染"></a>4.2、离屏渲染</h5><h6 id="4-2-1-什么是离屏渲染"><a href="#4-2-1-什么是离屏渲染" class="headerlink" title="4.2.1 什么是离屏渲染"></a>4.2.1 什么是离屏渲染</h6><ul>
<li>On- Screen Rendering 当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行</li>
<li>Off-Screen Rendering 离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作</li>
</ul>
<h6 id="4-2-2-什么时候会出发离屏渲染"><a href="#4-2-2-什么时候会出发离屏渲染" class="headerlink" title="4.2.2 什么时候会出发离屏渲染"></a>4.2.2 什么时候会出发离屏渲染</h6><ul>
<li>圆角和maskToBounds一起使用</li>
<li>图层蒙版</li>
<li>阴影</li>
<li>光栅化</li>
</ul>
<h5 id="4-2-3-为什么要避免离屏渲染"><a href="#4-2-3-为什么要避免离屏渲染" class="headerlink" title="4.2.3 为什么要避免离屏渲染"></a>4.2.3 为什么要避免离屏渲染</h5><ul>
<li><p>创建新的渲染缓冲区</p>
</li>
<li><p>在触发离屏渲染时会增加GPU的工作量，很可能造成掉帧和卡顿</p>
</li>
</ul>
<h5 id="4-3-异步绘制"><a href="#4-3-异步绘制" class="headerlink" title="4.3 异步绘制"></a>4.3 异步绘制</h5><h5 id="4-4、滑动优化方案"><a href="#4-4、滑动优化方案" class="headerlink" title="4.4、滑动优化方案"></a>4.4、滑动优化方案</h5><ul>
<li><p>GPU </p>
<ul>
<li>纹理渲染</li>
<li>视图混合</li>
</ul>
</li>
<li><p>CPU</p>
<ul>
<li>对象创建、调整、销毁</li>
<li>预排版、（布局计算、文本计算）</li>
<li>预渲染（文本异步绘制、图片编解码）</li>
</ul>
</li>
</ul>
<h3 id="5、分类"><a href="#5、分类" class="headerlink" title="5、分类"></a>5、分类</h3><h5 id="5-0、常见面试问题"><a href="#5-0、常见面试问题" class="headerlink" title="5.0、常见面试问题"></a>5.0、常见面试问题</h5><ul>
<li>分类</li>
<li>关联对象</li>
<li>扩展、代理</li>
<li>KVC、KVO</li>
<li>NSNotification（通知）的原理是什么</li>
<li>属性关键字</li>
</ul>
<h5 id="5-1、分类做了那些事？"><a href="#5-1、分类做了那些事？" class="headerlink" title="5.1、分类做了那些事？"></a>5.1、分类做了那些事？</h5><ul>
<li>申明私有方法</li>
<li>分解体积庞大的类文件</li>
<li>把Framework的私有方法公开</li>
<li>系统方法做一个扩展</li>
</ul>
<h5 id="5-2、分类的特点"><a href="#5-2、分类的特点" class="headerlink" title="5.2、分类的特点"></a>5.2、分类的特点</h5><ul>
<li>运行时决议，在运行时添加到宿主类上</li>
<li>可以为系统类添加分类</li>
</ul>
<h5 id="5-3、分类可以添加哪些内容"><a href="#5-3、分类可以添加哪些内容" class="headerlink" title="5.3、分类可以添加哪些内容"></a>5.3、分类可以添加哪些内容</h5><ul>
<li>实例方法</li>
<li>类方法</li>
<li>协议</li>
<li>属性（只添加了get方法，和set方法）</li>
<li>分类可以通过runtime关联对象的方式添加实例变量</li>
</ul>
<h5 id="5-4、分类方法"><a href="#5-4、分类方法" class="headerlink" title="5.4、分类方法"></a>5.4、分类方法</h5><ul>
<li>分类添加的方法可以覆盖原类方法</li>
<li>同名分类方法谁能生效取决于编译顺序</li>
<li>名字相同的分类会引起编译报错</li>
</ul>
<h5 id="5-5、怎样为分类添加成员变量"><a href="#5-5、怎样为分类添加成员变量" class="headerlink" title="5.5、怎样为分类添加成员变量"></a>5.5、怎样为分类添加成员变量</h5><ul>
<li>不能在分类申明时添加成员变量，只能用关联对象的方法添加成员变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,</span><br><span class="line">                         id _Nullable value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc_removeAssociatedObjects(id _Nonnull object)</span><br></pre></td></tr></table></figure>
<h5 id="5-6、分类添加的对象被添加到哪了？"><a href="#5-6、分类添加的对象被添加到哪了？" class="headerlink" title="5.6、分类添加的对象被添加到哪了？"></a>5.6、分类添加的对象被添加到哪了？</h5><ul>
<li>关联对象由<code>AssicucationsManager</code>管理并在<code>AssociationsHashMap</code>存储。</li>
<li>所有对象的关联内容都在同一个全局容器中。</li>
</ul>
<h4 id="6、扩展"><a href="#6、扩展" class="headerlink" title="6、扩展"></a>6、扩展</h4><h6 id="6-1、一般用扩展做什么"><a href="#6-1、一般用扩展做什么" class="headerlink" title="6.1、一般用扩展做什么"></a>6.1、一般用扩展做什么</h6><ul>
<li>申明私有属性</li>
<li>申明私有方法</li>
<li>申明私有成员变量</li>
</ul>
<h5 id="2、扩展的"><a href="#2、扩展的" class="headerlink" title=".2、扩展的"></a>.2、扩展的</h5><ul>
<li>编译时决议</li>
<li>只以申明的形式存在，多数情况下寄生于宿主类的.m中</li>
<li>不能为系统类添加扩展</li>
</ul>
<h4 id="7、代理"><a href="#7、代理" class="headerlink" title="7、代理"></a>7、代理</h4><h5 id="7-1、什么是代理"><a href="#7-1、什么是代理" class="headerlink" title="7.1、什么是代理"></a>7.1、什么是代理</h5><ul>
<li>代理是一种软件设计模式</li>
<li>iOS中以@protocol形式体现</li>
<li>代理是一对一的</li>
</ul>
<h5 id="7-2、通知"><a href="#7-2、通知" class="headerlink" title="7.2、通知"></a>7.2、通知</h5><ul>
<li>是使用观察者模式来实现的用于跨层传递消息机制</li>
<li>通知是一对多的</li>
</ul>
<h5 id="7-3、KVO"><a href="#7-3、KVO" class="headerlink" title="7.3、KVO"></a>7.3、KVO</h5><ul>
<li>KVO 是观察者模式的一种实现方式</li>
<li>Apple使用了isa混写（isa-swizzling）来实现KVO</li>
<li>使用setter方法改变值KVO才会生效</li>
<li>使用setValue:forKey:改变值KVO才会生效</li>
<li>成员变量直接修改需手动添加KVO才会生效</li>
</ul>
<h4 id="8、关键字"><a href="#8、关键字" class="headerlink" title="8、关键字"></a>8、关键字</h4><ul>
<li>读写权限 （readonly,）</li>
</ul>
<h5 id="8-1、weak"><a href="#8-1、weak" class="headerlink" title="8.1、weak"></a>8.1、weak</h5><ul>
<li>不改变被修饰对象的引用计数</li>
<li>所指对象在被释放之后会自动置为nil</li>
<li>多数用于解决循环引用计数</li>
</ul>
<h5 id="8-2-原子性"><a href="#8-2-原子性" class="headerlink" title="8.2 原子性"></a>8.2 原子性</h5><ul>
<li>atomic 对赋值和获取保证线程安全，</li>
<li>nonatomic 不保证线程安全</li>
</ul>
<h5 id="8-3-引用计数"><a href="#8-3-引用计数" class="headerlink" title="8.3 引用计数"></a>8.3 引用计数</h5><ul>
<li><p>retain 在MRC中使用</p>
</li>
<li><p>strong 在ARC中使用</p>
</li>
<li><p>assign 修饰基本数据类型，如Int</p>
<ul>
<li> 修饰基本数据类型，</li>
<li>修饰对象类型是，不改变其引用计数</li>
<li>会产生垂直指针</li>
</ul>
</li>
<li><p>unsafe_unretained 在MRC中使用</p>
<h5 id="8-4-weak-和-assign的区别和相同"><a href="#8-4-weak-和-assign的区别和相同" class="headerlink" title="8.4 weak 和 assign的区别和相同"></a>8.4 weak 和 assign的区别和相同</h5></li>
</ul>
<p>区别：</p>
<ul>
<li>weak只能修饰对象类型，assign既能修饰对象类型又能修饰基本数据类型</li>
<li>weak修饰的对象被释放后自动置为nil, assign所修饰的对象在被释放后assign指针依旧指向这个对象的地址</li>
</ul>
<p>相同： </p>
<ul>
<li>在修饰对象时，weak 和 assign 都不改变对象的引用计数</li>
</ul>
<h5 id="8-5-copy"><a href="#8-5-copy" class="headerlink" title="8.5 copy"></a>8.5 copy</h5><table>
<thead>
<tr>
<th align="center">源对象类型</th>
<th align="center">拷贝方式</th>
<th align="center">目标对象类型</th>
<th align="center">拷贝类型（深/浅）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mutable对象</td>
<td align="center">copy</td>
<td align="center">不可变</td>
<td align="center">深copy</td>
</tr>
<tr>
<td align="center">mutable对象</td>
<td align="center">mutableCopy</td>
<td align="center">可变</td>
<td align="center">深copy</td>
</tr>
<tr>
<td align="center">immutable对象</td>
<td align="center">copy</td>
<td align="center">不可变</td>
<td align="center">浅copy</td>
</tr>
<tr>
<td align="center">immutable对象</td>
<td align="center">mutableCopy</td>
<td align="center">可变</td>
<td align="center">深copy</td>
</tr>
</tbody></table>
<ul>
<li>可变对象的copy和mutableCopy都是深copy</li>
<li>不可变对象的copy是浅copy，mutableCopy是深copy</li>
<li>copy方法返回的都是不可变对象</li>
</ul>
<h4 id="9、RunTime"><a href="#9、RunTime" class="headerlink" title="9、RunTime"></a>9、RunTime</h4><p>常见面试问题：</p>
<ul>
<li>消息发送流程</li>
<li>消息转发流程</li>
<li>类方法和实例方法动态解析</li>
<li>类的本质</li>
<li>分类初始化</li>
<li>分类方法覆盖原类方法</li>
<li>KVO和KVC的原理</li>
<li>Method Swizzling原理，解决Crash问题</li>
</ul>
<h5 id="9-1、objc-object"><a href="#9-1、objc-object" class="headerlink" title="9.1、objc_object"></a>9.1、objc_object</h5><p>iOS中所有的对象都是的最终父类都是id类型，在RunTime中最终都转换成了<code>objc_object</code>结构体，该结构体主要包含四个部分</p>
<ul>
<li><code>isa_t</code>共用体</li>
<li>关于<code>isa</code>操作相关</li>
<li>弱引用相关，如该对象是否被弱引用过</li>
<li>关联对象相关，如是否关联属性</li>
<li>内存管理相关方法的实现</li>
</ul>
<h5 id="9-2、objc-class"><a href="#9-2、objc-class" class="headerlink" title="9.2、objc_class"></a>9.2、objc_class</h5><p>iOS中所有的<code>Class</code>对象在<code>RunTime</code>中最终都转换成了<code>objc-class</code>结构体，<code>objc_class</code>继承自<code>objc_object</code>，<code>objc_class</code>包含以下内容：</p>
<ul>
<li><code>Class superClass</code>,是一个Class类型的类对象，指向其父类对象</li>
<li><code>cache_t cache</code>方法缓存</li>
<li><code>class_data_bits_t bits</code>定义的属性</li>
</ul>
<h5 id="9-2、isa指针"><a href="#9-2、isa指针" class="headerlink" title="9.2、isa指针"></a>9.2、isa指针</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>; <span class="comment">// 是否Tagged Poniter</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>; <span class="comment">// 是否有关联引用</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>; <span class="comment">// 是否有析构器</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// 类的指针 MACH_VM_MAX_ADDRESS 0x1000000000</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>; <span class="comment">// 是否初始化完成</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>; <span class="comment">// 是否被弱引用</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>; <span class="comment">// 是否正在释放内存</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>; <span class="comment">// 引用计数是否过大</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>; <span class="comment">// 引用计数</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li><code>isa_t</code>分为指针型isa和非指针型isa</li>
<li>对象的isa指针指向其类对象</li>
<li>类对象的isa指针指向其元类对象</li>
</ul>
<h5 id="9-3、cache-t"><a href="#9-3、cache-t" class="headerlink" title="9.3、cache_t"></a>9.3、cache_t</h5><ul>
<li>用于快速查找方法执行函数</li>
<li>是可增量扩展的哈希表结构</li>
<li>是局部性原理的最佳应用</li>
<li><code>cache_t</code>数组中存储的数据是<code>key</code>和<code>IMP</code>,我们可以通过查找<code>key</code>的方法实现来查找<code>IMP</code>的方法实现</li>
</ul>
<h5 id="9-4、class-data-bits-t-bits"><a href="#9-4、class-data-bits-t-bits" class="headerlink" title="9.4、class_data_bits_t bits"></a>9.4、class_data_bits_t bits</h5><ul>
<li> <code>class_data_bits_t</code>主要是对<code>class_rw_t</code>的封装</li>
<li><code>class_rw_t</code>代表了类相关的<strong>读写</strong>信息，对<code>class_ro_t</code>的封装</li>
<li><code>class_ro_t</code>代表了类相关的只读信息</li>
</ul>
<h5 id="9-5、Tagged-Pointer原理"><a href="#9-5、Tagged-Pointer原理" class="headerlink" title="9.5、Tagged Pointer原理"></a>9.5、Tagged Pointer原理</h5><h3 id="10、多线程相关"><a href="#10、多线程相关" class="headerlink" title="10、多线程相关"></a>10、多线程相关</h3><h5 id="10-0、常见面试问题"><a href="#10-0、常见面试问题" class="headerlink" title="10.0、常见面试问题"></a>10.0、常见面试问题</h5><ul>
<li>GCD</li>
<li>NSOperation / NSOperationQueue</li>
<li>Thred</li>
<li>线程同步、资源共享</li>
<li>互斥锁、自旋锁、递归锁</li>
</ul>
<h5 id="10-1、iOS系统提供了几种多线程技术各自的特点是怎样的"><a href="#10-1、iOS系统提供了几种多线程技术各自的特点是怎样的" class="headerlink" title="10.1、iOS系统提供了几种多线程技术各自的特点是怎样的"></a>10.1、iOS系统提供了几种多线程技术各自的特点是怎样的</h5><ul>
<li>GCD 实现一些简单的线程同步</li>
<li>Thread + RunLoop = 常驻线程</li>
</ul>
<p>一般常用于线程保活，分为三步：</p>
<p>1、在线程的Block中取当前RunLoop</p>
<p>2、为RunLoop添加NSMachPort或者 Source</p>
<p>3、启动这个RunLoop</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thread <span class="operator">=</span> <span class="type">Thread</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">     <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> <span class="operator">=</span> `self` <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">     <span class="keyword">self</span>.configThread()</span><br><span class="line">&#125;</span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">configThread</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--------------1&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> runLoop <span class="operator">=</span> <span class="type">RunLoop</span>.current</span><br><span class="line">    runLoop.add(<span class="type">NSMachPort</span>(), forMode: .common)</span><br><span class="line">    runLoop.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Operation和OperationQueue,可以方便对任务的状态的控制，所以一些常见的第三方框架，<code>SDWebImage,AFNetworking</code>等</li>
</ul>
<h5 id="10-2-、怎样用GCD实现多读单写"><a href="#10-2-、怎样用GCD实现多读单写" class="headerlink" title="10.2 、怎样用GCD实现多读单写"></a>10.2 、怎样用GCD实现多读单写</h5><ul>
<li>写： 开启多个任务去修改数据，保证资源部被抢占，比如卖票系统，此处使用<strong>异步栅栏任务</strong></li>
<li>读： 允许多个任务同时加入队列，但要保证一个一个执行，此处使用<strong>同步并行</strong></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并发队列</span></span><br><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">&quot;com.tsn.readWriteQueue&quot;</span>, attributes: .concurrent)</span><br><span class="line"><span class="comment">// 数据源 一般是file</span></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> dataArray: [<span class="type">String</span>] <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line"> <span class="comment">// 读数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getData</span>(<span class="keyword">_</span> <span class="params">index</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="keyword">var</span> result: <span class="type">String</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 并发同步读取数据</span></span><br><span class="line">    queue.sync &#123;</span><br><span class="line">        result <span class="operator">=</span> dataArray[index]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addData</span>(<span class="keyword">_</span> <span class="params">data</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">    queue.async(execute: <span class="type">DispatchWorkItem</span>(qos: .default, flags: .barrier, block: &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataArray.append(data)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;======<span class="subst">\(<span class="keyword">self</span>.dataArray)</span>&quot;</span>)</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="10-3、Operation对象在Finished之后是怎样从queue当中移除的"><a href="#10-3、Operation对象在Finished之后是怎样从queue当中移除的" class="headerlink" title="10.3、Operation对象在Finished之后是怎样从queue当中移除的"></a>10.3、Operation对象在Finished之后是怎样从queue当中移除的</h5><p>通过KVO的方式达到对<code>Operation</code>移除的目的。</p>
<h5 id="10-4、你都使用过哪些锁？结合实际谈谈你是怎样使用的"><a href="#10-4、你都使用过哪些锁？结合实际谈谈你是怎样使用的" class="headerlink" title="10.4、你都使用过哪些锁？结合实际谈谈你是怎样使用的"></a>10.4、你都使用过哪些锁？结合实际谈谈你是怎样使用的</h5><p>递归锁解决死锁问题</p>
<h5 id="10-5、线程死锁"><a href="#10-5、线程死锁" class="headerlink" title="10.5、线程死锁"></a>10.5、线程死锁</h5><ul>
<li>队列引起的循环等待</li>
<li>主线程中+同步造成死锁</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.main.sync &#123; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="10-6、ABC三个任务并发，完成后执行任务D"><a href="#10-6、ABC三个任务并发，完成后执行任务D" class="headerlink" title="10.6、ABC三个任务并发，完成后执行任务D"></a>10.6、ABC三个任务并发，完成后执行任务D</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">&quot;com.tsn.groupQueue&quot;</span>)</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> group <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br><span class="line">        <span class="keyword">let</span> array <span class="operator">=</span> [<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>]</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>array.count &#123;</span><br><span class="line">            queue.async(group: group) &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;---------<span class="subst">\(array[index])</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        group.notify(queue: .main) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;---------D&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="10-7、Operation"><a href="#10-7、Operation" class="headerlink" title="10.7、Operation"></a>10.7、Operation</h5><p>需要和<code>OperationQueue</code>配合使用来实现多线程方案，</p>
<ul>
<li>添加任务依赖或移除依赖 这是GCD和Thread所不具备的</li>
<li>任务执行状态控制<ul>
<li><a href="https://developer.apple.com/documentation/foundation/operation/1412992-isready">isReady</a>是否可执行，一般用于异步的情况下</li>
<li><a href="https://developer.apple.com/documentation/foundation/operation/1415621-isexecuting">isExexuting</a>标记<code>Operation</code>是否正在执行中</li>
<li><a href="https://developer.apple.com/documentation/foundation/operation/1413540-isfinished">isFinished</a>标记<code>Operation</code>是否已经执行完成了，一般用于异步</li>
<li><a href="https://developer.apple.com/documentation/foundation/operation#1661262">isCancelled</a>标记<code>Operation</code>是否已经<code>cancel</code>了</li>
</ul>
</li>
<li>可以控制最大并发量</li>
<li>如果只重写<code>main</code>方法，底层控制变更任务执行完成状态，以及任务退出</li>
<li>如果重写了<code>start</code>方法，自行控制任务状态</li>
</ul>
<h3 id="11、内存管理"><a href="#11、内存管理" class="headerlink" title="11、内存管理"></a>11、内存管理</h3><h5 id="11-0、常见面试问题："><a href="#11-0、常见面试问题：" class="headerlink" title="11.0、常见面试问题："></a>11.0、常见面试问题：</h5><ul>
<li>ARC </li>
<li>MRC</li>
<li>引用计数机制</li>
<li>弱引用表</li>
<li>AutoReleasePool</li>
<li>循环引用</li>
</ul>
<h5 id="11-1、内存布局"><a href="#11-1、内存布局" class="headerlink" title="11.1、内存布局"></a>11.1、内存布局</h5><ul>
<li><strong>stack</strong>: 栈内存， 方法调用</li>
<li><strong>heap</strong>: 堆内存，通过<code>alloc</code>等分配的对象</li>
<li><strong>bss</strong>: 未初始化的全局变量</li>
<li><strong>data</strong>：已初始化的全局变量等</li>
<li><strong>txt</strong>: 程序代码</li>
</ul>
<h5 id="11-2、内存管理方案"><a href="#11-2、内存管理方案" class="headerlink" title="11.2、内存管理方案"></a>11.2、内存管理方案</h5><p>iOS系统会针对不同情况下使用不同的内存管理方法：</p>
<ul>
<li>对于一些小的对象，如<code>Number</code>,通过<code>TaggedPointer</code>来进行内存管理</li>
<li>对于64位的<code>NONPOINTER_ISA </code>,非指针型的ISA</li>
<li>散列表 是一种复杂的数据结构，其中包含了弱引用表 和 散列引用计数表</li>
</ul>
<h5 id="11-3-引用计数"><a href="#11-3-引用计数" class="headerlink" title="11.3 引用计数"></a>11.3 引用计数</h5><ul>
<li>ARC是<code>LLVM</code>和<code>Runtime</code>协作的结果</li>
<li>ARC中禁止手动调用<code>retain/release/retainCount/dealloc</code></li>
<li>ARC中新增了<code>weak 、strong</code>属性关键字</li>
</ul>
<h5 id="11-4-weak"><a href="#11-4-weak" class="headerlink" title="11.4 weak"></a>11.4 weak</h5><ul>
<li>添加<code>weak</code>时实现</li>
</ul>
<p>一个被申明为<code>__weak</code>的对象，经过编译器的编译之后回调用<code>objc_initWeak()</code>方法，然后经过一系列的函数调用栈，最终在<code>weak_reginster_no_lock()</code>函数中进行弱引用的添加，具体添加的位置通过<code>hash</code>算法来添加或查找的，如果查找位置中已经存在了一个弱引用数组，那么就把这个新的变量添加到这个弱引用数组中，如果没有弱引用数组那么就创建一个，并把第零个设置这个变量的weak指针,后面都添加为<code>nil</code>.</p>
<ul>
<li>清除<code>weak</code>变量，同时设置指向为<code>nil</code></li>
</ul>
<p>当一个对象调用<code>dealloc()</code>方法中，在<code>dealloc()</code>实现中会调用弱引用清除的相关函数。在这个函数的内部实现中会根据当前对象指针查找弱引用表，把当前对象相对应的弱引用数组取出，然后遍历数组中所有的弱引用指针，分别置为<code>nil</code>。</p>
<h5 id="11-5、自动释放池（-autoreleasepool）"><a href="#11-5、自动释放池（-autoreleasepool）" class="headerlink" title="11.5、自动释放池（@autoreleasepool）"></a>11.5、自动释放池（@autoreleasepool）</h5><ul>
<li><p><strong>@autoreleasepool</strong>的实现结构</p>
<ul>
<li>是以栈为节点通过双向链表的形式组合而成</li>
<li>是和线程一一对应的</li>
</ul>
</li>
<li><p><strong>@autoreleasepool</strong>的实现原理是怎样的？</p>
</li>
</ul>
<p>以栈为节点通过双向链表的形式组成的数据结构</p>
<ul>
<li><p><strong>@autoreleasepool</strong>为何可以嵌套使用？</p>
</li>
<li><p>在for循环中alloc图片数据等内存消耗较大场景手动插入**@autoreleasepool**</p>
</li>
</ul>
<h5 id="11-6、循环引用"><a href="#11-6、循环引用" class="headerlink" title="11.6、循环引用"></a>11.6、循环引用</h5><ul>
<li>自循环引用</li>
<li>相互循环引用</li>
<li>多循环引用</li>
</ul>
<h6 id="11-6-1、产生循环引用的条件"><a href="#11-6-1、产生循环引用的条件" class="headerlink" title="11.6.1、产生循环引用的条件"></a>11.6.1、产生循环引用的条件</h6><ul>
<li>代理</li>
<li>NSTimer</li>
<li>Block</li>
<li>大环引用</li>
</ul>
<h6 id="11-6-2、如破除循环引用"><a href="#11-6-2、如破除循环引用" class="headerlink" title="11.6.2、如破除循环引用"></a>11.6.2、如破除循环引用</h6><ul>
<li>避免产生循环引用</li>
<li>在合适的时机解除循环引用</li>
</ul>
<h6 id="11-6-3、具体的方案有哪些？"><a href="#11-6-3、具体的方案有哪些？" class="headerlink" title="11.6.3、具体的方案有哪些？"></a>11.6.3、具体的方案有哪些？</h6><ul>
<li>__weak </li>
<li>__block </li>
<li>__unsafe_unretained 由这个关键字修饰的关键字也没有增加引用计数<ul>
<li>修饰对象不会增加其引用计数，避免了循环引用</li>
<li>如果被修饰对象在某一时机被释放会产生垂直指针</li>
</ul>
</li>
</ul>
<h6 id="11-6-4、NSTimer-产生循环引用问题"><a href="#11-6-4、NSTimer-产生循环引用问题" class="headerlink" title="11.6.4、NSTimer 产生循环引用问题"></a>11.6.4、NSTimer 产生循环引用问题</h6><p> iOS 10以后通过<code>Block</code>方式，这时要注意的是和<code>Block</code>产生的循环引用；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (strong, nonatomic) NSTimer *timer;</span><br><span class="line">if (@available(iOS 10.0, *)) &#123;</span><br><span class="line">    __weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">    self.timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:2 repeats:true block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">        [weakSelf timePrint];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)timePrint &#123;</span><br><span class="line">    NSLog(@&quot;-------------------&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;------------------dealloc&quot;);</span><br><span class="line">    [self.timer invalidate];</span><br><span class="line">    _timer &#x3D; nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般要处理的是iOS 10之前的系统，方法有多种，可以</p>
<ul>
<li><p>模仿系统的采用Block方式</p>
<p>新建<code>NSTimer</code>分类</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;NSTimer+Category.h&quot;</span><br><span class="line"></span><br><span class="line">@interface NSTimer (Category)</span><br><span class="line">+ (NSTimer *)RP_ScheduledTimerWithTimeInterval:(NSTimeInterval)timeInterval repeats:(BOOL)repeats block:(void(^)(void))timerBlock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSTimer (Category)</span><br><span class="line">+ (NSTimer *)RP_ScheduledTimerWithTimeInterval:(NSTimeInterval)timeInterval repeats:(BOOL)repeats block:(void(^)(void))timerBlock &#123;</span><br><span class="line">    return [self scheduledTimerWithTimeInterval:timeInterval</span><br><span class="line">                                             target:self</span><br><span class="line">                                           selector:@selector(RP_TimerHandle:)</span><br><span class="line">                                           userInfo:[timerBlock copy] &#x2F;&#x2F;注意copy</span><br><span class="line">                                            repeats:repeats];</span><br><span class="line">&#125;</span><br><span class="line">+ (void)RP_TimerHandle:(NSTimer *)timer &#123;</span><br><span class="line">    void(^block)(void) &#x3D; timer.userInfo;</span><br><span class="line">    if (block) &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>调用方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">self.timer &#x3D; [NSTimer RP_ScheduledTimerWithTimeInterval:2 repeats:true block:^&#123;</span><br><span class="line">     [weakSelf timePrint];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">- (void)timePrint &#123;</span><br><span class="line">    NSLog(@&quot;-------------------&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">rp_scheduledTimer</span>(<span class="title">timeInterval</span> <span class="title">ti</span>: <span class="title">TimeInterval</span>, <span class="title">repeats</span> <span class="title">yesOrNo</span>: <span class="title">Bool</span>, <span class="title">closure</span>: @<span class="title">escaping</span> (<span class="title">Timer</span>) -&gt; <span class="title">Void</span>) -&gt; <span class="title">Timer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.scheduledTimer(timeInterval: ti, target: <span class="keyword">self</span>, selector: #selector(<span class="type">RP_TimerHandle</span>(timer:)), userInfo: closure, repeats: yesOrNo)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">@objc</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">RP_TimerHandle</span>(<span class="title">timer</span>: <span class="title">Timer</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> handleClosure <span class="operator">=</span> &#123; &#125;</span><br><span class="line">        handleClosure <span class="operator">=</span> timer.userInfo <span class="keyword">as!</span> () -&gt; ()</span><br><span class="line">        handleClosure()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">#available</span>(<span class="keyword">iOS</span> <span class="number">10.0</span>, <span class="operator">*</span>) &#123;</span><br><span class="line">     time <span class="operator">=</span> <span class="type">Timer</span>.scheduledTimer(withTimeInterval: <span class="number">2</span>, repeats: <span class="literal">true</span>, block: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (timer) <span class="keyword">in</span></span><br><span class="line">          <span class="keyword">guard</span> <span class="keyword">let</span> `self` <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">          <span class="keyword">self</span>.timePrint()</span><br><span class="line">      &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     time <span class="operator">=</span> <span class="type">Timer</span>.rp_scheduledTimer(timeInterval: <span class="number">2</span>, repeats: <span class="literal">true</span>, closure: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (timer) <span class="keyword">in</span></span><br><span class="line">          <span class="keyword">guard</span> <span class="keyword">let</span> `self` <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">          <span class="keyword">self</span>.timePrint()</span><br><span class="line">     &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>采用中间件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;objc&#x2F;runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) id target;</span><br><span class="line"></span><br><span class="line">_target &#x3D; [NSObject new];</span><br><span class="line">class_addMethod([_target class], @selector(timePrint), (IMP)timerIMP, &quot;v@:&quot;);</span><br><span class="line">&#x2F;&#x2F; self换成_target就没有了循环引用了</span><br><span class="line">self.timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:2 target:_target selector:@selector(timePrint) userInfo:nil repeats:true];</span><br><span class="line"></span><br><span class="line">void timerIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    NSLog(@&quot;-------------------&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)timePrint &#123;</span><br><span class="line">    NSLog(@&quot;-------------------&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12、Block"><a href="#12、Block" class="headerlink" title="12、Block"></a>12、Block</h3><h5 id="12-0、常见面试问题"><a href="#12-0、常见面试问题" class="headerlink" title="12.0、常见面试问题"></a>12.0、常见面试问题</h5><ul>
<li>Block的本质(什么是Block)</li>
<li>为什么Block会产生循环引用</li>
<li>__block修饰符的本质</li>
<li>Block的内存管理</li>
<li>怎样理解Block截获变量的特性<ul>
<li>截获基本数据类型的变量，是截获其值</li>
<li>截获对象类型是截获其修饰符和变量</li>
<li>截获静态变量是截获其指针</li>
</ul>
</li>
<li>你都遇到过哪些循环引用？你是怎么解决的？<ul>
<li>Block本身是对象的变量，Block又捕获了这个对象的变量，会产生循环引用</li>
</ul>
</li>
</ul>
<h5 id="12-1、什么是Block"><a href="#12-1、什么是Block" class="headerlink" title="12.1、什么是Block"></a>12.1、什么是Block</h5><ul>
<li>Block是将函数及其执行上下文封装起来的对象</li>
<li>Block调用即是函数调用</li>
<li>Block的底层结构：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">   <span class="keyword">void</span> *isa;<span class="comment">// isa指针，Block是对象的标志</span></span><br><span class="line">   <span class="keyword">int</span> Flags;</span><br><span class="line">   <span class="keyword">int</span> Reserved;</span><br><span class="line">   <span class="keyword">void</span> *FuncPtr;<span class="comment">// 函数指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="12-2、Block如何截获变量"><a href="#12-2、Block如何截获变量" class="headerlink" title="12.2、Block如何截获变量"></a>12.2、Block如何截获变量</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int multiplier &#x3D; 6;</span><br><span class="line">int (^ Block)(int) &#x3D; ^ int(int num) &#123;</span><br><span class="line">    return num * multiplier;</span><br><span class="line">&#125;;</span><br><span class="line">multiplier &#x3D; 4;</span><br><span class="line">NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;%d&quot;,Block(2));</span><br><span class="line">&#x2F;&#x2F; 打印结果</span><br><span class="line">&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;12</span><br></pre></td></tr></table></figure>
<h6 id="12-2-2、被截获变量的类型分类："><a href="#12-2-2、被截获变量的类型分类：" class="headerlink" title="12.2.2、被截获变量的类型分类："></a>12.2.2、被截获变量的类型分类：</h6><ul>
<li>局部变量<ul>
<li>基本数据类型</li>
<li>对象类型</li>
</ul>
</li>
<li>静态局部变量</li>
<li>全局变量</li>
<li>静态全局变量</li>
</ul>
<p>12.2.3、截获变量</p>
<ul>
<li>对于基本数据类型的局部变量截获其值</li>
<li>对于对象类型的局部变量连同所有权修饰符一起截获</li>
<li>以指针形式截获局部静态变量</li>
<li>不截获全局变量、静态全局变量</li>
</ul>
<h6 id="12-2-4、Block截获变量源码"><a href="#12-2-4、Block截获变量源码" class="headerlink" title="12.2.4、Block截获变量源码"></a>12.2.4、Block截获变量源码</h6><p>使用命令将OC代码转成C++代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clang -rewrite-objc -fobjc-arc ***.m</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局变量</span><br><span class="line">int gloabal_var &#x3D; 4;</span><br><span class="line">&#x2F;&#x2F; 全局静态变量</span><br><span class="line">static int static_global_var &#x3D; 5;</span><br><span class="line"></span><br><span class="line">@implementation BlockTest</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        [self testMethod];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)testMethod &#123;</span><br><span class="line">    &#x2F;&#x2F; 基本数据类型的局部变量</span><br><span class="line">    int var_num &#x3D; 10086;</span><br><span class="line">    &#x2F;&#x2F; 对象类型的局部变量</span><br><span class="line">    __unsafe_unretained id unsafa_obj &#x3D; nil;</span><br><span class="line">    __strong id strong_obj &#x3D; nil;</span><br><span class="line">    &#x2F;&#x2F; 局部静态变量</span><br><span class="line">    static int static_var_num &#x3D; 1008611;</span><br><span class="line">    </span><br><span class="line">    void (^Block)(void) &#x3D; ^&#123;</span><br><span class="line">        NSLog(@&quot;局部变量&lt;基本数据类型&gt; %d&quot;,var_num);</span><br><span class="line">        NSLog(@&quot;对象类型的局部变量:%@,%@&quot;,unsafa_obj,strong_obj);</span><br><span class="line">        NSLog(@&quot;局部静态变量:%d&quot;,static_var_num);</span><br><span class="line">        NSLog(@&quot;全局变量:%d&quot;,gloabal_var);</span><br><span class="line">        NSLog(@&quot;全局静态变量:%d&quot;,static_global_var);</span><br><span class="line">    &#125;;</span><br><span class="line">    Block();</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>编译结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">BlockTest__testMethod_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">BlockTest__testMethod_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> var_num;</span><br><span class="line">  __unsafe_unretained id unsafa_obj;</span><br><span class="line">  __strong id strong_obj;</span><br><span class="line">  <span class="keyword">int</span> *static_var_num;</span><br><span class="line">  __BlockTest__testMethod_block_impl_0(<span class="keyword">void</span> *fp, struct __BlockTest__testMethod_block_desc_0 *desc, <span class="keyword">int</span> _var_num, __unsafe_unretained id _unsafa_obj, __strong id _strong_obj, <span class="keyword">int</span> *_static_var_num, <span class="keyword">int</span> flags=<span class="number">0</span>) : var_num(_var_num), unsafa_obj(_unsafa_obj), strong_obj(_strong_obj), static_var_num(_static_var_num) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="12-2-5、-block修饰符"><a href="#12-2-5、-block修饰符" class="headerlink" title="12.2.5、__block修饰符"></a>12.2.5、__block修饰符</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__block int multiplier &#x3D; 6;</span><br><span class="line">int (^ Block)(int) &#x3D; ^ int(int num) &#123;</span><br><span class="line">   return num * multiplier;</span><br><span class="line">&#125;;</span><br><span class="line">multiplier &#x3D; 4;</span><br><span class="line">NSLog(@&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;%d&quot;,Block(2));</span><br><span class="line">&#x2F;&#x2F; 打印结果</span><br><span class="line">&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;8</span><br></pre></td></tr></table></figure>
<ul>
<li>__block修饰的变量变成了对象</li>
</ul>
<h5 id="12-3、Block内存管理"><a href="#12-3、Block内存管理" class="headerlink" title="12.3、Block内存管理"></a>12.3、Block内存管理</h5><h6 id="12-3-1、Block的分类"><a href="#12-3-1、Block的分类" class="headerlink" title="12.3.1、Block的分类"></a>12.3.1、Block的分类</h6><ul>
<li>全局类型 _NSConcreteGloabalBlock  存储于已初始化内存区中</li>
<li>堆类型 _NSConcreateStackBlock</li>
<li>栈类型 _NSConcreateMallocBlock</li>
</ul>
<h6 id="12-3-2、Block的copy操作"><a href="#12-3-2、Block的copy操作" class="headerlink" title="12.3.2、Block的copy操作"></a>12.3.2、Block的copy操作</h6><table>
<thead>
<tr>
<th align="center">Block类别</th>
<th align="center">源</th>
<th align="center">Copy结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">堆类型 _NSConcreateStackBlock</td>
<td align="center">栈</td>
<td align="center">堆</td>
</tr>
<tr>
<td align="center">栈类型 _NSConcreateMallocBlock</td>
<td align="center">数据区</td>
<td align="center">什么也不做</td>
</tr>
<tr>
<td align="center">全局类型 _NSConcreteGloabalBlock</td>
<td align="center">堆</td>
<td align="center">增加引用计数</td>
</tr>
</tbody></table>
<h6 id="12-3-3-解决循环引用问题"><a href="#12-3-3-解决循环引用问题" class="headerlink" title="12.3.3 解决循环引用问题"></a>12.3.3 解决循环引用问题</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (strong, nonatomic) NSArray &lt;NSString *&gt; *array;</span><br><span class="line">@property (copy, nonatomic)  NSString *(^strBlock)(NSString *);</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        </span><br><span class="line">        _array &#x3D; [NSMutableArray arrayWithObject:@&quot;block&quot;];</span><br><span class="line">        _strBlock &#x3D; ^NSString *(NSString *num) &#123;</span><br><span class="line">            return  _array[0]; &#x2F;&#x2F; Capturing &#39;self&#39; strongly in this block is likely to lead to a retain cycle</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__weak NSArray &lt;NSString *&gt; *weakArray &#x3D; _array;</span><br><span class="line">_strBlock &#x3D; ^NSString *(NSString *num) &#123;</span><br><span class="line">     return  weakArray[0];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="12-3-4、-block造成循环引用"><a href="#12-3-4、-block造成循环引用" class="headerlink" title="12.3.4、__block造成循环引用"></a>12.3.4、__block造成循环引用</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (copy, nonatomic) NSString *varNum;</span><br><span class="line">@property (copy, nonatomic) int(^numBlock)(int);</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        [self testMethod];</span><br><span class="line">      </span><br><span class="line">        _varNum &#x3D; @&quot;3&quot;;</span><br><span class="line">        __block BlockTest *blockSelf &#x3D; self;</span><br><span class="line">        _numBlock &#x3D; ^int(int num) &#123;</span><br><span class="line">            return  num * [blockSelf.varNum intValue];</span><br><span class="line">        &#125;;</span><br><span class="line">        int blockNum &#x3D; _numBlock(10);</span><br><span class="line">        NSLog(@&quot;blockNum&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;%d&quot;,blockNum);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在MRC下不会产生循环引用</p>
</li>
<li><p>在ARC下，会产生循环引用引起内存泄漏</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_numBlock &#x3D; ^int(int num) &#123;</span><br><span class="line">     int result &#x3D; num * [blockSelf.varNum intValue];</span><br><span class="line">     blockSelf &#x3D; nil;</span><br><span class="line">     return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="13、RunTime"><a href="#13、RunTime" class="headerlink" title="13、RunTime"></a>13、RunTime</h3><h5 id="13-1、常见面试问题"><a href="#13-1、常见面试问题" class="headerlink" title="13.1、常见面试问题"></a>13.1、常见面试问题</h5><ul>
<li>对象、类对象、元类对象</li>
<li>消息传递机制</li>
<li>消息转发流程</li>
<li>方法缓存</li>
<li>Method-Swizzling</li>
<li>动态添加方法</li>
</ul>
<h3 id="14、RunLoop"><a href="#14、RunLoop" class="headerlink" title="14、RunLoop"></a>14、RunLoop</h3><h5 id="14-0、常见面试问题"><a href="#14-0、常见面试问题" class="headerlink" title="14.0、常见面试问题"></a>14.0、常见面试问题</h5><ul>
<li>RunLoop的概念</li>
<li>Mode/Spurce/Timer/Observer</li>
<li>事件循环机制</li>
<li>RunLoop与Timer的关系</li>
<li>RunLoop和线程之间的关系</li>
<li>常驻线程</li>
</ul>
<h5 id="14-1、RunLoop的概念"><a href="#14-1、RunLoop的概念" class="headerlink" title="14.1、RunLoop的概念"></a>14.1、RunLoop的概念</h5><p>RunLoop是通过内部的事件循环来对事件/消息进行管理的一个对象。RunLoop可以不断的接收消息，如点击屏幕、滑动列表,接收到消息之后会对事件进行处理，处理完成之后会进入内核态等待。这里的等待并不是一个简单的等待或者循环，重点是状态的切换。</p>
<h5 id="14-2、事件循环机制"><a href="#14-2、事件循环机制" class="headerlink" title="14.2、事件循环机制"></a>14.2、事件循环机制</h5><ul>
<li>没有消息需要处理时，休眠以避免资源占用 （用户态 –&gt;转换时调用<code>mach_msg()</code>方法–&gt; 内核态）</li>
<li>有消息需要处理时，立即被唤醒 （内核态 –&gt; 转换时调用<code>mach_msg()</code>方法–&gt; 用户态 ）</li>
</ul>
<h6 id="14-2-1、为什么main函数不会退出"><a href="#14-2-1、为什么main函数不会退出" class="headerlink" title="14.2.1、为什么main函数不会退出"></a>14.2.1、为什么main函数不会退出</h6><p>  在main函数中维护着一个RunLoop，</p>
<h5 id="14-3、RunLoop与NSTimer"><a href="#14-3、RunLoop与NSTimer" class="headerlink" title="14.3、RunLoop与NSTimer"></a>14.3、RunLoop与NSTimer</h5><p>滑动TableView的时候我们的定时器还会生效吗？</p>
<ul>
<li>正常情况下，Timer是运行在RunLoopDefaultMode模式下，当UITableView滑动时会发生一个RunLoop的Mode的切换，会切换到UITrackingRunLoopMode</li>
<li>可以使用<code>addTimer()</code>同步添加到多个Mode中</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timer <span class="operator">=</span> <span class="type">Timer</span>.scheduledTimer(withTimeInterval: <span class="number">1</span>, repeats: <span class="literal">true</span>) &#123; (time) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;------------time&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> runLoop <span class="operator">=</span> <span class="type">RunLoop</span>.current</span><br><span class="line">runLoop.add(timer, forMode: .common)</span><br></pre></td></tr></table></figure>
<h5 id="14-4、RunLoop的Mode"><a href="#14-4、RunLoop的Mode" class="headerlink" title="14.4、RunLoop的Mode"></a>14.4、RunLoop的Mode</h5><p>RunLoop有多个Mode，运行到不同的Mode上时，只能接收到当前Mode上的事件，例如UI Mode下只能接收到屏幕点击，上下滑动的事件。一个Timer 要想加入到多个Mode当中呢，</p>
<ul>
<li>CommonMode是一个特殊的Mode，CommonMode不是实际存在的一种Mode，</li>
<li>CommonMode是同步到Timer/Source/Observer到多个Mode的一种技术方案</li>
</ul>
<h5 id="14-5、RunLoop与多线程"><a href="#14-5、RunLoop与多线程" class="headerlink" title="14.5、RunLoop与多线程"></a>14.5、RunLoop与多线程</h5><ul>
<li>线程和RunLoop是一一对应的关系。</li>
<li>线程中的RunLoop并没有创建需要手动创建，此处引出常驻线程。<ul>
<li>为当前线程开启一个RunLoop</li>
<li>向当前RunLoop中添加一个Port/Source等位置RunLoop的事件循环</li>
<li>启动该RunLoop</li>
</ul>
</li>
</ul>
<h5 id="14-6、RunLoop数据结构"><a href="#14-6、RunLoop数据结构" class="headerlink" title="14.6、RunLoop数据结构"></a>14.6、RunLoop数据结构</h5><ul>
<li>RunLoop是CGRunLoop的封装，提供了面向对象的API。</li>
<li>CFRunLoop<ul>
<li>pthread 线程相关，RunLoop和线程是一一对应的关系</li>
<li>currentMode </li>
<li>modes</li>
<li>commonModes</li>
<li>commonModeItems</li>
</ul>
</li>
<li>CGRunLoopMode</li>
<li>Source/Timer/Observer</li>
</ul>
]]></content>
  </entry>
</search>
